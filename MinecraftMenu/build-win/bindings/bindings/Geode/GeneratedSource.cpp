
#include <stdexcept>
#include <Geode/Bindings.hpp>
#include <Geode/utils/addresser.hpp>
#include <Geode/modify/Traits.hpp>
#include <Geode/loader/Tulip.hpp>

using namespace geode;
using namespace geode::modifier;
using cocos2d::CCDestructor;

std::unordered_map<void*, bool>& CCDestructor::destructorLock() {{
	static thread_local std::unordered_map<void*, bool> ret;
	return ret;
}}
bool& CCDestructor::globalLock() {{
	static thread_local bool ret = false;
	return ret; 
}}
bool& CCDestructor::lock(void* self) {
	return destructorLock()[self];
}
CCDestructor::~CCDestructor() {{
	destructorLock().erase(this);
}}

auto wrapFunction(uintptr_t address, tulip::hook::WrapperMetadata const& metadata) {
	auto wrapped = geode::hook::createWrapper(reinterpret_cast<void*>(address), metadata);
	if (wrapped.isErr()) {{
		throw std::runtime_error(wrapped.unwrapErr());
	}}
	return wrapped.unwrap();
}

// So apparently Clang considers cdecl to return floats through ST0, whereas 
// MSVC thinks they are returned through XMM0. This has caused a lot of pain 
// and misery for me


auto cocos2d::CCLightning::lightningWithStrikePoint(cocos2d::CCPoint p0, cocos2d::CCPoint p1, float p2) -> decltype(lightningWithStrikePoint(p0, p1, p2)) {
	using FunctionType = decltype(lightningWithStrikePoint(p0, p1, p2))(*)(cocos2d::CCPoint, cocos2d::CCPoint, float);
	static auto func = wrapFunction(base::get() + 0x44540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

cocos2d::CCLightning* cocos2d::CCLightning::lightningWithStrikePoint(cocos2d::CCPoint p1) {
    	auto ret = new CCLightning();
    	if (ret->initWithStrikePoint(p1)) {
    		ret->autorelease();
    		return ret;
    	}
    	delete ret;
    	return nullptr;
    }

auto cocos2d::CCLightning::initWithStrikePoint(cocos2d::CCPoint p0, cocos2d::CCPoint p1, float p2) -> decltype(initWithStrikePoint(p0, p1, p2)) {
	using FunctionType = decltype(initWithStrikePoint(p0, p1, p2))(*)(cocos2d::CCLightning*, cocos2d::CCPoint, cocos2d::CCPoint, float);
	static auto func = wrapFunction(base::get() + 0x439e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

bool cocos2d::CCLightning::initWithStrikePoint(cocos2d::CCPoint p1) {
    	return this->initWithStrikePoint(p1, CCPointZero, .5f);
    }

cocos2d::CCLightning::CCLightning() : cocos2d::CCLightning(geode::CutoffConstructor, sizeof(cocos2d::CCLightning)) {
	// here we construct it as normal as we can, then destruct it
	// using the generated functions. this ensures no memory gets leaked
	// no crashes :pray:
	CCDestructor::lock(this) = true;
	cocos2d::CCLightning::~CCLightning();
	using FunctionType = void(*)(cocos2d::CCLightning*);
	static auto func = wrapFunction(base::get() + 0x44400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
}

cocos2d::CCLightning::~CCLightning() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(cocos2d::CCLightning*);
	static auto func = wrapFunction(base::get() + 0x444d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) cocos2d::CCLightning(geode::CutoffConstructor, sizeof(cocos2d::CCLightning));
	CCDestructor::lock(this) = true;
}

auto cocos2d::CCLightning::strike() -> decltype(strike()) {
	using FunctionType = decltype(strike())(*)(cocos2d::CCLightning*);
	static auto func = wrapFunction(base::get() + 0x44880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCLightning::strikeFinished() -> decltype(strikeFinished()) {
	using FunctionType = decltype(strikeFinished())(*)(cocos2d::CCLightning*);
	static auto func = wrapFunction(base::get() + 0x448f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void cocos2d::CCLightning::strikeRandom() {
    	m_seed = rand();
    	this->strike();
    }

void cocos2d::CCLightning::strikeWithSeed(uint64_t seed) {
    	m_seed = seed;
    	this->strike();
    }

auto cocos2d::CCLightning::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLightning::draw), this);
	using FunctionType = decltype(draw())(*)(cocos2d::CCLightning*);
	static auto func = wrapFunction(base::get() + 0x44700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLightning::isOpacityModifyRGB() -> decltype(isOpacityModifyRGB()) {
	throw std::runtime_error("cocos2d::CCLightning::isOpacityModifyRGB not implemented");
}

auto cocos2d::CCLightning::setOpacityModifyRGB(bool p0) -> decltype(setOpacityModifyRGB(p0)) {
	throw std::runtime_error("cocos2d::CCLightning::setOpacityModifyRGB not implemented");
}

auto cocos2d::CCLightning::getOpacity() -> decltype(getOpacity()) {
	throw std::runtime_error("cocos2d::CCLightning::getOpacity not implemented");
}

auto cocos2d::CCLightning::getDisplayedOpacity() -> decltype(getDisplayedOpacity()) {
	throw std::runtime_error("cocos2d::CCLightning::getDisplayedOpacity not implemented");
}

auto cocos2d::CCLightning::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	throw std::runtime_error("cocos2d::CCLightning::setOpacity not implemented");
}

auto cocos2d::CCLightning::updateDisplayedOpacity(unsigned char p0) -> decltype(updateDisplayedOpacity(p0)) {
	throw std::runtime_error("cocos2d::CCLightning::updateDisplayedOpacity not implemented");
}

auto cocos2d::CCLightning::isCascadeOpacityEnabled() -> decltype(isCascadeOpacityEnabled()) {
	throw std::runtime_error("cocos2d::CCLightning::isCascadeOpacityEnabled not implemented");
}

auto cocos2d::CCLightning::setCascadeOpacityEnabled(bool p0) -> decltype(setCascadeOpacityEnabled(p0)) {
	throw std::runtime_error("cocos2d::CCLightning::setCascadeOpacityEnabled not implemented");
}

auto cocos2d::CCLightning::getColor() -> decltype(getColor()) {
	throw std::runtime_error("cocos2d::CCLightning::getColor not implemented");
}

auto cocos2d::CCLightning::getDisplayedColor() -> decltype(getDisplayedColor()) {
	throw std::runtime_error("cocos2d::CCLightning::getDisplayedColor not implemented");
}

auto cocos2d::CCLightning::setColor(cocos2d::_ccColor3B const& p0) -> decltype(setColor(p0)) {
	throw std::runtime_error("cocos2d::CCLightning::setColor not implemented");
}

auto cocos2d::CCLightning::updateDisplayedColor(cocos2d::_ccColor3B const& p0) -> decltype(updateDisplayedColor(p0)) {
	throw std::runtime_error("cocos2d::CCLightning::updateDisplayedColor not implemented");
}

auto cocos2d::CCLightning::isCascadeColorEnabled() -> decltype(isCascadeColorEnabled()) {
	throw std::runtime_error("cocos2d::CCLightning::isCascadeColorEnabled not implemented");
}

auto cocos2d::CCLightning::setCascadeColorEnabled(bool p0) -> decltype(setCascadeColorEnabled(p0)) {
	throw std::runtime_error("cocos2d::CCLightning::setCascadeColorEnabled not implemented");
}

GJDropDownLayer* GJDropDownLayer::create(const char* title, float height, bool p2) {
        GJDropDownLayer* pRet = new GJDropDownLayer();
        if (pRet && pRet->init(title, height, p2)) {
            pRet->autorelease();
            return pRet;
        }
        CC_SAFE_DELETE(pRet);
        return nullptr;
    }

GJDropDownLayer* GJDropDownLayer::create(const char* title) {
        GJDropDownLayer* pRet = new GJDropDownLayer();
        if (pRet && pRet->init(title)) {
            pRet->autorelease();
            return pRet;
        }
        CC_SAFE_DELETE(pRet);
        return nullptr;
    }

auto GJDropDownLayer::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJDropDownLayer::draw), this);
	using FunctionType = decltype(draw())(*)(GJDropDownLayer*);
	static auto func = wrapFunction(base::get() + 0x426f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJDropDownLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJDropDownLayer::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(GJDropDownLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x3c6a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void GJDropDownLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

void GJDropDownLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

void GJDropDownLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

auto GJDropDownLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJDropDownLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(GJDropDownLayer*);
	static auto func = wrapFunction(base::get() + 0x425d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJDropDownLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJDropDownLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(GJDropDownLayer*);
	static auto func = wrapFunction(base::get() + 0x250330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void GJDropDownLayer::customSetup() {}

auto GJDropDownLayer::enterLayer() -> decltype(enterLayer()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJDropDownLayer::enterLayer), this);
	using FunctionType = decltype(enterLayer())(*)(GJDropDownLayer*);
	static auto func = wrapFunction(base::get() + 0x425a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJDropDownLayer::exitLayer(cocos2d::CCObject* p0) -> decltype(exitLayer(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&GJDropDownLayer::exitLayer), this);
	using FunctionType = decltype(exitLayer(p0))(*)(GJDropDownLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x250350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJDropDownLayer::showLayer(bool p0) -> decltype(showLayer(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&GJDropDownLayer::showLayer), this);
	using FunctionType = decltype(showLayer(p0))(*)(GJDropDownLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x250390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJDropDownLayer::hideLayer(bool p0) -> decltype(hideLayer(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&GJDropDownLayer::hideLayer), this);
	using FunctionType = decltype(hideLayer(p0))(*)(GJDropDownLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x2504e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJDropDownLayer::layerVisible() -> decltype(layerVisible()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJDropDownLayer::layerVisible), this);
	using FunctionType = decltype(layerVisible())(*)(GJDropDownLayer*);
	static auto func = wrapFunction(base::get() + 0x426a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJDropDownLayer::layerHidden() -> decltype(layerHidden()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJDropDownLayer::layerHidden), this);
	using FunctionType = decltype(layerHidden())(*)(GJDropDownLayer*);
	static auto func = wrapFunction(base::get() + 0x250630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void GJDropDownLayer::enterAnimFinished() {}

auto GJDropDownLayer::disableUI() -> decltype(disableUI()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJDropDownLayer::disableUI), this);
	using FunctionType = decltype(disableUI())(*)(GJDropDownLayer*);
	static auto func = wrapFunction(base::get() + 0x2502f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJDropDownLayer::enableUI() -> decltype(enableUI()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJDropDownLayer::enableUI), this);
	using FunctionType = decltype(enableUI())(*)(GJDropDownLayer*);
	static auto func = wrapFunction(base::get() + 0x250310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJDropDownLayer::init(char const* p0, float p1, bool p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(GJDropDownLayer*, char const*, float, bool);
	static auto func = wrapFunction(base::get() + 0x24feb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

bool GJDropDownLayer::init(char const* title) {
        return init(title, 220.0f, false);
    }

auto GJAccountDelegate::accountStatusChanged() -> decltype(accountStatusChanged()) {
	throw std::runtime_error("GJAccountDelegate::accountStatusChanged not implemented");
}

void FLAlertLayerProtocol::FLAlert_Clicked(FLAlertLayer* p0, bool p1) {}

auto AccountHelpLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AccountHelpLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(AccountHelpLayer*);
	static auto func = wrapFunction(base::get() + 0x7f5c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AccountHelpLayer::layerHidden() -> decltype(layerHidden()) {
	throw std::runtime_error("AccountHelpLayer::layerHidden not implemented");
}

auto AccountHelpLayer::accountStatusChanged() -> decltype(accountStatusChanged()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AccountHelpLayer::accountStatusChanged), this);
	using FunctionType = decltype(accountStatusChanged())(*)(AccountHelpLayer*);
	static auto func = wrapFunction(base::get() + 0x7fcc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AccountHelpLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&AccountHelpLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(AccountHelpLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x7ffa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto AccountHelpLayer::onAccountManagement(cocos2d::CCObject* sender) -> decltype(onAccountManagement(sender)) {
	using FunctionType = decltype(onAccountManagement(sender))(*)(AccountHelpLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x7fa10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto AccountHelpLayer::onUnlink(cocos2d::CCObject* sender) -> decltype(onUnlink(sender)) {
	using FunctionType = decltype(onUnlink(sender))(*)(AccountHelpLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x7fb20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto AccountHelpLayer::updatePage() -> decltype(updatePage()) {
	using FunctionType = decltype(updatePage())(*)(AccountHelpLayer*);
	static auto func = wrapFunction(base::get() + 0x7fcd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJAccountBackupDelegate::backupAccountFinished() -> decltype(backupAccountFinished()) {
	throw std::runtime_error("GJAccountBackupDelegate::backupAccountFinished not implemented");
}

auto GJAccountBackupDelegate::backupAccountFailed(BackupAccountError p0, int p1) -> decltype(backupAccountFailed(p0, p1)) {
	throw std::runtime_error("GJAccountBackupDelegate::backupAccountFailed not implemented");
}

auto GJAccountSyncDelegate::syncAccountFinished() -> decltype(syncAccountFinished()) {
	throw std::runtime_error("GJAccountSyncDelegate::syncAccountFinished not implemented");
}

auto GJAccountSyncDelegate::syncAccountFailed(BackupAccountError p0, int p1) -> decltype(syncAccountFailed(p0, p1)) {
	throw std::runtime_error("GJAccountSyncDelegate::syncAccountFailed not implemented");
}

auto AccountLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x7d560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto AccountLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AccountLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(AccountLayer*);
	static auto func = wrapFunction(base::get() + 0x7d6c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AccountLayer::layerHidden() -> decltype(layerHidden()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AccountLayer::layerHidden), this);
	using FunctionType = decltype(layerHidden())(*)(AccountLayer*);
	static auto func = wrapFunction(base::get() + 0x7f450, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AccountLayer::backupAccountFinished() -> decltype(backupAccountFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AccountLayer::backupAccountFinished), this);
	using FunctionType = decltype(backupAccountFinished())(*)(AccountLayer*);
	static auto func = wrapFunction(base::get() + 0x7eb30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AccountLayer::backupAccountFailed(BackupAccountError p0, int p1) -> decltype(backupAccountFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<BackupAccountError, int>::func(&AccountLayer::backupAccountFailed), this);
	using FunctionType = decltype(backupAccountFailed(p0, p1))(*)(AccountLayer*, BackupAccountError, int);
	static auto func = wrapFunction(base::get() + 0x7ece0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto AccountLayer::syncAccountFinished() -> decltype(syncAccountFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AccountLayer::syncAccountFinished), this);
	using FunctionType = decltype(syncAccountFinished())(*)(AccountLayer*);
	static auto func = wrapFunction(base::get() + 0x7eff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AccountLayer::syncAccountFailed(BackupAccountError p0, int p1) -> decltype(syncAccountFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<BackupAccountError, int>::func(&AccountLayer::syncAccountFailed), this);
	using FunctionType = decltype(syncAccountFailed(p0, p1))(*)(AccountLayer*, BackupAccountError, int);
	static auto func = wrapFunction(base::get() + 0x7f1b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto AccountLayer::accountStatusChanged() -> decltype(accountStatusChanged()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AccountLayer::accountStatusChanged), this);
	using FunctionType = decltype(accountStatusChanged())(*)(AccountLayer*);
	static auto func = wrapFunction(base::get() + 0x7e750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AccountLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&AccountLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(AccountLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x7f340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void AccountLayer::doBackup() {
        this->updatePage(false);
        if (!GJAccountManager::sharedState()->getAccountBackupURL()) this->backupAccountFailed((BackupAccountError)-1, 0);
        else this->showLoadingUI();
    }

void AccountLayer::doSync() {
        this->updatePage(false);
        if (!GJAccountManager::sharedState()->getAccountSyncURL()) this->syncAccountFailed((BackupAccountError)-1, 0);
        else this->showLoadingUI();
    }

void AccountLayer::exitLayer() {
        this->setKeypadEnabled(false);
        this->disableUI();
        this->hideLayer(m_fastMenu);
    }

void AccountLayer::hideLoadingUI() {
        this->toggleUI(true);
        m_loadingCircle->setVisible(false);
    }

auto AccountLayer::onRegister(cocos2d::CCObject* sender) -> decltype(onRegister(sender)) {
	using FunctionType = decltype(onRegister(sender))(*)(AccountLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x7de50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

void AccountLayer::showLoadingUI() {
        this->toggleUI(false);
        m_loadingCircle->setVisible(true);
    }

void AccountLayer::toggleUI(bool enable) {
        m_buttonMenu->setEnabled(enable);
        this->setKeypadEnabled(enable);
    }

auto AccountLayer::updatePage(bool p0) -> decltype(updatePage(p0)) {
	using FunctionType = decltype(updatePage(p0))(*)(AccountLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x7e760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

FLAlertLayer::FLAlertLayer() { // ios 0xa7ec : this seems too small?
        m_buttonMenu = nullptr;
        m_controlConnected = -1;
        m_mainLayer = nullptr;
        m_ZOrder = 0;
        m_noElasticity = false;
        m_reverseKeyBack = false;
        m_scene = nullptr;
        m_alertProtocol = nullptr;
        m_scrollingLayer = nullptr;
        m_button2 = nullptr;
        m_button1 = nullptr;
        m_joystickConnected = -1;
        m_containsBorder = 0;
        m_forcePrioRegistered = false;
    }

FLAlertLayer::~FLAlertLayer() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(FLAlertLayer*);
	static auto func = wrapFunction(base::get() + 0x517e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) FLAlertLayer(geode::CutoffConstructor, sizeof(FLAlertLayer));
	CCDestructor::lock(this) = true;
}

auto FLAlertLayer::create(FLAlertLayerProtocol* delegate, char const* title, gd::string desc, char const* btn1, char const* btn2, float width, bool scroll, float height, float textScale) -> decltype(create(delegate, title, desc, btn1, btn2, width, scroll, height, textScale)) {
	using FunctionType = decltype(create(delegate, title, desc, btn1, btn2, width, scroll, height, textScale))(*)(FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float, bool, float, float);
	static auto func = wrapFunction(base::get() + 0x51940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(delegate, title, desc, btn1, btn2, width, scroll, height, textScale);
}

auto FLAlertLayer::create(FLAlertLayerProtocol* delegate, char const* title, gd::string desc, char const* btn1, char const* btn2, float width) -> decltype(create(delegate, title, desc, btn1, btn2, width)) {
	using FunctionType = decltype(create(delegate, title, desc, btn1, btn2, width))(*)(FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float);
	static auto func = wrapFunction(base::get() + 0x51890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(delegate, title, desc, btn1, btn2, width);
}

FLAlertLayer* FLAlertLayer::create(FLAlertLayerProtocol* delegate, char const* title, gd::string desc, char const* btn1, char const* btn2) {
        return FLAlertLayer::create(delegate, title, desc, btn1, btn2, 300.0);
    }

FLAlertLayer* FLAlertLayer::create(char const* title, const gd::string& desc, char const* btn) {
        return FLAlertLayer::create(nullptr, title, desc, btn, nullptr, 300.0);
    }

auto FLAlertLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&FLAlertLayer::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(FLAlertLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x52a00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FLAlertLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&FLAlertLayer::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(FLAlertLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x52b50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FLAlertLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&FLAlertLayer::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(FLAlertLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x52aa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FLAlertLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&FLAlertLayer::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(FLAlertLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x52b10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FLAlertLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FLAlertLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(FLAlertLayer*);
	static auto func = wrapFunction(base::get() + 0x52d60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FLAlertLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FLAlertLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(FLAlertLayer*);
	static auto func = wrapFunction(base::get() + 0x52880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FLAlertLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&FLAlertLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(FLAlertLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x52800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto FLAlertLayer::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FLAlertLayer::show), this);
	using FunctionType = decltype(show())(*)(FLAlertLayer*);
	static auto func = wrapFunction(base::get() + 0x52b90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FLAlertLayer::init(FLAlertLayerProtocol* p0, char const* p1, gd::string p2, char const* p3, char const* p4, float p5, bool p6, float p7, float p8) -> decltype(init(p0, p1, p2, p3, p4, p5, p6, p7, p8)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5, p6, p7, p8))(*)(FLAlertLayer*, FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float, bool, float, float);
	static auto func = wrapFunction(base::get() + 0x51b60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7, p8);
}

auto FLAlertLayer::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(FLAlertLayer*, int);
	static auto func = wrapFunction(base::get() + 0x51a50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FLAlertLayer::onBtn1(cocos2d::CCObject* sender) -> decltype(onBtn1(sender)) {
	using FunctionType = decltype(onBtn1(sender))(*)(FLAlertLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x52940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto FLAlertLayer::onBtn2(cocos2d::CCObject* sender) -> decltype(onBtn2(sender)) {
	using FunctionType = decltype(onBtn2(sender))(*)(FLAlertLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x529a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

void TextInputDelegate::textChanged(CCTextInputNode* p0) {}

void TextInputDelegate::textInputOpened(CCTextInputNode* p0) {}

void TextInputDelegate::textInputClosed(CCTextInputNode* p0) {}

void TextInputDelegate::textInputShouldOffset(CCTextInputNode* p0, float p1) {}

void TextInputDelegate::textInputReturn(CCTextInputNode* p0) {}

bool TextInputDelegate::allowTextInput(CCTextInputNode* p0) { return true; }

void TextInputDelegate::enterPressed(CCTextInputNode* p0) {}

auto GJAccountLoginDelegate::loginAccountFinished(int p0, int p1) -> decltype(loginAccountFinished(p0, p1)) {
	throw std::runtime_error("GJAccountLoginDelegate::loginAccountFinished not implemented");
}

auto GJAccountLoginDelegate::loginAccountFailed(AccountError p0) -> decltype(loginAccountFailed(p0)) {
	throw std::runtime_error("GJAccountLoginDelegate::loginAccountFailed not implemented");
}

auto AccountLoginLayer::create(gd::string p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(gd::string);
	static auto func = wrapFunction(base::get() + 0x7b730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto AccountLoginLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("AccountLoginLayer::registerWithTouchDispatcher not implemented");
}

auto AccountLoginLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AccountLoginLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(AccountLoginLayer*);
	static auto func = wrapFunction(base::get() + 0x7cfa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AccountLoginLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&AccountLoginLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(AccountLoginLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x7cb50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void AccountLoginLayer::textInputOpened(CCTextInputNode* p0) {}

auto AccountLoginLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&AccountLoginLayer::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(AccountLoginLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x7d070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

void AccountLoginLayer::textChanged(CCTextInputNode* p0) {}

auto AccountLoginLayer::loginAccountFinished(int p0, int p1) -> decltype(loginAccountFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&AccountLoginLayer::loginAccountFinished), this);
	using FunctionType = decltype(loginAccountFinished(p0, p1))(*)(AccountLoginLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x7c740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto AccountLoginLayer::loginAccountFailed(AccountError p0) -> decltype(loginAccountFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<AccountError>::func(&AccountLoginLayer::loginAccountFailed), this);
	using FunctionType = decltype(loginAccountFailed(p0))(*)(AccountLoginLayer*, AccountError);
	static auto func = wrapFunction(base::get() + 0x7c990, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AccountLoginLayer::init(gd::string p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(AccountLoginLayer*, gd::string);
	static auto func = wrapFunction(base::get() + 0x7b8d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto AccountLoginLayer::onForgotPassword(cocos2d::CCObject* sender) -> decltype(onForgotPassword(sender)) {
	using FunctionType = decltype(onForgotPassword(sender))(*)(AccountLoginLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x7c490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto AccountLoginLayer::onForgotUser(cocos2d::CCObject* sender) -> decltype(onForgotUser(sender)) {
	using FunctionType = decltype(onForgotUser(sender))(*)(AccountLoginLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x7c470, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto AccountLoginLayer::onSubmit(cocos2d::CCObject* sender) -> decltype(onSubmit(sender)) {
	using FunctionType = decltype(onSubmit(sender))(*)(AccountLoginLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x7cbc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJAccountRegisterDelegate::registerAccountFinished() -> decltype(registerAccountFinished()) {
	throw std::runtime_error("GJAccountRegisterDelegate::registerAccountFinished not implemented");
}

auto GJAccountRegisterDelegate::registerAccountFailed(AccountError p0) -> decltype(registerAccountFailed(p0)) {
	throw std::runtime_error("GJAccountRegisterDelegate::registerAccountFailed not implemented");
}

auto AccountRegisterLayer::init() -> decltype(init()) {
	throw std::runtime_error("AccountRegisterLayer::init not implemented");
}

auto AccountRegisterLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("AccountRegisterLayer::registerWithTouchDispatcher not implemented");
}

auto AccountRegisterLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AccountRegisterLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(AccountRegisterLayer*);
	static auto func = wrapFunction(base::get() + 0x7abf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AccountRegisterLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&AccountRegisterLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(AccountRegisterLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x7a200, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void AccountRegisterLayer::textInputOpened(CCTextInputNode* p0) {}

auto AccountRegisterLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&AccountRegisterLayer::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(AccountRegisterLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x7ad50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

void AccountRegisterLayer::textChanged(CCTextInputNode* p0) {}

auto AccountRegisterLayer::textInputShouldOffset(CCTextInputNode* p0, float p1) -> decltype(textInputShouldOffset(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*, float>::func(&AccountRegisterLayer::textInputShouldOffset), this);
	using FunctionType = decltype(textInputShouldOffset(p0, p1))(*)(AccountRegisterLayer*, CCTextInputNode*, float);
	static auto func = wrapFunction(base::get() + 0x7b5c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto AccountRegisterLayer::textInputReturn(CCTextInputNode* p0) -> decltype(textInputReturn(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&AccountRegisterLayer::textInputReturn), this);
	using FunctionType = decltype(textInputReturn(p0))(*)(AccountRegisterLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x7b620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AccountRegisterLayer::allowTextInput(CCTextInputNode* p0) -> decltype(allowTextInput(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&AccountRegisterLayer::allowTextInput), this);
	using FunctionType = decltype(allowTextInput(p0))(*)(AccountRegisterLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x7b670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AccountRegisterLayer::registerAccountFinished() -> decltype(registerAccountFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AccountRegisterLayer::registerAccountFinished), this);
	using FunctionType = decltype(registerAccountFinished())(*)(AccountRegisterLayer*);
	static auto func = wrapFunction(base::get() + 0x79c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AccountRegisterLayer::registerAccountFailed(AccountError p0) -> decltype(registerAccountFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<AccountError>::func(&AccountRegisterLayer::registerAccountFailed), this);
	using FunctionType = decltype(registerAccountFailed(p0))(*)(AccountRegisterLayer*, AccountError);
	static auto func = wrapFunction(base::get() + 0x79eb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

AchievementBar::AchievementBar(unsigned int idk) : AchievementBar(geode::CutoffConstructor, sizeof(AchievementBar)) {
	// here we construct it as normal as we can, then destruct it
	// using the generated functions. this ensures no memory gets leaked
	// no crashes :pray:
	CCDestructor::lock(this) = true;
	AchievementBar::~AchievementBar();
	using FunctionType = void(*)(AchievementBar*, unsigned int);
	static auto func = wrapFunction(base::get() + 0x80620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this, idk);
}

auto AchievementBar::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&AchievementBar::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(AchievementBar*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x81ea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AchievementBar::init(char const* title, char const* desc, char const* icon, bool quest) -> decltype(init(title, desc, icon, quest)) {
	using FunctionType = decltype(init(title, desc, icon, quest))(*)(AchievementBar*, char const*, char const*, char const*, bool);
	static auto func = wrapFunction(base::get() + 0x80670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, title, desc, icon, quest);
}

auto AchievementBar::show() -> decltype(show()) {
	using FunctionType = decltype(show())(*)(AchievementBar*);
	static auto func = wrapFunction(base::get() + 0x81c20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

CCIndexPath::CCIndexPath() {}

TableViewCell::TableViewCell(char const* p0, float p1, float p2) : TableViewCell(geode::CutoffConstructor, sizeof(TableViewCell)) {
	// here we construct it as normal as we can, then destruct it
	// using the generated functions. this ensures no memory gets leaked
	// no crashes :pray:
	CCDestructor::lock(this) = true;
	TableViewCell::~TableViewCell();
	using FunctionType = void(*)(TableViewCell*, char const*, float, float);
	static auto func = wrapFunction(base::get() + 0x76ad0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto AchievementCell::init() -> decltype(init()) {
	throw std::runtime_error("AchievementCell::init not implemented");
}

auto AchievementCell::draw() -> decltype(draw()) {
	throw std::runtime_error("AchievementCell::draw not implemented");
}

auto AchievementCell::loadFromDict(cocos2d::CCDictionary* p0) -> decltype(loadFromDict(p0)) {
	using FunctionType = decltype(loadFromDict(p0))(*)(AchievementCell*, cocos2d::CCDictionary*);
	static auto func = wrapFunction(base::get() + 0xac150, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto AchievementManager::sharedState() -> decltype(sharedState()) {
	using FunctionType = decltype(sharedState())(*)();
	static auto func = wrapFunction(base::get() + 0x7da0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto AchievementManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AchievementManager::init), this);
	using FunctionType = decltype(init())(*)(AchievementManager*);
	static auto func = wrapFunction(base::get() + 0x7e60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AchievementManager::achievementForUnlock(int p0, UnlockType p1) -> decltype(achievementForUnlock(p0, p1)) {
	using FunctionType = decltype(achievementForUnlock(p0, p1))(*)(AchievementManager*, int, UnlockType);
	static auto func = wrapFunction(base::get() + 0x3a1c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto AchievementManager::addAchievement(gd::string p0, gd::string p1, gd::string p2, gd::string p3, gd::string p4, int p5) -> decltype(addAchievement(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(addAchievement(p0, p1, p2, p3, p4, p5))(*)(AchievementManager*, gd::string, gd::string, gd::string, gd::string, gd::string, int);
	static auto func = wrapFunction(base::get() + 0x7ef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto AchievementManager::addManualAchievements() -> decltype(addManualAchievements()) {
	using FunctionType = decltype(addManualAchievements())(*)(AchievementManager*);
	static auto func = wrapFunction(base::get() + 0x8410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto AchievementManager::getAchievementsWithID(char const* p0) -> decltype(getAchievementsWithID(p0)) {
	using FunctionType = decltype(getAchievementsWithID(p0))(*)(AchievementManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x39d70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto AchievementManager::isAchievementEarned(char const* ach) -> decltype(isAchievementEarned(ach)) {
	using FunctionType = decltype(isAchievementEarned(ach))(*)(AchievementManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x39a70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, ach);
}

int AchievementManager::limitForAchievement(gd::string id) {
        if (auto achievements = getAchievementsWithID(id.c_str())) {
            if (auto limits = static_cast<cocos2d::CCString*>(achievements->objectForKey("limits"))) return limits->intValue();
        }
        return 0;
    }

auto AchievementManager::percentForAchievement(char const* p0) -> decltype(percentForAchievement(p0)) {
	using FunctionType = decltype(percentForAchievement(p0))(*)(AchievementManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x39a90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto AchievementNotifier::sharedState() -> decltype(sharedState()) {
	using FunctionType = decltype(sharedState())(*)();
	static auto func = wrapFunction(base::get() + 0x3ab20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto AchievementNotifier::init() -> decltype(init()) {
	throw std::runtime_error("AchievementNotifier::init not implemented");
}

auto AchievementNotifier::notifyAchievement(char const* title, char const* desc, char const* icon, bool quest) -> decltype(notifyAchievement(title, desc, icon, quest)) {
	using FunctionType = decltype(notifyAchievement(title, desc, icon, quest))(*)(AchievementNotifier*, char const*, char const*, char const*, bool);
	static auto func = wrapFunction(base::get() + 0x3ac00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, title, desc, icon, quest);
}

auto AchievementNotifier::showNextAchievement() -> decltype(showNextAchievement()) {
	using FunctionType = decltype(showNextAchievement())(*)(AchievementNotifier*);
	static auto func = wrapFunction(base::get() + 0x3ace0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void AchievementNotifier::willSwitchToScene(cocos2d::CCScene* scene) {
        this->m_nextScene = scene;

        if (this->m_activeAchievementBar && this->m_activeAchievementBar->getParent() != this->m_nextScene)
        {
            this->m_activeAchievementBar->retain();
            this->m_activeAchievementBar->removeFromParentAndCleanup(false);
            this->m_nextScene->addChild(this->m_activeAchievementBar, 105);
            this->m_activeAchievementBar->release();
            this->m_activeAchievementBar->resumeSchedulerAndActions();
        }
    }

AchievementsLayer::AchievementsLayer() {
        m_currentPage = 0;
        m_nextPageButton = nullptr;
        m_prevPageButton = nullptr;
        m_pageLabel = nullptr;
        m_unkPoint = cocos2d::CCPoint { 0.f, 0.f };
    }

AchievementsLayer* AchievementsLayer::create() {
        auto ret = new AchievementsLayer();
        if (ret->init("Achievements")) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto AchievementsLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&AchievementsLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(AchievementsLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x82260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AchievementsLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AchievementsLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(AchievementsLayer*);
	static auto func = wrapFunction(base::get() + 0x81fb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AchievementsLayer::loadPage(int p0) -> decltype(loadPage(p0)) {
	using FunctionType = decltype(loadPage(p0))(*)(AchievementsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x82300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto AchievementsLayer::onNextPage(cocos2d::CCObject* sender) -> decltype(onNextPage(sender)) {
	using FunctionType = decltype(onNextPage(sender))(*)(AchievementsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x824e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto AchievementsLayer::onPrevPage(cocos2d::CCObject* sender) -> decltype(onPrevPage(sender)) {
	using FunctionType = decltype(onPrevPage(sender))(*)(AchievementsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x824f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

void AchievementsLayer::setupLevelBrowser(cocos2d::CCArray* arr) {
        m_listLayer->removeChildByTag(9, true);
        auto* listView = CustomListView::create(arr, BoomListType::Default, 220.f, 356.f);
        listView->setTag(9);
        m_listLayer->addChild(listView, 6);
    }

auto CCSpritePlus::setScaleX(float fScaleX) -> decltype(setScaleX(fScaleX)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CCSpritePlus::setScaleX), this);
	using FunctionType = decltype(setScaleX(fScaleX))(*)(CCSpritePlus*, float);
	static auto func = wrapFunction(base::get() + 0x481d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, fScaleX);
}

auto CCSpritePlus::setScaleY(float fScaleY) -> decltype(setScaleY(fScaleY)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CCSpritePlus::setScaleY), this);
	using FunctionType = decltype(setScaleY(fScaleY))(*)(CCSpritePlus*, float);
	static auto func = wrapFunction(base::get() + 0x48250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, fScaleY);
}

auto CCSpritePlus::setScale(float fScale) -> decltype(setScale(fScale)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CCSpritePlus::setScale), this);
	using FunctionType = decltype(setScale(fScale))(*)(CCSpritePlus*, float);
	static auto func = wrapFunction(base::get() + 0x482e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, fScale);
}

auto CCSpritePlus::setPosition(cocos2d::CCPoint const& pos) -> decltype(setPosition(pos)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint const&>::func(&CCSpritePlus::setPosition), this);
	using FunctionType = decltype(setPosition(pos))(*)(CCSpritePlus*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x47dd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, pos);
}

auto CCSpritePlus::setRotation(float fRotation) -> decltype(setRotation(fRotation)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CCSpritePlus::setRotation), this);
	using FunctionType = decltype(setRotation(fRotation))(*)(CCSpritePlus*, float);
	static auto func = wrapFunction(base::get() + 0x47e60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, fRotation);
}

auto CCSpritePlus::setRotationX(float fRotationX) -> decltype(setRotationX(fRotationX)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CCSpritePlus::setRotationX), this);
	using FunctionType = decltype(setRotationX(fRotationX))(*)(CCSpritePlus*, float);
	static auto func = wrapFunction(base::get() + 0x47ef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, fRotationX);
}

auto CCSpritePlus::setRotationY(float p0) -> decltype(setRotationY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CCSpritePlus::setRotationY), this);
	using FunctionType = decltype(setRotationY(p0))(*)(CCSpritePlus*, float);
	static auto func = wrapFunction(base::get() + 0x47f80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCSpritePlus::initWithTexture(cocos2d::CCTexture2D* texture) -> decltype(initWithTexture(texture)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTexture2D*>::func(&CCSpritePlus::initWithTexture), this);
	using FunctionType = decltype(initWithTexture(texture))(*)(CCSpritePlus*, cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x47db0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, texture);
}

auto CCSpritePlus::initWithSpriteFrameName(char const* p0) -> decltype(initWithSpriteFrameName(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&CCSpritePlus::initWithSpriteFrameName), this);
	using FunctionType = decltype(initWithSpriteFrameName(p0))(*)(CCSpritePlus*, char const*);
	static auto func = wrapFunction(base::get() + 0x47da0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCSpritePlus::setFlipX(bool flipX) -> decltype(setFlipX(flipX)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&CCSpritePlus::setFlipX), this);
	using FunctionType = decltype(setFlipX(flipX))(*)(CCSpritePlus*, bool);
	static auto func = wrapFunction(base::get() + 0x48010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, flipX);
}

auto CCSpritePlus::setFlipY(bool flipY) -> decltype(setFlipY(flipY)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&CCSpritePlus::setFlipY), this);
	using FunctionType = decltype(setFlipY(flipY))(*)(CCSpritePlus*, bool);
	static auto func = wrapFunction(base::get() + 0x480f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, flipY);
}

auto CCSpritePlus::removeFollower(cocos2d::CCNode* sprite) -> decltype(removeFollower(sprite)) {
	using FunctionType = decltype(removeFollower(sprite))(*)(CCSpritePlus*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x48370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sprite);
}

GameObject::GameObject() : GameObject(geode::CutoffConstructor, sizeof(GameObject)) {
	// here we construct it as normal as we can, then destruct it
	// using the generated functions. this ensures no memory gets leaked
	// no crashes :pray:
	CCDestructor::lock(this) = true;
	GameObject::~GameObject();
	using FunctionType = void(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x135ba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::createWithFrame(char const* name) -> decltype(createWithFrame(name)) {
	using FunctionType = decltype(createWithFrame(name))(*)(char const*);
	static auto func = wrapFunction(base::get() + 0x18aca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(name);
}

auto GameObject::createWithKey(int p0) -> decltype(createWithKey(p0)) {
	using FunctionType = decltype(createWithKey(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x188850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GameObject::objectFromVector(gd::vector<gd::string>& p0, gd::vector<void*>& p1, GJBaseGameLayer* p2, bool p3) -> decltype(objectFromVector(p0, p1, p2, p3)) {
	using FunctionType = decltype(objectFromVector(p0, p1, p2, p3))(*)(gd::vector<gd::string>&, gd::vector<void*>&, GJBaseGameLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x19a260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3);
}

auto GameObject::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("GameObject::update not implemented");
}

auto GameObject::setScaleX(float p0) -> decltype(setScaleX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameObject::setScaleX), this);
	using FunctionType = decltype(setScaleX(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x1952d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setScaleY(float p0) -> decltype(setScaleY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameObject::setScaleY), this);
	using FunctionType = decltype(setScaleY(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x1953b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setScale(float p0) -> decltype(setScale(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameObject::setScale), this);
	using FunctionType = decltype(setScale(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x1954a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setPosition(cocos2d::CCPoint const& p0) -> decltype(setPosition(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint const&>::func(&GameObject::setPosition), this);
	using FunctionType = decltype(setPosition(p0))(*)(GameObject*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x194be0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setVisible(bool p0) -> decltype(setVisible(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&GameObject::setVisible), this);
	using FunctionType = decltype(setVisible(p0))(*)(GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x195cd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setRotation(float p0) -> decltype(setRotation(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameObject::setRotation), this);
	using FunctionType = decltype(setRotation(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x194e80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setRotationX(float p0) -> decltype(setRotationX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameObject::setRotationX), this);
	using FunctionType = decltype(setRotationX(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x194fd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setRotationY(float p0) -> decltype(setRotationY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameObject::setRotationY), this);
	using FunctionType = decltype(setRotationY(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x195120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&GameObject::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(GameObject*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x195880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::initWithTexture(cocos2d::CCTexture2D* p0) -> decltype(initWithTexture(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTexture2D*>::func(&GameObject::initWithTexture), this);
	using FunctionType = decltype(initWithTexture(p0))(*)(GameObject*, cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x18ad30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setChildColor(cocos2d::ccColor3B const& p0) -> decltype(setChildColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B const&>::func(&GameObject::setChildColor), this);
	using FunctionType = decltype(setChildColor(p0))(*)(GameObject*, cocos2d::ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x19de40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setFlipX(bool p0) -> decltype(setFlipX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&GameObject::setFlipX), this);
	using FunctionType = decltype(setFlipX(p0))(*)(GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x195240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setFlipY(bool p0) -> decltype(setFlipY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&GameObject::setFlipY), this);
	using FunctionType = decltype(setFlipY(p0))(*)(GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x195280, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::firstSetup() -> decltype(firstSetup()) {
	throw std::runtime_error("GameObject::firstSetup not implemented");
}

auto GameObject::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x18dea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::setupCustomSprites(gd::string p0) -> decltype(setupCustomSprites(p0)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string>::func(&GameObject::setupCustomSprites), this);
	using FunctionType = decltype(setupCustomSprites(p0))(*)(GameObject*, gd::string);
	static auto func = wrapFunction(base::get() + 0x1abf80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::addMainSpriteToParent(bool p0) -> decltype(addMainSpriteToParent(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&GameObject::addMainSpriteToParent), this);
	using FunctionType = decltype(addMainSpriteToParent(p0))(*)(GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x198dd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::resetObject() -> decltype(resetObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::resetObject), this);
	using FunctionType = decltype(resetObject())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x18d750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	throw std::runtime_error("GameObject::triggerObject not implemented");
}

auto GameObject::activateObject() -> decltype(activateObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::activateObject), this);
	using FunctionType = decltype(activateObject())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x18db60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::deactivateObject(bool p0) -> decltype(deactivateObject(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&GameObject::deactivateObject), this);
	using FunctionType = decltype(deactivateObject(p0))(*)(GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x18dc10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::transferObjectRect(cocos2d::CCRect& p0) -> decltype(transferObjectRect(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCRect&>::func(&GameObject::transferObjectRect), this);
	using FunctionType = decltype(transferObjectRect(p0))(*)(GameObject*, cocos2d::CCRect&);
	static auto func = wrapFunction(base::get() + 0x1946d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::getObjectRect() -> decltype(getObjectRect()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::getObjectRect), this);
	using FunctionType = decltype(getObjectRect())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x194720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::getObjectRect(float p0, float p1) -> decltype(getObjectRect(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, float>::func(&GameObject::getObjectRect), this);
	using FunctionType = decltype(getObjectRect(p0, p1))(*)(GameObject*, float, float);
	static auto func = wrapFunction(base::get() + 0x194740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GameObject::getObjectRect2(float p0, float p1) -> decltype(getObjectRect2(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, float>::func(&GameObject::getObjectRect2), this);
	using FunctionType = decltype(getObjectRect2(p0, p1))(*)(GameObject*, float, float);
	static auto func = wrapFunction(base::get() + 0x1948d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GameObject::getObjectTextureRect() -> decltype(getObjectTextureRect()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::getObjectTextureRect), this);
	using FunctionType = decltype(getObjectTextureRect())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x194970, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::getRealPosition() -> decltype(getRealPosition()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::getRealPosition), this);
	using FunctionType = decltype(getRealPosition())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x194ba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::setStartPos(cocos2d::CCPoint p0) -> decltype(setStartPos(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint>::func(&GameObject::setStartPos), this);
	using FunctionType = decltype(setStartPos(p0))(*)(GameObject*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x18d5d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::updateStartValues() -> decltype(updateStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::updateStartValues), this);
	using FunctionType = decltype(updateStartValues())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x18d9a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("GameObject::customObjectSetup not implemented");
}

auto GameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&GameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(GameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x19bd50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::claimParticle() -> decltype(claimParticle()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::claimParticle), this);
	using FunctionType = decltype(claimParticle())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x195df0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::unclaimParticle() -> decltype(unclaimParticle()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::unclaimParticle), this);
	using FunctionType = decltype(unclaimParticle())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x196320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::particleWasActivated() -> decltype(particleWasActivated()) {
	throw std::runtime_error("GameObject::particleWasActivated not implemented");
}

auto GameObject::isFlipX() -> decltype(isFlipX()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::isFlipX), this);
	using FunctionType = decltype(isFlipX())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x195220, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::isFlipY() -> decltype(isFlipY()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::isFlipY), this);
	using FunctionType = decltype(isFlipY())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x195230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::setRScaleX(float p0) -> decltype(setRScaleX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameObject::setRScaleX), this);
	using FunctionType = decltype(setRScaleX(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x195590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setRScaleY(float p0) -> decltype(setRScaleY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameObject::setRScaleY), this);
	using FunctionType = decltype(setRScaleY(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x1955d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setRScale(float p0) -> decltype(setRScale(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameObject::setRScale), this);
	using FunctionType = decltype(setRScale(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x195610, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::getRScaleX() -> decltype(getRScaleX()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::getRScaleX), this);
	using FunctionType = decltype(getRScaleX())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x195650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::getRScaleY() -> decltype(getRScaleY()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::getRScaleY), this);
	using FunctionType = decltype(getRScaleY())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x195690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::setRRotation(float p0) -> decltype(setRRotation(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameObject::setRRotation), this);
	using FunctionType = decltype(setRRotation(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x194df0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::triggerActivated(float p0) -> decltype(triggerActivated(p0)) {
	throw std::runtime_error("GameObject::triggerActivated not implemented");
}

auto GameObject::setObjectColor(cocos2d::ccColor3B const& p0) -> decltype(setObjectColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B const&>::func(&GameObject::setObjectColor), this);
	using FunctionType = decltype(setObjectColor(p0))(*)(GameObject*, cocos2d::ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x19db00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setGlowColor(cocos2d::ccColor3B const& p0) -> decltype(setGlowColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B const&>::func(&GameObject::setGlowColor), this);
	using FunctionType = decltype(setGlowColor(p0))(*)(GameObject*, cocos2d::ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x19ddf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::restoreObject() -> decltype(restoreObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::restoreObject), this);
	using FunctionType = decltype(restoreObject())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x196410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::animationTriggered() -> decltype(animationTriggered()) {
	throw std::runtime_error("GameObject::animationTriggered not implemented");
}

auto GameObject::selectObject(cocos2d::ccColor3B p0) -> decltype(selectObject(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B>::func(&GameObject::selectObject), this);
	using FunctionType = decltype(selectObject(p0))(*)(GameObject*, cocos2d::ccColor3B);
	static auto func = wrapFunction(base::get() + 0x19dec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::activatedByPlayer(PlayerObject* p0) -> decltype(activatedByPlayer(p0)) {
	throw std::runtime_error("GameObject::activatedByPlayer not implemented");
}

auto GameObject::hasBeenActivatedByPlayer(PlayerObject* p0) -> decltype(hasBeenActivatedByPlayer(p0)) {
	throw std::runtime_error("GameObject::hasBeenActivatedByPlayer not implemented");
}

auto GameObject::hasBeenActivated() -> decltype(hasBeenActivated()) {
	throw std::runtime_error("GameObject::hasBeenActivated not implemented");
}

auto GameObject::getOrientedBox() -> decltype(getOrientedBox()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::getOrientedBox), this);
	using FunctionType = decltype(getOrientedBox())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x19e590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::updateOrientedBox() -> decltype(updateOrientedBox()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::updateOrientedBox), this);
	using FunctionType = decltype(updateOrientedBox())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x19e5f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::getObjectRotation() -> decltype(getObjectRotation()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::getObjectRotation), this);
	using FunctionType = decltype(getObjectRotation())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x19e570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::updateMainColor(cocos2d::ccColor3B const& p0) -> decltype(updateMainColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B const&>::func(&GameObject::updateMainColor), this);
	using FunctionType = decltype(updateMainColor(p0))(*)(GameObject*, cocos2d::ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x19eff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::updateSecondaryColor(cocos2d::ccColor3B const& p0) -> decltype(updateSecondaryColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B const&>::func(&GameObject::updateSecondaryColor), this);
	using FunctionType = decltype(updateSecondaryColor(p0))(*)(GameObject*, cocos2d::ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x19f000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::addToGroup(int p0) -> decltype(addToGroup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&GameObject::addToGroup), this);
	using FunctionType = decltype(addToGroup(p0))(*)(GameObject*, int);
	static auto func = wrapFunction(base::get() + 0x199810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::removeFromGroup(int p0) -> decltype(removeFromGroup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&GameObject::removeFromGroup), this);
	using FunctionType = decltype(removeFromGroup(p0))(*)(GameObject*, int);
	static auto func = wrapFunction(base::get() + 0x199930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::saveActiveColors() -> decltype(saveActiveColors()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::saveActiveColors), this);
	using FunctionType = decltype(saveActiveColors())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x19d950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::spawnXPosition() -> decltype(spawnXPosition()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::spawnXPosition), this);
	using FunctionType = decltype(spawnXPosition())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x135fe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::canAllowMultiActivate() -> decltype(canAllowMultiActivate()) {
	throw std::runtime_error("GameObject::canAllowMultiActivate not implemented");
}

auto GameObject::blendModeChanged() -> decltype(blendModeChanged()) {
	throw std::runtime_error("GameObject::blendModeChanged not implemented");
}

auto GameObject::updateParticleColor(cocos2d::ccColor3B const& p0) -> decltype(updateParticleColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B const&>::func(&GameObject::updateParticleColor), this);
	using FunctionType = decltype(updateParticleColor(p0))(*)(GameObject*, cocos2d::ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x19dce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::updateParticleOpacity(unsigned char p0) -> decltype(updateParticleOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&GameObject::updateParticleOpacity), this);
	using FunctionType = decltype(updateParticleOpacity(p0))(*)(GameObject*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x195b20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::updateMainParticleOpacity(unsigned char p0) -> decltype(updateMainParticleOpacity(p0)) {
	throw std::runtime_error("GameObject::updateMainParticleOpacity not implemented");
}

auto GameObject::updateSecondaryParticleOpacity(unsigned char p0) -> decltype(updateSecondaryParticleOpacity(p0)) {
	throw std::runtime_error("GameObject::updateSecondaryParticleOpacity not implemented");
}

auto GameObject::canReverse() -> decltype(canReverse()) {
	throw std::runtime_error("GameObject::canReverse not implemented");
}

auto GameObject::isSpecialSpawnObject() -> decltype(isSpecialSpawnObject()) {
	throw std::runtime_error("GameObject::isSpecialSpawnObject not implemented");
}

auto GameObject::canBeOrdered() -> decltype(canBeOrdered()) {
	throw std::runtime_error("GameObject::canBeOrdered not implemented");
}

auto GameObject::getObjectLabel() -> decltype(getObjectLabel()) {
	throw std::runtime_error("GameObject::getObjectLabel not implemented");
}

auto GameObject::setObjectLabel(cocos2d::CCLabelBMFont* p0) -> decltype(setObjectLabel(p0)) {
	throw std::runtime_error("GameObject::setObjectLabel not implemented");
}

auto GameObject::shouldDrawEditorHitbox() -> decltype(shouldDrawEditorHitbox()) {
	throw std::runtime_error("GameObject::shouldDrawEditorHitbox not implemented");
}

auto GameObject::getHasSyncedAnimation() -> decltype(getHasSyncedAnimation()) {
	throw std::runtime_error("GameObject::getHasSyncedAnimation not implemented");
}

auto GameObject::getHasRotateAction() -> decltype(getHasRotateAction()) {
	throw std::runtime_error("GameObject::getHasRotateAction not implemented");
}

auto GameObject::canMultiActivate(bool p0) -> decltype(canMultiActivate(p0)) {
	throw std::runtime_error("GameObject::canMultiActivate not implemented");
}

auto GameObject::updateTextKerning(int p0) -> decltype(updateTextKerning(p0)) {
	throw std::runtime_error("GameObject::updateTextKerning not implemented");
}

auto GameObject::getTextKerning() -> decltype(getTextKerning()) {
	throw std::runtime_error("GameObject::getTextKerning not implemented");
}

auto GameObject::getObjectRectDirty() -> decltype(getObjectRectDirty()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::getObjectRectDirty), this);
	using FunctionType = decltype(getObjectRectDirty())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x136000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::setObjectRectDirty(bool p0) -> decltype(setObjectRectDirty(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&GameObject::setObjectRectDirty), this);
	using FunctionType = decltype(setObjectRectDirty(p0))(*)(GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x136010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::getOrientedRectDirty() -> decltype(getOrientedRectDirty()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::getOrientedRectDirty), this);
	using FunctionType = decltype(getOrientedRectDirty())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x136020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::setOrientedRectDirty(bool p0) -> decltype(setOrientedRectDirty(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&GameObject::setOrientedRectDirty), this);
	using FunctionType = decltype(setOrientedRectDirty(p0))(*)(GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x136030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::getType() -> decltype(getType()) {
	throw std::runtime_error("GameObject::getType not implemented");
}

auto GameObject::setType(GameObjectType p0) -> decltype(setType(p0)) {
	throw std::runtime_error("GameObject::setType not implemented");
}

auto GameObject::getStartPos() -> decltype(getStartPos()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::getStartPos), this);
	using FunctionType = decltype(getStartPos())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x136060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::addColorSprite(gd::string p0) -> decltype(addColorSprite(p0)) {
	using FunctionType = decltype(addColorSprite(p0))(*)(GameObject*, gd::string);
	static auto func = wrapFunction(base::get() + 0x18b830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameObject::commonSetup() -> decltype(commonSetup()) {
	using FunctionType = decltype(commonSetup())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x18ad70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::copyGroups(GameObject* p0) -> decltype(copyGroups(p0)) {
	using FunctionType = decltype(copyGroups(p0))(*)(GameObject*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x1999c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameObject::createAndAddParticle(int p0, char const* plistName, int p2, cocos2d::tCCPositionType positionType) -> decltype(createAndAddParticle(p0, plistName, p2, positionType)) {
	using FunctionType = decltype(createAndAddParticle(p0, plistName, p2, positionType))(*)(GameObject*, int, char const*, int, cocos2d::tCCPositionType);
	static auto func = wrapFunction(base::get() + 0x195ba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, plistName, p2, positionType);
}

void GameObject::createGroupContainer(int size) {
        if (!m_groups) {
            auto groups = new short[size];
            memset(groups, 0, size * sizeof(short));
            m_groups = reinterpret_cast<decltype(m_groups)>(groups);
        }
    }

auto GameObject::determineSlopeDirection() -> decltype(determineSlopeDirection()) {
	using FunctionType = decltype(determineSlopeDirection())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x199340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::duplicateValues(GameObject* p0) -> decltype(duplicateValues(p0)) {
	using FunctionType = decltype(duplicateValues(p0))(*)(GameObject*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x19ee40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameObject::editorColorForMode(int p0) -> decltype(editorColorForMode(p0)) {
	using FunctionType = decltype(editorColorForMode(p0))(*)(GameObject*, int);
	static auto func = wrapFunction(base::get() + 0x19e0a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameObject::groupOpacityMod() -> decltype(groupOpacityMod()) {
	using FunctionType = decltype(groupOpacityMod())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x199d30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::isFacingDown() -> decltype(isFacingDown()) {
	using FunctionType = decltype(isFacingDown())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x19e990, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::isFacingLeft() -> decltype(isFacingLeft()) {
	using FunctionType = decltype(isFacingLeft())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x19ea50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::playDestroyObjectAnim(GJBaseGameLayer* p0) -> decltype(playDestroyObjectAnim(p0)) {
	using FunctionType = decltype(playDestroyObjectAnim(p0))(*)(GameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1a7520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameObject::playPickupAnimation(cocos2d::CCSprite* p0, float p1, float p2, float p3, float p4, float p5, float p6, float p7, float p8, bool p9, float p10, float p11) -> decltype(playPickupAnimation(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11)) {
	using FunctionType = decltype(playPickupAnimation(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11))(*)(GameObject*, cocos2d::CCSprite*, float, float, float, float, float, float, float, float, bool, float, float);
	static auto func = wrapFunction(base::get() + 0x1a7040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11);
}

auto GameObject::playPickupAnimation(cocos2d::CCSprite* p0, float p1, float p2, float p3, float p4) -> decltype(playPickupAnimation(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(playPickupAnimation(p0, p1, p2, p3, p4))(*)(GameObject*, cocos2d::CCSprite*, float, float, float, float);
	static auto func = wrapFunction(base::get() + 0x1a6f50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto GameObject::playShineEffect() -> decltype(playShineEffect()) {
	using FunctionType = decltype(playShineEffect())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x196430, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::slopeYPos(cocos2d::CCRect p0) -> decltype(slopeYPos(p0)) {
	using FunctionType = decltype(slopeYPos(p0))(*)(GameObject*, cocos2d::CCRect);
	static auto func = wrapFunction(base::get() + 0x19e430, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameObject::slopeYPos(float p0) -> decltype(slopeYPos(p0)) {
	using FunctionType = decltype(slopeYPos(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x19e430, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameObject::updateCustomScaleX(float p0) -> decltype(updateCustomScaleX(p0)) {
	using FunctionType = decltype(updateCustomScaleX(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x1956d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameObject::updateCustomScaleY(float p0) -> decltype(updateCustomScaleY(p0)) {
	using FunctionType = decltype(updateCustomScaleY(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x195760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameObject::updateIsOriented() -> decltype(updateIsOriented()) {
	using FunctionType = decltype(updateIsOriented())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x19e7b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::updateObjectEditorColor() -> decltype(updateObjectEditorColor()) {
	using FunctionType = decltype(updateObjectEditorColor())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x19e370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EnhancedGameObject::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EnhancedGameObject::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(EnhancedGameObject*);
	static auto func = wrapFunction(base::get() + 0x1a1ff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EnhancedGameObject::resetObject() -> decltype(resetObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EnhancedGameObject::resetObject), this);
	using FunctionType = decltype(resetObject())(*)(EnhancedGameObject*);
	static auto func = wrapFunction(base::get() + 0x1a19b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EnhancedGameObject::deactivateObject(bool p0) -> decltype(deactivateObject(p0)) {
	throw std::runtime_error("EnhancedGameObject::deactivateObject not implemented");
}

auto EnhancedGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("EnhancedGameObject::customObjectSetup not implemented");
}

auto EnhancedGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("EnhancedGameObject::getSaveString not implemented");
}

auto EnhancedGameObject::triggerActivated(float p0) -> decltype(triggerActivated(p0)) {
	throw std::runtime_error("EnhancedGameObject::triggerActivated not implemented");
}

auto EnhancedGameObject::restoreObject() -> decltype(restoreObject()) {
	throw std::runtime_error("EnhancedGameObject::restoreObject not implemented");
}

auto EnhancedGameObject::animationTriggered() -> decltype(animationTriggered()) {
	throw std::runtime_error("EnhancedGameObject::animationTriggered not implemented");
}

auto EnhancedGameObject::activatedByPlayer(PlayerObject* p0) -> decltype(activatedByPlayer(p0)) {
	throw std::runtime_error("EnhancedGameObject::activatedByPlayer not implemented");
}

auto EnhancedGameObject::hasBeenActivatedByPlayer(PlayerObject* p0) -> decltype(hasBeenActivatedByPlayer(p0)) {
	throw std::runtime_error("EnhancedGameObject::hasBeenActivatedByPlayer not implemented");
}

auto EnhancedGameObject::hasBeenActivated() -> decltype(hasBeenActivated()) {
	throw std::runtime_error("EnhancedGameObject::hasBeenActivated not implemented");
}

auto EnhancedGameObject::saveActiveColors() -> decltype(saveActiveColors()) {
	throw std::runtime_error("EnhancedGameObject::saveActiveColors not implemented");
}

auto EnhancedGameObject::canAllowMultiActivate() -> decltype(canAllowMultiActivate()) {
	throw std::runtime_error("EnhancedGameObject::canAllowMultiActivate not implemented");
}

auto EnhancedGameObject::getHasSyncedAnimation() -> decltype(getHasSyncedAnimation()) {
	throw std::runtime_error("EnhancedGameObject::getHasSyncedAnimation not implemented");
}

auto EnhancedGameObject::getHasRotateAction() -> decltype(getHasRotateAction()) {
	throw std::runtime_error("EnhancedGameObject::getHasRotateAction not implemented");
}

auto EnhancedGameObject::canMultiActivate(bool p0) -> decltype(canMultiActivate(p0)) {
	throw std::runtime_error("EnhancedGameObject::canMultiActivate not implemented");
}

auto EnhancedGameObject::powerOnObject(int p0) -> decltype(powerOnObject(p0)) {
	throw std::runtime_error("EnhancedGameObject::powerOnObject not implemented");
}

auto EnhancedGameObject::powerOffObject() -> decltype(powerOffObject()) {
	throw std::runtime_error("EnhancedGameObject::powerOffObject not implemented");
}

auto EnhancedGameObject::stateSensitiveOff(GJBaseGameLayer* p0) -> decltype(stateSensitiveOff(p0)) {
	throw std::runtime_error("EnhancedGameObject::stateSensitiveOff not implemented");
}

auto EnhancedGameObject::updateSyncedAnimation(float p0, int p1) -> decltype(updateSyncedAnimation(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, int>::func(&EnhancedGameObject::updateSyncedAnimation), this);
	using FunctionType = decltype(updateSyncedAnimation(p0, p1))(*)(EnhancedGameObject*, float, int);
	static auto func = wrapFunction(base::get() + 0x1a4e30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EnhancedGameObject::updateAnimateOnTrigger(bool p0) -> decltype(updateAnimateOnTrigger(p0)) {
	throw std::runtime_error("EnhancedGameObject::updateAnimateOnTrigger not implemented");
}

auto EnhancedGameObject::init(char const* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(EnhancedGameObject*, char const*);
	static auto func = wrapFunction(base::get() + 0x1a1800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EnhancedGameObject::updateUserCoin() -> decltype(updateUserCoin()) {
	using FunctionType = decltype(updateUserCoin())(*)(EnhancedGameObject*);
	static auto func = wrapFunction(base::get() + 0x1a3970, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EffectGameObject::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&EffectGameObject::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(EffectGameObject*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x48d790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EffectGameObject::firstSetup() -> decltype(firstSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EffectGameObject::firstSetup), this);
	using FunctionType = decltype(firstSetup())(*)(EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x48ffb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EffectGameObject::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EffectGameObject::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x48ffd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EffectGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*, int, gd::vector<int> const*>::func(&EffectGameObject::triggerObject), this);
	using FunctionType = decltype(triggerObject(p0, p1, p2))(*)(EffectGameObject*, GJBaseGameLayer*, int, gd::vector<int> const*);
	static auto func = wrapFunction(base::get() + 0x48d7d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto EffectGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&EffectGameObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(EffectGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x490230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EffectGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&EffectGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(EffectGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x4932b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EffectGameObject::setRScaleX(float p0) -> decltype(setRScaleX(p0)) {
	throw std::runtime_error("EffectGameObject::setRScaleX not implemented");
}

auto EffectGameObject::setRScaleY(float p0) -> decltype(setRScaleY(p0)) {
	throw std::runtime_error("EffectGameObject::setRScaleY not implemented");
}

auto EffectGameObject::triggerActivated(float p0) -> decltype(triggerActivated(p0)) {
	throw std::runtime_error("EffectGameObject::triggerActivated not implemented");
}

auto EffectGameObject::restoreObject() -> decltype(restoreObject()) {
	throw std::runtime_error("EffectGameObject::restoreObject not implemented");
}

auto EffectGameObject::spawnXPosition() -> decltype(spawnXPosition()) {
	throw std::runtime_error("EffectGameObject::spawnXPosition not implemented");
}

auto EffectGameObject::canReverse() -> decltype(canReverse()) {
	throw std::runtime_error("EffectGameObject::canReverse not implemented");
}

auto EffectGameObject::isSpecialSpawnObject() -> decltype(isSpecialSpawnObject()) {
	throw std::runtime_error("EffectGameObject::isSpecialSpawnObject not implemented");
}

auto EffectGameObject::canBeOrdered() -> decltype(canBeOrdered()) {
	throw std::runtime_error("EffectGameObject::canBeOrdered not implemented");
}

auto EffectGameObject::getObjectLabel() -> decltype(getObjectLabel()) {
	throw std::runtime_error("EffectGameObject::getObjectLabel not implemented");
}

auto EffectGameObject::setObjectLabel(cocos2d::CCLabelBMFont* p0) -> decltype(setObjectLabel(p0)) {
	throw std::runtime_error("EffectGameObject::setObjectLabel not implemented");
}

auto EffectGameObject::stateSensitiveOff(GJBaseGameLayer* p0) -> decltype(stateSensitiveOff(p0)) {
	throw std::runtime_error("EffectGameObject::stateSensitiveOff not implemented");
}

auto EffectGameObject::init(char const* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(EffectGameObject*, char const*);
	static auto func = wrapFunction(base::get() + 0x48d1a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EffectGameObject::playTriggerEffect() -> decltype(playTriggerEffect()) {
	using FunctionType = decltype(playTriggerEffect())(*)(EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x48d2b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EffectGameObject::updateSpeedModType() -> decltype(updateSpeedModType()) {
	using FunctionType = decltype(updateSpeedModType())(*)(EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x493010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto AdvancedFollowTriggerObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("AdvancedFollowTriggerObject::customObjectSetup not implemented");
}

auto AdvancedFollowTriggerObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("AdvancedFollowTriggerObject::getSaveString not implemented");
}

auto AdvancedFollowEditObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("AdvancedFollowEditObject::customObjectSetup not implemented");
}

auto AdvancedFollowEditObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("AdvancedFollowEditObject::getSaveString not implemented");
}

auto AnimatedSpriteDelegate::animationFinished(char const* p0) -> decltype(animationFinished(p0)) {
	throw std::runtime_error("AnimatedSpriteDelegate::animationFinished not implemented");
}

auto SpritePartDelegate::displayFrameChanged(cocos2d::CCObject* p0, gd::string p1) -> decltype(displayFrameChanged(p0, p1)) {
	throw std::runtime_error("SpritePartDelegate::displayFrameChanged not implemented");
}

auto AnimatedGameObject::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&AnimatedGameObject::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(AnimatedGameObject*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x48b5e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AnimatedGameObject::setChildColor(cocos2d::ccColor3B const& p0) -> decltype(setChildColor(p0)) {
	throw std::runtime_error("AnimatedGameObject::setChildColor not implemented");
}

auto AnimatedGameObject::resetObject() -> decltype(resetObject()) {
	throw std::runtime_error("AnimatedGameObject::resetObject not implemented");
}

auto AnimatedGameObject::activateObject() -> decltype(activateObject()) {
	throw std::runtime_error("AnimatedGameObject::activateObject not implemented");
}

auto AnimatedGameObject::deactivateObject(bool p0) -> decltype(deactivateObject(p0)) {
	throw std::runtime_error("AnimatedGameObject::deactivateObject not implemented");
}

auto AnimatedGameObject::setObjectColor(cocos2d::ccColor3B const& p0) -> decltype(setObjectColor(p0)) {
	throw std::runtime_error("AnimatedGameObject::setObjectColor not implemented");
}

auto AnimatedGameObject::animationFinished(char const* p0) -> decltype(animationFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&AnimatedGameObject::animationFinished), this);
	using FunctionType = decltype(animationFinished(p0))(*)(AnimatedGameObject*, char const*);
	static auto func = wrapFunction(base::get() + 0x48b6f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AnimatedGameObject::displayFrameChanged(cocos2d::CCObject* p0, gd::string p1) -> decltype(displayFrameChanged(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*, gd::string>::func(&AnimatedGameObject::displayFrameChanged), this);
	using FunctionType = decltype(displayFrameChanged(p0, p1))(*)(AnimatedGameObject*, cocos2d::CCObject*, gd::string);
	static auto func = wrapFunction(base::get() + 0x48c9d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

CCAnimatedSprite::CCAnimatedSprite() : CCAnimatedSprite(geode::CutoffConstructor, sizeof(CCAnimatedSprite)) {
	// here we construct it as normal as we can, then destruct it
	// using the generated functions. this ensures no memory gets leaked
	// no crashes :pray:
	CCDestructor::lock(this) = true;
	CCAnimatedSprite::~CCAnimatedSprite();
	using FunctionType = void(*)(CCAnimatedSprite*);
	static auto func = wrapFunction(base::get() + 0x3feb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
}

auto CCAnimatedSprite::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&CCAnimatedSprite::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(CCAnimatedSprite*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x41070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCAnimatedSprite::setColor(cocos2d::ccColor3B const& p0) -> decltype(setColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B const&>::func(&CCAnimatedSprite::setColor), this);
	using FunctionType = decltype(setColor(p0))(*)(CCAnimatedSprite*, cocos2d::ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x410d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCAnimatedSprite::animationFinished(char const* p0) -> decltype(animationFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&CCAnimatedSprite::animationFinished), this);
	using FunctionType = decltype(animationFinished(p0))(*)(CCAnimatedSprite*, char const*);
	static auto func = wrapFunction(base::get() + 0x41050, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCAnimatedSprite::animationFinishedO(cocos2d::CCObject* p0) -> decltype(animationFinishedO(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&CCAnimatedSprite::animationFinishedO), this);
	using FunctionType = decltype(animationFinishedO(p0))(*)(CCAnimatedSprite*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x41010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCAnimatedSprite::initWithType(char const* p0, cocos2d::CCTexture2D* p1, bool p2) -> decltype(initWithType(p0, p1, p2)) {
	using FunctionType = decltype(initWithType(p0, p1, p2))(*)(CCAnimatedSprite*, char const*, cocos2d::CCTexture2D*, bool);
	static auto func = wrapFunction(base::get() + 0x3ffc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto CCAnimatedSprite::loadType(char const* p0, cocos2d::CCTexture2D* p1, bool p2) -> decltype(loadType(p0, p1, p2)) {
	using FunctionType = decltype(loadType(p0, p1, p2))(*)(CCAnimatedSprite*, char const*, cocos2d::CCTexture2D*, bool);
	static auto func = wrapFunction(base::get() + 0x401e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto CCAnimatedSprite::runAnimation(gd::string p0) -> decltype(runAnimation(p0)) {
	using FunctionType = decltype(runAnimation(p0))(*)(CCAnimatedSprite*, gd::string);
	static auto func = wrapFunction(base::get() + 0x40c80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CCAnimatedSprite::switchToMode(spriteMode p0) -> decltype(switchToMode(p0)) {
	using FunctionType = decltype(switchToMode(p0))(*)(CCAnimatedSprite*, spriteMode);
	static auto func = wrapFunction(base::get() + 0x40b10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CCAnimatedSprite::tweenToAnimation(gd::string p0, float p1) -> decltype(tweenToAnimation(p0, p1)) {
	using FunctionType = decltype(tweenToAnimation(p0, p1))(*)(CCAnimatedSprite*, gd::string, float);
	static auto func = wrapFunction(base::get() + 0x40cf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto CCAnimatedSprite::tweenToAnimationFinished() -> decltype(tweenToAnimationFinished()) {
	using FunctionType = decltype(tweenToAnimationFinished())(*)(CCAnimatedSprite*);
	static auto func = wrapFunction(base::get() + 0x40fc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

AnimatedShopKeeper::AnimatedShopKeeper() {
        m_type = ShopType::Normal;
        m_idleInt1 = 0;
        m_idleInt2 = 0;
        m_looking = false;
        m_reacting = false;
        m_reactCount = 0;
        m_gruntIndex = 0;
    }

AnimatedShopKeeper* AnimatedShopKeeper::create(ShopType type) {
        auto ret = new AnimatedShopKeeper();
        if (ret->init(type)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto AnimatedShopKeeper::animationFinished(char const* p0) -> decltype(animationFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&AnimatedShopKeeper::animationFinished), this);
	using FunctionType = decltype(animationFinished(p0))(*)(AnimatedShopKeeper*, char const*);
	static auto func = wrapFunction(base::get() + 0x2a8840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

bool AnimatedShopKeeper::init(ShopType type) {
        m_type = type;
        auto shopkeeper = "GJShopKeeper";
        switch (type) {
            case ShopType::Secret: shopkeeper = "GJShopKeeper2"; break;
            case ShopType::Community: shopkeeper = "GJShopKeeper3"; break;
            case ShopType::Mechanic: shopkeeper = "GJShopKeeper4"; break;
            case ShopType::Diamond: shopkeeper = "GJShopKeeper5"; break;
            default: shopkeeper = "GJShopKeeper"; break;
        }
        if (!CCAnimatedSprite::initWithType(shopkeeper, nullptr, false)) return false;
        m_idleInt2 = (rand() / 32767.f) * 5.f + 10.f;
        m_idleInt1 = (rand() / 32767.f) * 2.f + 1.f;
        m_animationManager->stopAnimations();
        return true;
    }

auto AnimatedShopKeeper::playReactAnimation() -> decltype(playReactAnimation()) {
	using FunctionType = decltype(playReactAnimation())(*)(AnimatedShopKeeper*);
	static auto func = wrapFunction(base::get() + 0x2a8520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto AnimatedShopKeeper::startAnimating() -> decltype(startAnimating()) {
	using FunctionType = decltype(startAnimating())(*)(AnimatedShopKeeper*);
	static auto func = wrapFunction(base::get() + 0x2a87b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

AppDelegate* AppDelegate::get() {
            return static_cast<AppDelegate*>(cocos2d::CCApplication::sharedApplication());
        }

auto AppDelegate::applicationDidFinishLaunching() -> decltype(applicationDidFinishLaunching()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AppDelegate::applicationDidFinishLaunching), this);
	using FunctionType = decltype(applicationDidFinishLaunching())(*)(AppDelegate*);
	static auto func = wrapFunction(base::get() + 0x829f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AppDelegate::applicationDidEnterBackground() -> decltype(applicationDidEnterBackground()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AppDelegate::applicationDidEnterBackground), this);
	using FunctionType = decltype(applicationDidEnterBackground())(*)(AppDelegate*);
	static auto func = wrapFunction(base::get() + 0x82da0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AppDelegate::applicationWillEnterForeground() -> decltype(applicationWillEnterForeground()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AppDelegate::applicationWillEnterForeground), this);
	using FunctionType = decltype(applicationWillEnterForeground())(*)(AppDelegate*);
	static auto func = wrapFunction(base::get() + 0x82e20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AppDelegate::applicationWillBecomeActive() -> decltype(applicationWillBecomeActive()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AppDelegate::applicationWillBecomeActive), this);
	using FunctionType = decltype(applicationWillBecomeActive())(*)(AppDelegate*);
	static auto func = wrapFunction(base::get() + 0x82d40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AppDelegate::applicationWillResignActive() -> decltype(applicationWillResignActive()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AppDelegate::applicationWillResignActive), this);
	using FunctionType = decltype(applicationWillResignActive())(*)(AppDelegate*);
	static auto func = wrapFunction(base::get() + 0x82d90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AppDelegate::trySaveGame(bool p0) -> decltype(trySaveGame(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&AppDelegate::trySaveGame), this);
	using FunctionType = decltype(trySaveGame(p0))(*)(AppDelegate*, bool);
	static auto func = wrapFunction(base::get() + 0x834b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AppDelegate::willSwitchToScene(cocos2d::CCScene* p0) -> decltype(willSwitchToScene(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCScene*>::func(&AppDelegate::willSwitchToScene), this);
	using FunctionType = decltype(willSwitchToScene(p0))(*)(AppDelegate*, cocos2d::CCScene*);
	static auto func = wrapFunction(base::get() + 0x83590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AppDelegate::musicTest() -> decltype(musicTest()) {
	using FunctionType = decltype(musicTest())(*)(AppDelegate*);
	static auto func = wrapFunction(base::get() + 0x83370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto AppDelegate::pauseGame() -> decltype(pauseGame()) {
	using FunctionType = decltype(pauseGame())(*)(AppDelegate*);
	static auto func = wrapFunction(base::get() + 0x82ff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto AppDelegate::pauseSound() -> decltype(pauseSound()) {
	using FunctionType = decltype(pauseSound())(*)(AppDelegate*);
	static auto func = wrapFunction(base::get() + 0x830d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto AppDelegate::platformShutdown() -> decltype(platformShutdown()) {
	using FunctionType = decltype(platformShutdown())(*)(AppDelegate*);
	static auto func = wrapFunction(base::get() + 0x82560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto AppDelegate::resumeSound() -> decltype(resumeSound()) {
	using FunctionType = decltype(resumeSound())(*)(AppDelegate*);
	static auto func = wrapFunction(base::get() + 0x83270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto AppDelegate::setupGLView() -> decltype(setupGLView()) {
	using FunctionType = decltype(setupGLView())(*)(AppDelegate*);
	static auto func = wrapFunction(base::get() + 0x82580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ArtistCell::init() -> decltype(init()) {
	throw std::runtime_error("ArtistCell::init not implemented");
}

auto ArtistCell::draw() -> decltype(draw()) {
	throw std::runtime_error("ArtistCell::draw not implemented");
}

auto ArtistCell::loadFromObject(SongInfoObject* p0) -> decltype(loadFromObject(p0)) {
	using FunctionType = decltype(loadFromObject(p0))(*)(ArtistCell*, SongInfoObject*);
	static auto func = wrapFunction(base::get() + 0xb4e90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ArtTriggerGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	throw std::runtime_error("ArtTriggerGameObject::triggerObject not implemented");
}

auto ArtTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("ArtTriggerGameObject::customObjectSetup not implemented");
}

auto ArtTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("ArtTriggerGameObject::getSaveString not implemented");
}

auto TableViewCellDelegate::cellPerformedAction(TableViewCell* p0, int p1, CellAction p2, cocos2d::CCNode* p3) -> decltype(cellPerformedAction(p0, p1, p2, p3)) {
	throw std::runtime_error("TableViewCellDelegate::cellPerformedAction not implemented");
}

auto TableViewCellDelegate::getSelectedCellIdx() -> decltype(getSelectedCellIdx()) {
	throw std::runtime_error("TableViewCellDelegate::getSelectedCellIdx not implemented");
}

auto TableViewCellDelegate::shouldSnapToSelected() -> decltype(shouldSnapToSelected()) {
	throw std::runtime_error("TableViewCellDelegate::shouldSnapToSelected not implemented");
}

auto TableViewCellDelegate::getCellDelegateType() -> decltype(getCellDelegateType()) {
	throw std::runtime_error("TableViewCellDelegate::getCellDelegateType not implemented");
}

void MusicDownloadDelegate::loadSongInfoFinished(SongInfoObject* p0) {}

void MusicDownloadDelegate::loadSongInfoFailed(int p0, GJSongError p1) {}

void MusicDownloadDelegate::downloadSongFinished(int p0) {}

void MusicDownloadDelegate::downloadSongFailed(int p0, GJSongError p1) {}

void MusicDownloadDelegate::songStateChanged() {}

void MusicDownloadDelegate::downloadSFXFinished(int p0) {}

void MusicDownloadDelegate::downloadSFXFailed(int p0, GJSongError p1) {}

void MusicDownloadDelegate::musicActionFinished(GJMusicAction p0) {}

void MusicDownloadDelegate::musicActionFailed(GJMusicAction p0) {}

auto AudioAssetsBrowser::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("AudioAssetsBrowser::registerWithTouchDispatcher not implemented");
}

auto AudioAssetsBrowser::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("AudioAssetsBrowser::keyBackClicked not implemented");
}

auto AudioAssetsBrowser::musicActionFinished(GJMusicAction p0) -> decltype(musicActionFinished(p0)) {
	throw std::runtime_error("AudioAssetsBrowser::musicActionFinished not implemented");
}

auto AudioAssetsBrowser::musicActionFailed(GJMusicAction p0) -> decltype(musicActionFailed(p0)) {
	throw std::runtime_error("AudioAssetsBrowser::musicActionFailed not implemented");
}

auto AudioAssetsBrowser::cellPerformedAction(TableViewCell* p0, int p1, CellAction p2, cocos2d::CCNode* p3) -> decltype(cellPerformedAction(p0, p1, p2, p3)) {
	throw std::runtime_error("AudioAssetsBrowser::cellPerformedAction not implemented");
}

auto AudioAssetsBrowser::getSelectedCellIdx() -> decltype(getSelectedCellIdx()) {
	throw std::runtime_error("AudioAssetsBrowser::getSelectedCellIdx not implemented");
}

auto AudioAssetsBrowser::getCellDelegateType() -> decltype(getCellDelegateType()) {
	throw std::runtime_error("AudioAssetsBrowser::getCellDelegateType not implemented");
}

void AudioEffectsLayer::draw() {}

auto AudioEffectsLayer::updateTweenAction(float p0, char const* p1) -> decltype(updateTweenAction(p0, p1)) {
	throw std::runtime_error("AudioEffectsLayer::updateTweenAction not implemented");
}

auto AudioEffectsLayer::audioStep(float p0) -> decltype(audioStep(p0)) {
	using FunctionType = decltype(audioStep(p0))(*)(AudioEffectsLayer*, float);
	static auto func = wrapFunction(base::get() + 0x84d80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto AudioLineGuideGameObject::init() -> decltype(init()) {
	throw std::runtime_error("AudioLineGuideGameObject::init not implemented");
}

auto AudioLineGuideGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("AudioLineGuideGameObject::customObjectSetup not implemented");
}

auto AudioLineGuideGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("AudioLineGuideGameObject::getSaveString not implemented");
}

BitmapFontCache::BitmapFontCache() {}

void BitmapFontCache::purgeSharedFontCache() {
        auto** instancePtr = reinterpret_cast<BitmapFontCache**>(geode::base::get() + 0x6a4e08);
        if (*instancePtr) {
            (*instancePtr)->release();
            *instancePtr = nullptr;
        }
    }

BitmapFontCache* BitmapFontCache::sharedFontCache() {
        auto** instancePtr = reinterpret_cast<BitmapFontCache**>(geode::base::get() + 0x6a4e08);
        if (!*instancePtr) {
            *instancePtr = new BitmapFontCache();
            (*instancePtr)->init();
        }
        return *instancePtr;
    }

auto BitmapFontCache::fontWithConfigFile(char const* p0, float p1) -> decltype(fontWithConfigFile(p0, p1)) {
	using FunctionType = decltype(fontWithConfigFile(p0, p1))(*)(BitmapFontCache*, char const*, float);
	static auto func = wrapFunction(base::get() + 0x3b380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

bool BitmapFontCache::init() {
        m_cache = cocos2d::CCDictionary::create();
        m_cache->retain();
        return true;
    }

void TableViewDelegate::willTweenToIndexPath(CCIndexPath& p0, TableViewCell* p1, TableView* p2) {}

void TableViewDelegate::didEndTweenToIndexPath(CCIndexPath& p0, TableView* p1) {}

void TableViewDelegate::TableViewWillDisplayCellForRowAtIndexPath(CCIndexPath& p0, TableViewCell* p1, TableView* p2) {}

void TableViewDelegate::TableViewDidDisplayCellForRowAtIndexPath(CCIndexPath& p0, TableViewCell* p1, TableView* p2) {}

void TableViewDelegate::TableViewWillReloadCellForRowAtIndexPath(CCIndexPath& p0, TableViewCell* p1, TableView* p2) {}

float TableViewDelegate::cellHeightForRowAtIndexPath(CCIndexPath& p0, TableView* p1) { return 0; }

void TableViewDelegate::didSelectRowAtIndexPath(CCIndexPath& p0, TableView* p1) {}

int TableViewDataSource::numberOfRowsInSection(unsigned int p0, TableView* p1) { return 0; }

unsigned int TableViewDataSource::numberOfSectionsInTableView(TableView* p0) { return 0; }

void TableViewDataSource::TableViewCommitCellEditingStyleForRowAtIndexPath(TableView* p0, TableViewCellEditingStyle p1, CCIndexPath& p2) {}

TableViewCell* TableViewDataSource::cellForRowAtIndexPath(CCIndexPath& p0, TableView* p1) { return nullptr; }

BoomListView::BoomListView() {}

BoomListView::~BoomListView() {
        CC_SAFE_RELEASE(m_entries);
    }

void BoomListView::draw() {}

auto BoomListView::setupList(float p0) -> decltype(setupList(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&BoomListView::setupList), this);
	using FunctionType = decltype(setupList(p0))(*)(BoomListView*, float);
	static auto func = wrapFunction(base::get() + 0x3c350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

void BoomListView::TableViewWillDisplayCellForRowAtIndexPath(CCIndexPath& p0, TableViewCell* p1, TableView* p2) {}

auto BoomListView::cellHeightForRowAtIndexPath(CCIndexPath& p0, TableView* p1) -> decltype(cellHeightForRowAtIndexPath(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<CCIndexPath&, TableView*>::func(&BoomListView::cellHeightForRowAtIndexPath), this);
	using FunctionType = decltype(cellHeightForRowAtIndexPath(p0, p1))(*)(BoomListView*, CCIndexPath&, TableView*);
	static auto func = wrapFunction(base::get() + 0x3c3e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void BoomListView::didSelectRowAtIndexPath(CCIndexPath& p0, TableView* p1) {}

auto BoomListView::numberOfRowsInSection(unsigned int p0, TableView* p1) -> decltype(numberOfRowsInSection(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned int, TableView*>::func(&BoomListView::numberOfRowsInSection), this);
	using FunctionType = decltype(numberOfRowsInSection(p0, p1))(*)(BoomListView*, unsigned int, TableView*);
	static auto func = wrapFunction(base::get() + 0x3c3f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

unsigned int BoomListView::numberOfSectionsInTableView(TableView* p0) { return 1; }

auto BoomListView::cellForRowAtIndexPath(CCIndexPath& p0, TableView* p1) -> decltype(cellForRowAtIndexPath(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<CCIndexPath&, TableView*>::func(&BoomListView::cellForRowAtIndexPath), this);
	using FunctionType = decltype(cellForRowAtIndexPath(p0, p1))(*)(BoomListView*, CCIndexPath&, TableView*);
	static auto func = wrapFunction(base::get() + 0x3c410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void BoomListView::TableViewCommitCellEditingStyleForRowAtIndexPath(TableView* p0, TableViewCellEditingStyle p1, CCIndexPath& p2) {}

void BoomListView::TableViewWillReloadCellForRowAtIndexPath(CCIndexPath& p0, TableViewCell* p1, TableView* p2) {}

auto BoomListView::getListCell(char const* p0) -> decltype(getListCell(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&BoomListView::getListCell), this);
	using FunctionType = decltype(getListCell(p0))(*)(BoomListView*, char const*);
	static auto func = wrapFunction(base::get() + 0x3c4a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto BoomListView::loadCell(TableViewCell* p0, int p1) -> decltype(loadCell(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<TableViewCell*, int>::func(&BoomListView::loadCell), this);
	using FunctionType = decltype(loadCell(p0, p1))(*)(BoomListView*, TableViewCell*, int);
	static auto func = wrapFunction(base::get() + 0x3c610, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto BoomListView::init(cocos2d::CCArray* p0, TableViewCellDelegate* p1, float p2, float p3, int p4, BoomListType p5, float p6) -> decltype(init(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5, p6))(*)(BoomListView*, cocos2d::CCArray*, TableViewCellDelegate*, float, float, int, BoomListType, float);
	static auto func = wrapFunction(base::get() + 0x3bfe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6);
}

bool BoomListView::init(cocos2d::CCArray* entries, BoomListType type, float width, float height) {
        return this->init(entries, nullptr, height, width, 0, type, 0.0f);
    }

auto BoomScrollLayer::create(cocos2d::CCArray* pages, int unk1, bool unk2, cocos2d::CCArray* unk3, DynamicScrollDelegate* delegate) -> decltype(create(pages, unk1, unk2, unk3, delegate)) {
	using FunctionType = decltype(create(pages, unk1, unk2, unk3, delegate))(*)(cocos2d::CCArray*, int, bool, cocos2d::CCArray*, DynamicScrollDelegate*);
	static auto func = wrapFunction(base::get() + 0x3d060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(pages, unk1, unk2, unk3, delegate);
}

BoomScrollLayer* BoomScrollLayer::create(cocos2d::CCArray* pages, int unk1, bool unk2) {
        return BoomScrollLayer::create(pages, unk1, unk2, nullptr, nullptr);
    }

auto BoomScrollLayer::visit() -> decltype(visit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&BoomScrollLayer::visit), this);
	using FunctionType = decltype(visit())(*)(BoomScrollLayer*);
	static auto func = wrapFunction(base::get() + 0x3dbd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto BoomScrollLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&BoomScrollLayer::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(BoomScrollLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x3e710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto BoomScrollLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&BoomScrollLayer::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(BoomScrollLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x3e7c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto BoomScrollLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&BoomScrollLayer::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(BoomScrollLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x3eaf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto BoomScrollLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&BoomScrollLayer::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(BoomScrollLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x3e630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto BoomScrollLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("BoomScrollLayer::registerWithTouchDispatcher not implemented");
}

cocos2d::CCLayer* BoomScrollLayer::getPage(int p0) {
        auto index = m_page;
        if (m_dynamic) index = index % m_pages->count();
        return static_cast<cocos2d::CCLayer*>(m_pages->objectAtIndex(index));
    }

int BoomScrollLayer::getRelativePageForNum(int page) {
        return page < 1 ? page : page % getTotalPages();
    }

cocos2d::CCPoint BoomScrollLayer::getRelativePosForPage(int page) {
        return { this->getContentSize().width - m_pageOffset * page, 0.f };
    }

int BoomScrollLayer::getTotalPages() {
        return m_dynamic ? m_dynamicObjects->count() : m_pages->count();
    }

auto BoomScrollLayer::init(cocos2d::CCArray* p0, int p1, bool p2, cocos2d::CCArray* p3, DynamicScrollDelegate* p4) -> decltype(init(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4))(*)(BoomScrollLayer*, cocos2d::CCArray*, int, bool, cocos2d::CCArray*, DynamicScrollDelegate*);
	static auto func = wrapFunction(base::get() + 0x3d230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto BoomScrollLayer::instantMoveToPage(int p0) -> decltype(instantMoveToPage(p0)) {
	using FunctionType = decltype(instantMoveToPage(p0))(*)(BoomScrollLayer*, int);
	static auto func = wrapFunction(base::get() + 0x3ddc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto BoomScrollLayer::moveToPage(int p0) -> decltype(moveToPage(p0)) {
	using FunctionType = decltype(moveToPage(p0))(*)(BoomScrollLayer*, int);
	static auto func = wrapFunction(base::get() + 0x3dea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto BoomScrollLayer::moveToPageEnded() -> decltype(moveToPageEnded()) {
	using FunctionType = decltype(moveToPageEnded())(*)(BoomScrollLayer*);
	static auto func = wrapFunction(base::get() + 0x3dc30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto BoomScrollLayer::pageNumberForPosition(cocos2d::CCPoint p0) -> decltype(pageNumberForPosition(p0)) {
	using FunctionType = decltype(pageNumberForPosition(p0))(*)(BoomScrollLayer*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x3dcc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

cocos2d::CCPoint BoomScrollLayer::positionForPageWithNumber(int page) {
        return { this->getContentSize().width + m_pageOffset * page, 0.f };
    }

void BoomScrollLayer::quickUpdate() {
        if (m_pageMoving) {
            m_pageMoving = false;
            m_extendedLayer->stopActionByTag(2);
            m_extendedLayer->setPosition(m_position);
            this->moveToPageEnded();
        }
    }

auto BoomScrollLayer::repositionPagesLooped() -> decltype(repositionPagesLooped()) {
	using FunctionType = decltype(repositionPagesLooped())(*)(BoomScrollLayer*);
	static auto func = wrapFunction(base::get() + 0x3e060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void BoomScrollLayer::setDotScale(float scale) {
        for (int i = 0; i < m_dots->count(); i++) {
            static_cast<cocos2d::CCSprite*>(m_dots->objectAtIndex(i))->setScale(scale);
        }
    }

void BoomScrollLayer::setPagesIndicatorPosition(cocos2d::CCPoint pos) {
        m_dotPosition = pos;
        this->updateDots(0.f);
    }

auto BoomScrollLayer::setupDynamicScrolling(cocos2d::CCArray* p0, DynamicScrollDelegate* p1) -> decltype(setupDynamicScrolling(p0, p1)) {
	using FunctionType = decltype(setupDynamicScrolling(p0, p1))(*)(BoomScrollLayer*, cocos2d::CCArray*, DynamicScrollDelegate*);
	static auto func = wrapFunction(base::get() + 0x3d5a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto BoomScrollLayer::togglePageIndicators(bool p0) -> decltype(togglePageIndicators(p0)) {
	using FunctionType = decltype(togglePageIndicators(p0))(*)(BoomScrollLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x3db60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto BoomScrollLayer::updateDots(float p0) -> decltype(updateDots(p0)) {
	using FunctionType = decltype(updateDots(p0))(*)(BoomScrollLayer*, float);
	static auto func = wrapFunction(base::get() + 0x3d960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto BoomScrollLayer::updatePages() -> decltype(updatePages()) {
	using FunctionType = decltype(updatePages())(*)(BoomScrollLayer*);
	static auto func = wrapFunction(base::get() + 0x3d840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto BoomScrollLayerDelegate::scrollLayerScrollingStarted(BoomScrollLayer* p0) -> decltype(scrollLayerScrollingStarted(p0)) {
	throw std::runtime_error("BoomScrollLayerDelegate::scrollLayerScrollingStarted not implemented");
}

auto BoomScrollLayerDelegate::scrollLayerScrolledToPage(BoomScrollLayer* p0, int p1) -> decltype(scrollLayerScrolledToPage(p0, p1)) {
	throw std::runtime_error("BoomScrollLayerDelegate::scrollLayerScrolledToPage not implemented");
}

auto BoomScrollLayerDelegate::scrollLayerMoved(cocos2d::CCPoint p0) -> decltype(scrollLayerMoved(p0)) {
	throw std::runtime_error("BoomScrollLayerDelegate::scrollLayerMoved not implemented");
}

auto BoomScrollLayerDelegate::scrollLayerWillScrollToPage(BoomScrollLayer* p0, int p1) -> decltype(scrollLayerWillScrollToPage(p0, p1)) {
	throw std::runtime_error("BoomScrollLayerDelegate::scrollLayerWillScrollToPage not implemented");
}

auto BrowseSmartTemplateLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&BrowseSmartTemplateLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(BrowseSmartTemplateLayer*);
	static auto func = wrapFunction(base::get() + 0x443040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto BrowseSmartTemplateLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&BrowseSmartTemplateLayer::onBack), this);
	using FunctionType = decltype(onBack(sender))(*)(BrowseSmartTemplateLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x443060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto BrowseSmartKeyLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	throw std::runtime_error("BrowseSmartKeyLayer::onBack not implemented");
}

ButtonSprite::ButtonSprite() : ButtonSprite(geode::CutoffConstructor, sizeof(ButtonSprite)) {
	// here we construct it as normal as we can, then destruct it
	// using the generated functions. this ensures no memory gets leaked
	// no crashes :pray:
	CCDestructor::lock(this) = true;
	ButtonSprite::~ButtonSprite();
	using FunctionType = void(*)(ButtonSprite*);
	static auto func = wrapFunction(base::get() + 0x3ed20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
}

auto ButtonSprite::create(char const* caption, int width, int p2, float scale, bool absolute, char const* font, char const* bg, float height) -> decltype(create(caption, width, p2, scale, absolute, font, bg, height)) {
	using FunctionType = decltype(create(caption, width, p2, scale, absolute, font, bg, height))(*)(char const*, int, int, float, bool, char const*, char const*, float);
	static auto func = wrapFunction(base::get() + 0x3f150, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(caption, width, p2, scale, absolute, font, bg, height);
}

auto ButtonSprite::create(cocos2d::CCSprite* topSprite, int width, int unused, float height, float scale, bool absolute, char const* bgSprite, bool noScaleSpriteForBG) -> decltype(create(topSprite, width, unused, height, scale, absolute, bgSprite, noScaleSpriteForBG)) {
	using FunctionType = decltype(create(topSprite, width, unused, height, scale, absolute, bgSprite, noScaleSpriteForBG))(*)(cocos2d::CCSprite*, int, int, float, float, bool, char const*, bool);
	static auto func = wrapFunction(base::get() + 0x3ee40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(topSprite, width, unused, height, scale, absolute, bgSprite, noScaleSpriteForBG);
}

ButtonSprite* ButtonSprite::create(cocos2d::CCSprite* topSprite, int width, bool absolute, float height, const char* texture, float scale) {
        return create(topSprite, width, 0, height, scale, absolute, texture, true);
    }

ButtonSprite* ButtonSprite::create(const char* caption, int width, bool absolute, const char* font, const char* texture, float height, float scale) {
        return create(caption, width, 0, scale, absolute, font, texture, height);
    }

ButtonSprite* ButtonSprite::create(char const* caption) {
        return ButtonSprite::create(caption, 0, false, "goldFont.fnt", "GJ_button_01.png", .0f, 1.f);
    }

ButtonSprite* ButtonSprite::create(char const* caption, const char* font, const char* texture) {
        return ButtonSprite::create(caption, 0, false, font, texture, .0f, 1.f);
    }

ButtonSprite* ButtonSprite::create(char const* caption, const char* font, const char* texture, float scale) {
        return ButtonSprite::create(caption, 0, false, font, texture, .0f, scale);
    }

ButtonSprite* ButtonSprite::create(char const* caption, float scale) {
        return ButtonSprite::create(caption, 0, false, "goldFont.fnt", "GJ_button_01.png", .0f, scale);
    }

ButtonSprite* ButtonSprite::create(char const* caption, int width, int p2, float scale, bool absolute, char const* font, char const* bg) {
        return ButtonSprite::create(caption, width, p2, scale, absolute, font, bg, .0f);
    }

ButtonSprite* ButtonSprite::create(char const* caption, int width, int p2, float scale, bool absolute) {
        return ButtonSprite::create(caption, width, p2, scale, absolute, "goldFont.fnt", "GJ_button_01.png", .0f);
    }

ButtonSprite* ButtonSprite::create(cocos2d::CCSprite* topSprite, int width, int unused, float height, float scale, bool absolute) {
        return ButtonSprite::create(topSprite, width, unused, height, scale, absolute, "GJ_button_01.png", false);
    }

ButtonSprite* ButtonSprite::create(cocos2d::CCSprite* topSprite) {
        return ButtonSprite::create(topSprite, 0, 0, .0f, 1.f, false, "GJ_button_01.png", false);
    }

auto ButtonSprite::init(char const* p0, int p1, int p2, float p3, bool p4, char const* p5, char const* p6, float p7) -> decltype(init(p0, p1, p2, p3, p4, p5, p6, p7)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5, p6, p7))(*)(ButtonSprite*, char const*, int, int, float, bool, char const*, char const*, float);
	static auto func = wrapFunction(base::get() + 0x3f220, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7);
}

auto ButtonSprite::init(cocos2d::CCSprite* topSprite, int width, int unused, float height, float scale, bool absolute, char const* bgSprite, bool noScaleSpriteForBG) -> decltype(init(topSprite, width, unused, height, scale, absolute, bgSprite, noScaleSpriteForBG)) {
	using FunctionType = decltype(init(topSprite, width, unused, height, scale, absolute, bgSprite, noScaleSpriteForBG))(*)(ButtonSprite*, cocos2d::CCSprite*, int, int, float, float, bool, char const*, bool);
	static auto func = wrapFunction(base::get() + 0x3eef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, topSprite, width, unused, height, scale, absolute, bgSprite, noScaleSpriteForBG);
}

void ButtonSprite::setColor(cocos2d::ccColor3B color) {
        // i love inlined funcs
        if (m_label) m_label->setColor(color);
        if (m_subSprite) m_subSprite->setColor(color);
        if (m_subBGSprite) m_subBGSprite->setColor(color);
        if (m_BGSprite) m_BGSprite->setColor(color);
    }

auto ButtonSprite::setString(char const* p0) -> decltype(setString(p0)) {
	using FunctionType = decltype(setString(p0))(*)(ButtonSprite*, char const*);
	static auto func = wrapFunction(base::get() + 0x3fae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ButtonSprite::updateBGImage(char const* p0) -> decltype(updateBGImage(p0)) {
	using FunctionType = decltype(updateBGImage(p0))(*)(ButtonSprite*, char const*);
	static auto func = wrapFunction(base::get() + 0x3f520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ButtonSprite::updateSpriteBGSize() -> decltype(updateSpriteBGSize()) {
	using FunctionType = decltype(updateSpriteBGSize())(*)(ButtonSprite*);
	static auto func = wrapFunction(base::get() + 0x3f660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void ButtonSprite::updateSpriteOffset(cocos2d::CCPoint offset) {
        m_spritePosition = offset;
        this->updateSpriteBGSize();
    }

auto CameraTriggerGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*, int, gd::vector<int> const*>::func(&CameraTriggerGameObject::triggerObject), this);
	using FunctionType = decltype(triggerObject(p0, p1, p2))(*)(CameraTriggerGameObject*, GJBaseGameLayer*, int, gd::vector<int> const*);
	static auto func = wrapFunction(base::get() + 0x4a4cd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto CameraTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("CameraTriggerGameObject::customObjectSetup not implemented");
}

auto CameraTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("CameraTriggerGameObject::getSaveString not implemented");
}

auto CCAlertCircle::init() -> decltype(init()) {
	throw std::runtime_error("CCAlertCircle::init not implemented");
}

auto CCAlertCircle::draw() -> decltype(draw()) {
	throw std::runtime_error("CCAlertCircle::draw not implemented");
}

auto CCAnimateFrameCache::sharedSpriteFrameCache() -> decltype(sharedSpriteFrameCache()) {
	using FunctionType = decltype(sharedSpriteFrameCache())(*)();
	static auto func = wrapFunction(base::get() + 0x41450, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto CCAnimateFrameCache::addSpriteFramesWithFile(char const* p0) -> decltype(addSpriteFramesWithFile(p0)) {
	using FunctionType = decltype(addSpriteFramesWithFile(p0))(*)(CCAnimateFrameCache*, char const*);
	static auto func = wrapFunction(base::get() + 0x414e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

CCBlockLayer::CCBlockLayer() {
        m_unknown = nullptr;
    }

auto CCBlockLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCBlockLayer::init), this);
	using FunctionType = decltype(init())(*)(CCBlockLayer*);
	static auto func = wrapFunction(base::get() + 0x424e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCBlockLayer::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCBlockLayer::draw), this);
	using FunctionType = decltype(draw())(*)(CCBlockLayer*);
	static auto func = wrapFunction(base::get() + 0x426f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCBlockLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	throw std::runtime_error("CCBlockLayer::ccTouchBegan not implemented");
}

void CCBlockLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

void CCBlockLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

void CCBlockLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

auto CCBlockLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCBlockLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(CCBlockLayer*);
	static auto func = wrapFunction(base::get() + 0x425d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCBlockLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCBlockLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(CCBlockLayer*);
	static auto func = wrapFunction(base::get() + 0x42620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void CCBlockLayer::customSetup() {}

auto CCBlockLayer::enterLayer() -> decltype(enterLayer()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCBlockLayer::enterLayer), this);
	using FunctionType = decltype(enterLayer())(*)(CCBlockLayer*);
	static auto func = wrapFunction(base::get() + 0x425a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCBlockLayer::exitLayer() -> decltype(exitLayer()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCBlockLayer::exitLayer), this);
	using FunctionType = decltype(exitLayer())(*)(CCBlockLayer*);
	static auto func = wrapFunction(base::get() + 0x42640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCBlockLayer::showLayer(bool p0) -> decltype(showLayer(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&CCBlockLayer::showLayer), this);
	using FunctionType = decltype(showLayer(p0))(*)(CCBlockLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x42680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCBlockLayer::hideLayer(bool p0) -> decltype(hideLayer(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&CCBlockLayer::hideLayer), this);
	using FunctionType = decltype(hideLayer(p0))(*)(CCBlockLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x42690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCBlockLayer::layerVisible() -> decltype(layerVisible()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCBlockLayer::layerVisible), this);
	using FunctionType = decltype(layerVisible())(*)(CCBlockLayer*);
	static auto func = wrapFunction(base::get() + 0x426a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCBlockLayer::layerHidden() -> decltype(layerHidden()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCBlockLayer::layerHidden), this);
	using FunctionType = decltype(layerHidden())(*)(CCBlockLayer*);
	static auto func = wrapFunction(base::get() + 0x426b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void CCBlockLayer::enterAnimFinished() {}

void CCBlockLayer::disableUI() {}

void CCBlockLayer::enableUI() {}

auto CCCircleWave::create(float startRadius, float endRadius, float duration, bool fadeIn, bool easeOut) -> decltype(create(startRadius, endRadius, duration, fadeIn, easeOut)) {
	using FunctionType = decltype(create(startRadius, endRadius, duration, fadeIn, easeOut))(*)(float, float, float, bool, bool);
	static auto func = wrapFunction(base::get() + 0x42800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(startRadius, endRadius, duration, fadeIn, easeOut);
}

CCCircleWave* CCCircleWave::create(float startRadius, float endRadius, float duration, bool fadeIn) {
        return CCCircleWave::create(startRadius, endRadius, duration, fadeIn, true);
    }

auto CCCircleWave::setPosition(cocos2d::CCPoint const& p0) -> decltype(setPosition(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint const&>::func(&CCCircleWave::setPosition), this);
	using FunctionType = decltype(setPosition(p0))(*)(CCCircleWave*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x42af0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCCircleWave::removeMeAndCleanup() -> decltype(removeMeAndCleanup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCCircleWave::removeMeAndCleanup), this);
	using FunctionType = decltype(removeMeAndCleanup())(*)(CCCircleWave*);
	static auto func = wrapFunction(base::get() + 0x42f00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCCircleWave::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCCircleWave::draw), this);
	using FunctionType = decltype(draw())(*)(CCCircleWave*);
	static auto func = wrapFunction(base::get() + 0x42dd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCCircleWave::updateTweenAction(float p0, char const* p1) -> decltype(updateTweenAction(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, char const*>::func(&CCCircleWave::updateTweenAction), this);
	using FunctionType = decltype(updateTweenAction(p0, p1))(*)(CCCircleWave*, float, char const*);
	static auto func = wrapFunction(base::get() + 0x42b70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CCCircleWave::init(float startRadius, float endRadius, float duration, bool fadeIn, bool easeOut) -> decltype(init(startRadius, endRadius, duration, fadeIn, easeOut)) {
	using FunctionType = decltype(init(startRadius, endRadius, duration, fadeIn, easeOut))(*)(CCCircleWave*, float, float, float, bool, bool);
	static auto func = wrapFunction(base::get() + 0x428b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, startRadius, endRadius, duration, fadeIn, easeOut);
}

auto CCCircleWave::updatePosition(float p0) -> decltype(updatePosition(p0)) {
	using FunctionType = decltype(updatePosition(p0))(*)(CCCircleWave*, float);
	static auto func = wrapFunction(base::get() + 0x42b30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void CCCircleWaveDelegate::circleWaveWillBeRemoved(CCCircleWave* p0) {}

auto CCContentLayer::setPosition(cocos2d::CCPoint const& p0) -> decltype(setPosition(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint const&>::func(&CCContentLayer::setPosition), this);
	using FunctionType = decltype(setPosition(p0))(*)(CCContentLayer*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x42f70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCCountdown::init() -> decltype(init()) {
	throw std::runtime_error("CCCountdown::init not implemented");
}

auto CCCountdown::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	throw std::runtime_error("CCCountdown::setOpacity not implemented");
}

CCLightFlash::CCLightFlash() {
        m_lightStripArray = nullptr;
        m_layerColor = nullptr;
        m_dontFadeOut = false;
        m_mainLayer = nullptr;
        m_layerColorZOrder = 0;
    }

CCLightFlash* CCLightFlash::create() {
        auto ret = new CCLightFlash();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        CC_SAFE_DELETE(ret);
        return nullptr;
    }

bool CCLightFlash::init() {
        return true;
    }

auto CCLightFlash::cleanupFlash() -> decltype(cleanupFlash()) {
	using FunctionType = decltype(cleanupFlash())(*)(CCLightFlash*);
	static auto func = wrapFunction(base::get() + 0x43c80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CCLightFlash::playEffect(cocos2d::CCPoint pos, cocos2d::ccColor3B col, float startWidth, float startWidthVariation, float endWidth, float endWidthVariation, float endHeight, float stripDuration, float stripDurationVariance, float stripInterval, float stripStartDelay, float stripStartDelayVariation, float stripRotation, float stripRotationVariation, float stripOpacity, float stripOpacityVariation, int stripCount, bool circleRotation, bool fadeIn, float delay) -> decltype(playEffect(pos, col, startWidth, startWidthVariation, endWidth, endWidthVariation, endHeight, stripDuration, stripDurationVariance, stripInterval, stripStartDelay, stripStartDelayVariation, stripRotation, stripRotationVariation, stripOpacity, stripOpacityVariation, stripCount, circleRotation, fadeIn, delay)) {
	using FunctionType = decltype(playEffect(pos, col, startWidth, startWidthVariation, endWidth, endWidthVariation, endHeight, stripDuration, stripDurationVariance, stripInterval, stripStartDelay, stripStartDelayVariation, stripRotation, stripRotationVariation, stripOpacity, stripOpacityVariation, stripCount, circleRotation, fadeIn, delay))(*)(CCLightFlash*, cocos2d::CCPoint, cocos2d::ccColor3B, float, float, float, float, float, float, float, float, float, float, float, float, float, float, int, bool, bool, float);
	static auto func = wrapFunction(base::get() + 0x433a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, pos, col, startWidth, startWidthVariation, endWidth, endWidthVariation, endHeight, stripDuration, stripDurationVariance, stripInterval, stripStartDelay, stripStartDelayVariation, stripRotation, stripRotationVariation, stripOpacity, stripOpacityVariation, stripCount, circleRotation, fadeIn, delay);
}

auto CCLightFlash::removeLights() -> decltype(removeLights()) {
	using FunctionType = decltype(removeLights())(*)(CCLightFlash*);
	static auto func = wrapFunction(base::get() + 0x43c20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CCLightFlash::showFlash() -> decltype(showFlash()) {
	using FunctionType = decltype(showFlash())(*)(CCLightFlash*);
	static auto func = wrapFunction(base::get() + 0x438e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

CCLightStrip::CCLightStrip() {
        m_objectWidth = .0f;
        m_toWidth = .0f;
        m_toHeight = .0f;
        m_duration = .0f;
        m_opacity = .0f;
        m_width = .0f;
        m_height = .0f;
    }

CCLightStrip* CCLightStrip::create(float width, float toWidth, float toHeight, float duration, float delay) {
        auto ret = new CCLightStrip();
        if (ret->init(width, toWidth, toHeight, duration, delay)) {
            ret->autorelease();
            return ret;
        }
        CC_SAFE_DELETE(ret);
        return nullptr;
    }

auto CCLightStrip::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCLightStrip::draw), this);
	using FunctionType = decltype(draw())(*)(CCLightStrip*);
	static auto func = wrapFunction(base::get() + 0x43cb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCLightStrip::updateTweenAction(float value, char const* keyword) -> decltype(updateTweenAction(value, keyword)) {
	auto self = addresser::thunkAdjust(Resolve<float, char const*>::func(&CCLightStrip::updateTweenAction), this);
	using FunctionType = decltype(updateTweenAction(value, keyword))(*)(CCLightStrip*, float, char const*);
	static auto func = wrapFunction(base::get() + 0x43e70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, value, keyword);
}

bool CCLightStrip::init(float width, float toWidth, float toHeight, float duration, float delay) {
        this->m_toWidth = toWidth;
        this->m_toHeight = toHeight;
        this->m_objectWidth = width;
        this->m_duration = duration;
        this->m_width = width;
        this->m_opacity = 255.f;
        this->m_height = 1.f;

        this->setVisible(false);

        auto* delayAction = cocos2d::CCDelayTime::create(delay);
        auto* heightActionTween = cocos2d::CCActionTween::create(this->m_duration, "height", this->m_height, this->m_toHeight);
        auto* widthActionTween = cocos2d::CCActionTween::create(this->m_duration, "width", this->m_width, this->m_toWidth);
        auto* heightEaseOutAction = cocos2d::CCEaseOut::create(heightActionTween, 2.f);
        auto* widthEaseOutAction = cocos2d::CCEaseOut::create(widthActionTween, 2.f);
        auto* spawnEaseOutActions = cocos2d::CCSpawn::create(heightEaseOutAction, widthEaseOutAction, nullptr);
        auto* lightStripSequence = cocos2d::CCSequence::create(delayAction, cocos2d::CCShow::create(), spawnEaseOutActions, nullptr);

        cocos2d::CCDirector::sharedDirector()->getActionManager()->addAction(lightStripSequence, this, false);

        return true;
    }

CCMenuItemSpriteExtra::CCMenuItemSpriteExtra() {
        m_animationEnabled = false; //this is changed to true in init
        m_colorEnabled = false;
        m_colorDip = 0.784314f;
        m_scaleMultiplier = 1.f; //this is changed to 1.26f in init
        m_volume = 1.f;
        m_duration = 0.3f;
        m_unselectedDuration = 0.4f;
        m_animationType = MenuAnimationType::Scale;
        m_unknown4 = 0;
        //m_baseScale is initialized in init
    }

CCMenuItemSpriteExtra::~CCMenuItemSpriteExtra() {}

auto CCMenuItemSpriteExtra::create(cocos2d::CCNode* sprite, cocos2d::CCNode* disabledSprite, cocos2d::CCObject* target, cocos2d::SEL_MenuHandler callback) -> decltype(create(sprite, disabledSprite, target, callback)) {
	using FunctionType = decltype(create(sprite, disabledSprite, target, callback))(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
	static auto func = wrapFunction(base::get() + 0x44b40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(sprite, disabledSprite, target, callback);
}

CCMenuItemSpriteExtra* CCMenuItemSpriteExtra::create(cocos2d::CCNode* sprite, cocos2d::CCObject* target, cocos2d::SEL_MenuHandler callback) {
        return CCMenuItemSpriteExtra::create(sprite, nullptr, target, callback);
    }

auto CCMenuItemSpriteExtra::activate() -> decltype(activate()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCMenuItemSpriteExtra::activate), this);
	using FunctionType = decltype(activate())(*)(CCMenuItemSpriteExtra*);
	static auto func = wrapFunction(base::get() + 0x44d40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCMenuItemSpriteExtra::selected() -> decltype(selected()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCMenuItemSpriteExtra::selected), this);
	using FunctionType = decltype(selected())(*)(CCMenuItemSpriteExtra*);
	static auto func = wrapFunction(base::get() + 0x44e50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCMenuItemSpriteExtra::unselected() -> decltype(unselected()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCMenuItemSpriteExtra::unselected), this);
	using FunctionType = decltype(unselected())(*)(CCMenuItemSpriteExtra*);
	static auto func = wrapFunction(base::get() + 0x45070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCMenuItemSpriteExtra::init(cocos2d::CCNode* sprite, cocos2d::CCNode* disabledSprite, cocos2d::CCObject* target, cocos2d::SEL_MenuHandler callback) -> decltype(init(sprite, disabledSprite, target, callback)) {
	using FunctionType = decltype(init(sprite, disabledSprite, target, callback))(*)(CCMenuItemSpriteExtra*, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
	static auto func = wrapFunction(base::get() + 0x44be0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sprite, disabledSprite, target, callback);
}

void CCMenuItemSpriteExtra::setSizeMult(float mult) {
        //inlined on windows, member is in CCMenuItemSprite
        m_fSizeMult = mult;
    }

void CCMenuItemSpriteExtra::setSprite(cocos2d::CCSprite* sprite) {
        this->setNormalImage(sprite);
        this->updateSprite();
    }

void CCMenuItemSpriteExtra::updateSprite() {
        auto sprite = this->getNormalImage();
        auto size = sprite->getScaledContentSize();
        sprite->setPosition(size / 2);
        sprite->setAnchorPoint({ .5f, .5f });
        this->setContentSize(size);
    }

CCMenuItemToggler::CCMenuItemToggler() {}

auto CCMenuItemToggler::create(cocos2d::CCNode* p0, cocos2d::CCNode* p1, cocos2d::CCObject* p2, cocos2d::SEL_MenuHandler p3) -> decltype(create(p0, p1, p2, p3)) {
	using FunctionType = decltype(create(p0, p1, p2, p3))(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
	static auto func = wrapFunction(base::get() + 0x451e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3);
}

CCMenuItemToggler* CCMenuItemToggler::createWithSize(const char* spr1, const char* spr2, cocos2d::CCObject* target, cocos2d::SEL_MenuHandler callback, float scale) {
        auto sprOff = cocos2d::CCSprite::createWithSpriteFrameName(spr1);
        auto sprOn = cocos2d::CCSprite::createWithSpriteFrameName(spr2);

        sprOff->setScale(scale);
        sprOn->setScale(scale);

        return create(sprOff, sprOn, target, callback);
    }

CCMenuItemToggler* CCMenuItemToggler::createWithStandardSprites(cocos2d::CCObject* target, cocos2d::SEL_MenuHandler callback, float scale) {
        auto sprOff = cocos2d::CCSprite::createWithSpriteFrameName("GJ_checkOff_001.png");
        auto sprOn = cocos2d::CCSprite::createWithSpriteFrameName("GJ_checkOn_001.png");

        float maxWidth = (std::max)(sprOff->getContentSize().width, sprOn->getContentSize().width);
        float maxHeight = (std::max)(sprOff->getContentSize().height, sprOn->getContentSize().height);

        sprOff->setScale(scale);
        sprOn->setScale(scale);

        auto ret = create(sprOff, sprOn, target, callback);

        ret->setContentSize({maxWidth, maxHeight});

        ret->m_offButton->setContentSize({maxWidth, maxHeight});
        ret->m_onButton->setContentSize({maxWidth, maxHeight});

             ret->m_offButton->setPosition({maxWidth/2, maxHeight/2});
        ret->m_onButton->setPosition({maxWidth/2, maxHeight/2});

        sprOff->setPosition({maxWidth/2, maxHeight/2});
        sprOn->setPosition({maxWidth/2, maxHeight/2});

        return ret;
    }

auto CCMenuItemToggler::activate() -> decltype(activate()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCMenuItemToggler::activate), this);
	using FunctionType = decltype(activate())(*)(CCMenuItemToggler*);
	static auto func = wrapFunction(base::get() + 0x45490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCMenuItemToggler::selected() -> decltype(selected()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCMenuItemToggler::selected), this);
	using FunctionType = decltype(selected())(*)(CCMenuItemToggler*);
	static auto func = wrapFunction(base::get() + 0x45440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCMenuItemToggler::unselected() -> decltype(unselected()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCMenuItemToggler::unselected), this);
	using FunctionType = decltype(unselected())(*)(CCMenuItemToggler*);
	static auto func = wrapFunction(base::get() + 0x454e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCMenuItemToggler::setEnabled(bool p0) -> decltype(setEnabled(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&CCMenuItemToggler::setEnabled), this);
	using FunctionType = decltype(setEnabled(p0))(*)(CCMenuItemToggler*, bool);
	static auto func = wrapFunction(base::get() + 0x45530, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

bool CCMenuItemToggler::init(cocos2d::CCNode* off, cocos2d::CCNode* on, cocos2d::CCObject* target, cocos2d::SEL_MenuHandler callback) {
        if (!CCMenuItem::initWithTarget(target, callback)) return false;

        m_offButton = CCMenuItemSpriteExtra::create(off, nullptr, this, menu_selector(CCMenuItemToggler::normalTouch));
        m_onButton = CCMenuItemSpriteExtra::create(on, nullptr, this, menu_selector(CCMenuItemToggler::selectedTouch));

        this->addChild(m_offButton);
        this->addChild(m_onButton);

        m_offButton->getNormalImage()->setAnchorPoint({0.5f, 0.5f});
        m_onButton->getNormalImage()->setAnchorPoint({0.5f, 0.5f});

        auto imgoff = m_offButton->getNormalImage();
        auto imgon = m_onButton->getNormalImage();

        imgoff->setPosition(m_offButton->convertToNodeSpace({0.f, 0.f}));
        imgon->setPosition(m_onButton->convertToNodeSpace({0.f, 0.f}));
        m_notClickable = false;
        this->toggle(false);

        return true;
    }

bool CCMenuItemToggler::isOn() {
        return m_toggled;
    }

bool CCMenuItemToggler::isToggled() {
        return m_toggled;
    }

auto CCMenuItemToggler::normalTouch(cocos2d::CCObject* p0) -> decltype(normalTouch(p0)) {
	using FunctionType = decltype(normalTouch(p0))(*)(CCMenuItemToggler*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x45580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CCMenuItemToggler::selectedTouch(cocos2d::CCObject* p0) -> decltype(selectedTouch(p0)) {
	using FunctionType = decltype(selectedTouch(p0))(*)(CCMenuItemToggler*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x455a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void CCMenuItemToggler::setClickable(bool on) {
        m_notClickable = !on;
    }

void CCMenuItemToggler::setSizeMult(float mult) {
        m_offButton->setSizeMult(mult);
        m_onButton->setSizeMult(mult);

        this->toggle(this->m_toggled);
    }

auto CCMenuItemToggler::toggle(bool p0) -> decltype(toggle(p0)) {
	using FunctionType = decltype(toggle(p0))(*)(CCMenuItemToggler*, bool);
	static auto func = wrapFunction(base::get() + 0x455c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void CCMenuItemToggler::toggleWithCallback(bool on) {
        this->activate();
        this->toggle(on);
    }

void CCMenuItemToggler::updateSprite() {
        m_offButton->updateSprite();
        m_onButton->updateSprite();
        auto size = m_offButton->getScaledContentSize();
        m_offButton->setPosition(size / 2);
        m_offButton->setAnchorPoint({ .5f, .5f });
        m_onButton->setPosition(size / 2);
        m_onButton->setAnchorPoint({ .5f, .5f });
        this->setContentSize(size);
    }

auto CCNodeContainer::init() -> decltype(init()) {
	throw std::runtime_error("CCNodeContainer::init not implemented");
}

auto CCNodeContainer::visit() -> decltype(visit()) {
	throw std::runtime_error("CCNodeContainer::visit not implemented");
}

auto CCPartAnimSprite::setScaleX(float p0) -> decltype(setScaleX(p0)) {
	throw std::runtime_error("CCPartAnimSprite::setScaleX not implemented");
}

auto CCPartAnimSprite::setScaleY(float p0) -> decltype(setScaleY(p0)) {
	throw std::runtime_error("CCPartAnimSprite::setScaleY not implemented");
}

auto CCPartAnimSprite::setScale(float p0) -> decltype(setScale(p0)) {
	throw std::runtime_error("CCPartAnimSprite::setScale not implemented");
}

auto CCPartAnimSprite::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&CCPartAnimSprite::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(CCPartAnimSprite*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x468a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCPartAnimSprite::setBlendFunc(cocos2d::_ccBlendFunc p0) -> decltype(setBlendFunc(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccBlendFunc>::func(&CCPartAnimSprite::setBlendFunc), this);
	using FunctionType = decltype(setBlendFunc(p0))(*)(CCPartAnimSprite*, cocos2d::_ccBlendFunc);
	static auto func = wrapFunction(base::get() + 0x466f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCPartAnimSprite::setDisplayFrame(cocos2d::CCSpriteFrame* p0) -> decltype(setDisplayFrame(p0)) {
	throw std::runtime_error("CCPartAnimSprite::setDisplayFrame not implemented");
}

auto CCPartAnimSprite::isFrameDisplayed(cocos2d::CCSpriteFrame* p0) -> decltype(isFrameDisplayed(p0)) {
	throw std::runtime_error("CCPartAnimSprite::isFrameDisplayed not implemented");
}

auto CCPartAnimSprite::displayFrame() -> decltype(displayFrame()) {
	throw std::runtime_error("CCPartAnimSprite::displayFrame not implemented");
}

auto CCPartAnimSprite::setColor(cocos2d::ccColor3B p0) -> decltype(setColor(p0)) {
	using FunctionType = decltype(setColor(p0))(*)(CCPartAnimSprite*, cocos2d::ccColor3B);
	static auto func = wrapFunction(base::get() + 0x467c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

CCScrollLayerExt::CCScrollLayerExt(cocos2d::CCRect p0) : CCScrollLayerExt(geode::CutoffConstructor, sizeof(CCScrollLayerExt)) {
	// here we construct it as normal as we can, then destruct it
	// using the generated functions. this ensures no memory gets leaked
	// no crashes :pray:
	CCDestructor::lock(this) = true;
	CCScrollLayerExt::~CCScrollLayerExt();
	using FunctionType = void(*)(CCScrollLayerExt*, cocos2d::CCRect);
	static auto func = wrapFunction(base::get() + 0x46a50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CCScrollLayerExt::visit() -> decltype(visit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCScrollLayerExt::visit), this);
	using FunctionType = decltype(visit())(*)(CCScrollLayerExt*);
	static auto func = wrapFunction(base::get() + 0x47ad0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCScrollLayerExt::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CCScrollLayerExt::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(CCScrollLayerExt*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x47580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CCScrollLayerExt::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CCScrollLayerExt::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(CCScrollLayerExt*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x47950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CCScrollLayerExt::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CCScrollLayerExt::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(CCScrollLayerExt*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x476a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CCScrollLayerExt::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CCScrollLayerExt::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(CCScrollLayerExt*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x47920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CCScrollLayerExt::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCScrollLayerExt::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(CCScrollLayerExt*);
	static auto func = wrapFunction(base::get() + 0x47530, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCScrollLayerExt::preVisitWithClippingRect(cocos2d::CCRect p0) -> decltype(preVisitWithClippingRect(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCRect>::func(&CCScrollLayerExt::preVisitWithClippingRect), this);
	using FunctionType = decltype(preVisitWithClippingRect(p0))(*)(CCScrollLayerExt*, cocos2d::CCRect);
	static auto func = wrapFunction(base::get() + 0x47c00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCScrollLayerExt::postVisit() -> decltype(postVisit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCScrollLayerExt::postVisit), this);
	using FunctionType = decltype(postVisit())(*)(CCScrollLayerExt*);
	static auto func = wrapFunction(base::get() + 0x47ca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCScrollLayerExt::moveToTop() -> decltype(moveToTop()) {
	using FunctionType = decltype(moveToTop())(*)(CCScrollLayerExt*);
	static auto func = wrapFunction(base::get() + 0x47000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CCScrollLayerExt::moveToTopWithOffset(float p0) -> decltype(moveToTopWithOffset(p0)) {
	using FunctionType = decltype(moveToTopWithOffset(p0))(*)(CCScrollLayerExt*, float);
	static auto func = wrapFunction(base::get() + 0x46f60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void CCScrollLayerExt::scrollLayer(float offset) {
        float y = m_contentLayer->getPositionY() + offset;
        float minY = getMinY();
        float maxY = getMaxY();
        m_contentLayer->setPositionY(y < minY ? minY : y > maxY ? maxY : y);
    }

void CCScrollLayerExtDelegate::scrllViewWillBeginDecelerating(CCScrollLayerExt* p0) {}

void CCScrollLayerExtDelegate::scrollViewDidEndDecelerating(CCScrollLayerExt* p0) {}

void CCScrollLayerExtDelegate::scrollViewTouchMoving(CCScrollLayerExt* p0) {}

void CCScrollLayerExtDelegate::scrollViewDidEndMoving(CCScrollLayerExt* p0) {}

void CCScrollLayerExtDelegate::scrollViewTouchBegin(CCScrollLayerExt* p0) {}

void CCScrollLayerExtDelegate::scrollViewTouchEnd(CCScrollLayerExt* p0) {}

auto CCSpriteCOpacity::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&CCSpriteCOpacity::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(CCSpriteCOpacity*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x483c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

CCSpriteWithHue::CCSpriteWithHue() {}

CCSpriteWithHue* CCSpriteWithHue::create(gd::string const& file, cocos2d::CCRect const& rect) {
        auto ret = new CCSpriteWithHue();
        if (ret->initWithFile(file.c_str(), rect)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

CCSpriteWithHue* CCSpriteWithHue::create(gd::string const& file) {
        auto ret = new CCSpriteWithHue();
        if (ret->initWithFile(file.c_str())) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

CCSpriteWithHue* CCSpriteWithHue::createWithSpriteFrame(cocos2d::CCSpriteFrame* frame) {
        auto ret = new CCSpriteWithHue();
        if (ret->initWithSpriteFrame(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

CCSpriteWithHue* CCSpriteWithHue::createWithTexture(cocos2d::CCTexture2D* texture, cocos2d::CCRect const& rect, bool rotated) {
        auto ret = new CCSpriteWithHue();
        if (ret->initWithTexture(texture, rect, rotated)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

CCSpriteWithHue* CCSpriteWithHue::createWithTexture(cocos2d::CCTexture2D* texture) {
        auto ret = new CCSpriteWithHue();
        if (ret->initWithTexture(texture)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto CCSpriteWithHue::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCSpriteWithHue::draw), this);
	using FunctionType = decltype(draw())(*)(CCSpriteWithHue*);
	static auto func = wrapFunction(base::get() + 0x48c20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCSpriteWithHue::initWithTexture(cocos2d::CCTexture2D* p0) -> decltype(initWithTexture(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTexture2D*>::func(&CCSpriteWithHue::initWithTexture), this);
	using FunctionType = decltype(initWithTexture(p0))(*)(CCSpriteWithHue*, cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x485f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCSpriteWithHue::initWithTexture(cocos2d::CCTexture2D* p0, cocos2d::CCRect const& p1) -> decltype(initWithTexture(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTexture2D*, cocos2d::CCRect const&>::func(&CCSpriteWithHue::initWithTexture), this);
	using FunctionType = decltype(initWithTexture(p0, p1))(*)(CCSpriteWithHue*, cocos2d::CCTexture2D*, cocos2d::CCRect const&);
	static auto func = wrapFunction(base::get() + 0x48650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CCSpriteWithHue::initWithTexture(cocos2d::CCTexture2D* p0, cocos2d::CCRect const& p1, bool p2) -> decltype(initWithTexture(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTexture2D*, cocos2d::CCRect const&, bool>::func(&CCSpriteWithHue::initWithTexture), this);
	using FunctionType = decltype(initWithTexture(p0, p1, p2))(*)(CCSpriteWithHue*, cocos2d::CCTexture2D*, cocos2d::CCRect const&, bool);
	static auto func = wrapFunction(base::get() + 0x48590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto CCSpriteWithHue::initWithSpriteFrame(cocos2d::CCSpriteFrame* p0) -> decltype(initWithSpriteFrame(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCSpriteFrame*>::func(&CCSpriteWithHue::initWithSpriteFrame), this);
	using FunctionType = decltype(initWithSpriteFrame(p0))(*)(CCSpriteWithHue*, cocos2d::CCSpriteFrame*);
	static auto func = wrapFunction(base::get() + 0x48660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCSpriteWithHue::getShaderName() -> decltype(getShaderName()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCSpriteWithHue::getShaderName), this);
	using FunctionType = decltype(getShaderName())(*)(CCSpriteWithHue*);
	static auto func = wrapFunction(base::get() + 0x48400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCSpriteWithHue::shaderBody() -> decltype(shaderBody()) {
	throw std::runtime_error("CCSpriteWithHue::shaderBody not implemented");
}

auto CCSpriteWithHue::updateColor() -> decltype(updateColor()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCSpriteWithHue::updateColor), this);
	using FunctionType = decltype(updateColor())(*)(CCSpriteWithHue*);
	static auto func = wrapFunction(base::get() + 0x48910, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

float CCSpriteWithHue::getAlpha() {
        return _displayedOpacity / 255.f;
    }

float CCSpriteWithHue::getHue() {
        return m_hue;
    }

void CCSpriteWithHue::getUniformLocations() {
        m_uHueLoc = glGetUniformLocation(m_pShaderProgram->getProgram(), "u_hue");
        m_uAlphaLoc = glGetUniformLocation(m_pShaderProgram->getProgram(), "u_alpha");
        m_uLumLoc = glGetUniformLocation(m_pShaderProgram->getProgram(), "u_lum");
    }

auto CCSpriteWithHue::initShader() -> decltype(initShader()) {
	using FunctionType = decltype(initShader())(*)(CCSpriteWithHue*);
	static auto func = wrapFunction(base::get() + 0x486d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void CCSpriteWithHue::setCustomLuminance(float r, float g, float b) {
        m_luminance[0] = r;
        m_luminance[1] = g;
        m_luminance[2] = b;
    }

void CCSpriteWithHue::setEvenLuminance(float luminance) {
        m_luminance[0] = luminance * 0.33f;
        m_luminance[1] = luminance * 0.33f;
        m_luminance[2] = luminance * 0.33f;
    }

void CCSpriteWithHue::setHue(float hue) {
        m_hue = hue;
        this->updateColorMatrix();
    }

void CCSpriteWithHue::setHueDegrees(float degrees) {
        auto deg = degrees;
        while (deg < 0.f) deg += 360.f;
        this->setHue(deg / 360.f * 6.28318548f);
    }

void CCSpriteWithHue::setLuminance(float luminance) {
        m_luminance[0] = luminance * 0.21f;
        m_luminance[1] = luminance * 0.72f;
        m_luminance[2] = luminance * 0.07f;
    }

void CCSpriteWithHue::setupDefaultSettings() {
        m_hue = 0.f;
        this->setLuminance(1.f);
    }

auto CCSpriteWithHue::updateColorMatrix() -> decltype(updateColorMatrix()) {
	using FunctionType = decltype(updateColorMatrix())(*)(CCSpriteWithHue*);
	static auto func = wrapFunction(base::get() + 0x48930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void CCSpriteWithHue::updateHue(float p0) {
        this->setHue(m_hue + 0.05235988f);
    }

CCSpriteGrayscale::CCSpriteGrayscale() {}

CCSpriteGrayscale* CCSpriteGrayscale::create(gd::string const& file, cocos2d::CCRect const& rect) {
        auto ret = new CCSpriteGrayscale();
        if (ret->initWithFile(file.c_str(), rect)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

CCSpriteGrayscale* CCSpriteGrayscale::create(gd::string const& file) {
        auto ret = new CCSpriteGrayscale();
        if (ret->initWithFile(file.c_str())) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

CCSpriteGrayscale* CCSpriteGrayscale::createWithSpriteFrame(cocos2d::CCSpriteFrame* frame) {
        auto ret = new CCSpriteGrayscale();
        if (ret->initWithSpriteFrame(frame)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto CCSpriteGrayscale::createWithSpriteFrameName(gd::string const& frameName) -> decltype(createWithSpriteFrameName(frameName)) {
	using FunctionType = decltype(createWithSpriteFrameName(frameName))(*)(gd::string const&);
	static auto func = wrapFunction(base::get() + 0x49020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(frameName);
}

CCSpriteGrayscale* CCSpriteGrayscale::createWithTexture(cocos2d::CCTexture2D* texture, cocos2d::CCRect const& rect, bool rotated) {
        auto ret = new CCSpriteGrayscale();
        if (ret->initWithTexture(texture, rect, rotated)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

CCSpriteGrayscale* CCSpriteGrayscale::createWithTexture(cocos2d::CCTexture2D* texture) {
        auto ret = new CCSpriteGrayscale();
        if (ret->initWithTexture(texture)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto CCSpriteGrayscale::getShaderName() -> decltype(getShaderName()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCSpriteGrayscale::getShaderName), this);
	using FunctionType = decltype(getShaderName())(*)(CCSpriteGrayscale*);
	static auto func = wrapFunction(base::get() + 0x48fc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCSpriteGrayscale::shaderBody() -> decltype(shaderBody()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCSpriteGrayscale::shaderBody), this);
	using FunctionType = decltype(shaderBody())(*)(CCSpriteGrayscale*);
	static auto func = wrapFunction(base::get() + 0x48e00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCSpritePart::setVisible(bool p0) -> decltype(setVisible(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&CCSpritePart::setVisible), this);
	using FunctionType = decltype(setVisible(p0))(*)(CCSpritePart*, bool);
	static auto func = wrapFunction(base::get() + 0x46a30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

CCTextInputNode::CCTextInputNode() {
        m_numberInput = false;
        m_caption = "";
        m_unknown1 = 0;
        m_selected = false;
        m_unknown2 = false;
        m_fontValue1 = -0.5f;
        m_fontValue2 = 8.0f;
        m_isChatFont = false;
        m_allowedChars = "";
        m_maxLabelWidth = 0.0f;
        m_maxLabelScale = 0.0f;
        m_placeholderScale = 0.0f;
        m_placeholderColor = cocos2d::ccc3(0, 0, 0);
        m_textColor = cocos2d::ccc3(0, 0, 0);
        m_cursor = nullptr;
        m_textField = nullptr;
        m_delegate = nullptr;
        m_maxLabelLength = 0;
        m_placeholderLabel = nullptr;
        m_filterSwearWords = false;
        m_usePasswordChar = false;
        m_forceOffset = false;
        m_textArea = nullptr;
        m_valueType = (InputValueType)0;
        m_decimalPlaces = 0;
        m_kerningAmount = 0;
    }

auto CCTextInputNode::create(float p0, float p1, char const* p2, char const* p3, int p4, char const* p5) -> decltype(create(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5))(*)(float, float, char const*, char const*, int, char const*);
	static auto func = wrapFunction(base::get() + 0x4f0f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5);
}

CCTextInputNode* CCTextInputNode::create(float width, float height, char const* placeholder, char const* fontPath) {
        return CCTextInputNode::create(width, height, placeholder, 0x18, fontPath);
    }

CCTextInputNode* CCTextInputNode::create(float width, float height, char const* placeholder, int fontSize, char const* fontPath) {
        return CCTextInputNode::create(width, height, placeholder, "Thonburi", fontSize, fontPath);
    }

auto CCTextInputNode::visit() -> decltype(visit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCTextInputNode::visit), this);
	using FunctionType = decltype(visit())(*)(CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x4f730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCTextInputNode::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CCTextInputNode::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(CCTextInputNode*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x512c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void CCTextInputNode::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

void CCTextInputNode::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

void CCTextInputNode::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

auto CCTextInputNode::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCTextInputNode::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x514d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCTextInputNode::textChanged() -> decltype(textChanged()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCTextInputNode::textChanged), this);
	using FunctionType = decltype(textChanged())(*)(CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x50410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCTextInputNode::onClickTrackNode(bool p0) -> decltype(onClickTrackNode(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&CCTextInputNode::onClickTrackNode), this);
	using FunctionType = decltype(onClickTrackNode(p0))(*)(CCTextInputNode*, bool);
	static auto func = wrapFunction(base::get() + 0x503f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCTextInputNode::keyboardWillShow(cocos2d::CCIMEKeyboardNotificationInfo& p0) -> decltype(keyboardWillShow(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCIMEKeyboardNotificationInfo&>::func(&CCTextInputNode::keyboardWillShow), this);
	using FunctionType = decltype(keyboardWillShow(p0))(*)(CCTextInputNode*, cocos2d::CCIMEKeyboardNotificationInfo&);
	static auto func = wrapFunction(base::get() + 0x50210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCTextInputNode::keyboardWillHide(cocos2d::CCIMEKeyboardNotificationInfo& p0) -> decltype(keyboardWillHide(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCIMEKeyboardNotificationInfo&>::func(&CCTextInputNode::keyboardWillHide), this);
	using FunctionType = decltype(keyboardWillHide(p0))(*)(CCTextInputNode*, cocos2d::CCIMEKeyboardNotificationInfo&);
	static auto func = wrapFunction(base::get() + 0x50370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCTextInputNode::onTextFieldInsertText(cocos2d::CCTextFieldTTF* pSender, char const* text, int nLen, cocos2d::enumKeyCodes keyCodes) -> decltype(onTextFieldInsertText(pSender, text, nLen, keyCodes)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTextFieldTTF*, char const*, int, cocos2d::enumKeyCodes>::func(&CCTextInputNode::onTextFieldInsertText), this);
	using FunctionType = decltype(onTextFieldInsertText(pSender, text, nLen, keyCodes))(*)(CCTextInputNode*, cocos2d::CCTextFieldTTF*, char const*, int, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x504a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, pSender, text, nLen, keyCodes);
}

auto CCTextInputNode::onTextFieldAttachWithIME(cocos2d::CCTextFieldTTF* tField) -> decltype(onTextFieldAttachWithIME(tField)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTextFieldTTF*>::func(&CCTextInputNode::onTextFieldAttachWithIME), this);
	using FunctionType = decltype(onTextFieldAttachWithIME(tField))(*)(CCTextInputNode*, cocos2d::CCTextFieldTTF*);
	static auto func = wrapFunction(base::get() + 0x50880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, tField);
}

auto CCTextInputNode::onTextFieldDetachWithIME(cocos2d::CCTextFieldTTF* tField) -> decltype(onTextFieldDetachWithIME(tField)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTextFieldTTF*>::func(&CCTextInputNode::onTextFieldDetachWithIME), this);
	using FunctionType = decltype(onTextFieldDetachWithIME(tField))(*)(CCTextInputNode*, cocos2d::CCTextFieldTTF*);
	static auto func = wrapFunction(base::get() + 0x50bb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, tField);
}

auto CCTextInputNode::addTextArea(TextArea* p0) -> decltype(addTextArea(p0)) {
	using FunctionType = decltype(addTextArea(p0))(*)(CCTextInputNode*, TextArea*);
	static auto func = wrapFunction(base::get() + 0x4f540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

cocos2d::CCLabelBMFont* CCTextInputNode::getPlaceholderLabel() {
        return m_placeholderLabel;
    }

gd::string CCTextInputNode::getString() {
        return m_textField->getString();
    }

auto CCTextInputNode::init(float p0, float p1, char const* p2, char const* p3, int p4, char const* p5) -> decltype(init(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5))(*)(CCTextInputNode*, float, float, char const*, char const*, int, char const*);
	static auto func = wrapFunction(base::get() + 0x4f300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto CCTextInputNode::refreshLabel() -> decltype(refreshLabel()) {
	using FunctionType = decltype(refreshLabel())(*)(CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x4fb40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void CCTextInputNode::setAllowedChars(gd::string filter) {
        m_allowedChars = filter;
    }

void CCTextInputNode::setDelegate(TextInputDelegate* delegate) {
        m_delegate = delegate;
    }

void CCTextInputNode::setLabelNormalColor(cocos2d::ccColor3B color) {
        m_textColor = color;
        this->refreshLabel();
    }

void CCTextInputNode::setLabelPlaceholderColor(cocos2d::ccColor3B color) {
        m_placeholderColor = color;
        this->refreshLabel();
    }

void CCTextInputNode::setLabelPlaceholderScale(float v) {
        m_placeholderScale = v;
        this->refreshLabel();
    }

void CCTextInputNode::setMaxLabelLength(int v) {
        m_maxLabelLength = v;
        this->refreshLabel();
    }

void CCTextInputNode::setMaxLabelScale(float v) {
        m_maxLabelScale = v;
        this->refreshLabel();
    }

void CCTextInputNode::setMaxLabelWidth(float v) {
        m_maxLabelWidth = v;
        this->refreshLabel();
    }

auto CCTextInputNode::setString(gd::string p0) -> decltype(setString(p0)) {
	using FunctionType = decltype(setString(p0))(*)(CCTextInputNode*, gd::string);
	static auto func = wrapFunction(base::get() + 0x4f7a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void CCTextInputNode::updateBlinkLabel() {
        this->updateBlinkLabelToChar(this->m_textField->m_uCursorPos);
    }

auto CCTextInputNode::updateBlinkLabelToChar(int p0) -> decltype(updateBlinkLabelToChar(p0)) {
	using FunctionType = decltype(updateBlinkLabelToChar(p0))(*)(CCTextInputNode*, int);
	static auto func = wrapFunction(base::get() + 0x4fe20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CCTextInputNode::updateCursorPosition(cocos2d::CCPoint p0, cocos2d::CCRect p1) -> decltype(updateCursorPosition(p0, p1)) {
	using FunctionType = decltype(updateCursorPosition(p0, p1))(*)(CCTextInputNode*, cocos2d::CCPoint, cocos2d::CCRect);
	static auto func = wrapFunction(base::get() + 0x50d60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto CCTextInputNode::updateDefaultFontValues(gd::string p0) -> decltype(updateDefaultFontValues(p0)) {
	using FunctionType = decltype(updateDefaultFontValues(p0))(*)(CCTextInputNode*, gd::string);
	static auto func = wrapFunction(base::get() + 0x4f630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CCTextInputNode::updateLabel(gd::string p0) -> decltype(updateLabel(p0)) {
	using FunctionType = decltype(updateLabel(p0))(*)(CCTextInputNode*, gd::string);
	static auto func = wrapFunction(base::get() + 0x4f840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJChallengeDelegate::challengeStatusFinished() -> decltype(challengeStatusFinished()) {
	throw std::runtime_error("GJChallengeDelegate::challengeStatusFinished not implemented");
}

auto GJChallengeDelegate::challengeStatusFailed() -> decltype(challengeStatusFailed()) {
	throw std::runtime_error("GJChallengeDelegate::challengeStatusFailed not implemented");
}

void CurrencyRewardDelegate::currencyWillExit(CurrencyRewardLayer* p0) {}

ChallengesPage* ChallengesPage::create() {
        auto ret = new ChallengesPage();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto ChallengesPage::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ChallengesPage::init), this);
	using FunctionType = decltype(init())(*)(ChallengesPage*);
	static auto func = wrapFunction(base::get() + 0x85300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ChallengesPage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ChallengesPage::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(ChallengesPage*);
	static auto func = wrapFunction(base::get() + 0x425d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ChallengesPage::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ChallengesPage::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(ChallengesPage*);
	static auto func = wrapFunction(base::get() + 0x86980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ChallengesPage::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ChallengesPage::show), this);
	using FunctionType = decltype(show())(*)(ChallengesPage*);
	static auto func = wrapFunction(base::get() + 0x867a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void ChallengesPage::FLAlert_Clicked(FLAlertLayer* p0, bool p1) {}

auto ChallengesPage::challengeStatusFinished() -> decltype(challengeStatusFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ChallengesPage::challengeStatusFinished), this);
	using FunctionType = decltype(challengeStatusFinished())(*)(ChallengesPage*);
	static auto func = wrapFunction(base::get() + 0x85db0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ChallengesPage::challengeStatusFailed() -> decltype(challengeStatusFailed()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ChallengesPage::challengeStatusFailed), this);
	using FunctionType = decltype(challengeStatusFailed())(*)(ChallengesPage*);
	static auto func = wrapFunction(base::get() + 0x85f40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ChallengesPage::currencyWillExit(CurrencyRewardLayer* p0) -> decltype(currencyWillExit(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CurrencyRewardLayer*>::func(&ChallengesPage::currencyWillExit), this);
	using FunctionType = decltype(currencyWillExit(p0))(*)(ChallengesPage*, CurrencyRewardLayer*);
	static auto func = wrapFunction(base::get() + 0x86cc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ChallengesPage::claimItem(ChallengeNode* p0, GJChallengeItem* p1, cocos2d::CCPoint p2) -> decltype(claimItem(p0, p1, p2)) {
	using FunctionType = decltype(claimItem(p0, p1, p2))(*)(ChallengesPage*, ChallengeNode*, GJChallengeItem*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x869d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto ChallengesPage::createChallengeNode(int number, bool skipAnimation, float animLength, bool isNew) -> decltype(createChallengeNode(number, skipAnimation, animLength, isNew)) {
	using FunctionType = decltype(createChallengeNode(number, skipAnimation, animLength, isNew))(*)(ChallengesPage*, int, bool, float, bool);
	static auto func = wrapFunction(base::get() + 0x86090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, number, skipAnimation, animLength, isNew);
}

auto ChallengesPage::exitNodeAtSlot(int p0, float p1) -> decltype(exitNodeAtSlot(p0, p1)) {
	using FunctionType = decltype(exitNodeAtSlot(p0, p1))(*)(ChallengesPage*, int, float);
	static auto func = wrapFunction(base::get() + 0x863c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto ChallengesPage::updateTimers(float p0) -> decltype(updateTimers(p0)) {
	using FunctionType = decltype(updateTimers(p0))(*)(ChallengesPage*, float);
	static auto func = wrapFunction(base::get() + 0x864b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJChallengeItem::encodeWithCoder(DS_Dictionary* dsdict) -> decltype(encodeWithCoder(dsdict)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&GJChallengeItem::encodeWithCoder), this);
	using FunctionType = decltype(encodeWithCoder(dsdict))(*)(GJChallengeItem*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x1f16a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, dsdict);
}

auto GJChallengeItem::canEncode() -> decltype(canEncode()) {
	throw std::runtime_error("GJChallengeItem::canEncode not implemented");
}

ChallengeNode* ChallengeNode::create(GJChallengeItem* challengeItem, ChallengesPage* challengesPage, bool isNew) {
        auto ret = new ChallengeNode();
        if (ret->init(challengeItem, challengesPage, isNew)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto ChallengeNode::init(GJChallengeItem* challengeItem, ChallengesPage* challengesPage, bool isNew) -> decltype(init(challengeItem, challengesPage, isNew)) {
	using FunctionType = decltype(init(challengeItem, challengesPage, isNew))(*)(ChallengeNode*, GJChallengeItem*, ChallengesPage*, bool);
	static auto func = wrapFunction(base::get() + 0x86ce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, challengeItem, challengesPage, isNew);
}

auto CharacterColorDelegate::playerColorChanged() -> decltype(playerColorChanged()) {
	throw std::runtime_error("CharacterColorDelegate::playerColorChanged not implemented");
}

auto CharacterColorDelegate::showUnlockPopup(int p0, UnlockType p1) -> decltype(showUnlockPopup(p0, p1)) {
	throw std::runtime_error("CharacterColorDelegate::showUnlockPopup not implemented");
}

CharacterColorPage::CharacterColorPage() {
        m_colorMode = 0;
        m_playerObjects = nullptr;
        m_modeButtons = nullptr;
        m_colorButtons = nullptr;
        m_cursors = nullptr;
        m_delegate = nullptr;
        m_glowToggler = nullptr;
        m_glowLabel = nullptr;
    }

CharacterColorPage* CharacterColorPage::create() {
        auto ret = new CharacterColorPage();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto CharacterColorPage::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CharacterColorPage::init), this);
	using FunctionType = decltype(init())(*)(CharacterColorPage*);
	static auto func = wrapFunction(base::get() + 0x87f30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CharacterColorPage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CharacterColorPage::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(CharacterColorPage*);
	static auto func = wrapFunction(base::get() + 0x425d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CharacterColorPage::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CharacterColorPage::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(CharacterColorPage*);
	static auto func = wrapFunction(base::get() + 0x8a7a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CharacterColorPage::show() -> decltype(show()) {
	throw std::runtime_error("CharacterColorPage::show not implemented");
}

auto CharacterColorPage::createColorMenu() -> decltype(createColorMenu()) {
	using FunctionType = decltype(createColorMenu())(*)(CharacterColorPage*);
	static auto func = wrapFunction(base::get() + 0x88e50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CharacterColorPage::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(CharacterColorPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x8a760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CharacterColorPage::onMode(cocos2d::CCObject* sender) -> decltype(onMode(sender)) {
	using FunctionType = decltype(onMode(sender))(*)(CharacterColorPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x89550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CharacterColorPage::onPlayerColor(cocos2d::CCObject* sender) -> decltype(onPlayerColor(sender)) {
	using FunctionType = decltype(onPlayerColor(sender))(*)(CharacterColorPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x89d60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CharacterColorPage::toggleGlow(cocos2d::CCObject* p0) -> decltype(toggleGlow(p0)) {
	using FunctionType = decltype(toggleGlow(p0))(*)(CharacterColorPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x88da0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CharacterColorPage::toggleShip(cocos2d::CCObject* p0) -> decltype(toggleShip(p0)) {
	using FunctionType = decltype(toggleShip(p0))(*)(CharacterColorPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x88c80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CharacterColorPage::updateIconColors() -> decltype(updateIconColors()) {
	using FunctionType = decltype(updateIconColors())(*)(CharacterColorPage*);
	static auto func = wrapFunction(base::get() + 0x8a540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CheckpointGameObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CheckpointGameObject::init), this);
	using FunctionType = decltype(init())(*)(CheckpointGameObject*);
	static auto func = wrapFunction(base::get() + 0x4a1240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CheckpointGameObject::setupCustomSprites(gd::string p0) -> decltype(setupCustomSprites(p0)) {
	throw std::runtime_error("CheckpointGameObject::setupCustomSprites not implemented");
}

auto CheckpointGameObject::resetObject() -> decltype(resetObject()) {
	throw std::runtime_error("CheckpointGameObject::resetObject not implemented");
}

auto CheckpointGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*, int, gd::vector<int> const*>::func(&CheckpointGameObject::triggerObject), this);
	using FunctionType = decltype(triggerObject(p0, p1, p2))(*)(CheckpointGameObject*, GJBaseGameLayer*, int, gd::vector<int> const*);
	static auto func = wrapFunction(base::get() + 0x4a12c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto CheckpointGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("CheckpointGameObject::customObjectSetup not implemented");
}

auto CheckpointGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("CheckpointGameObject::getSaveString not implemented");
}

auto CheckpointGameObject::triggerActivated(float p0) -> decltype(triggerActivated(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CheckpointGameObject::triggerActivated), this);
	using FunctionType = decltype(triggerActivated(p0))(*)(CheckpointGameObject*, float);
	static auto func = wrapFunction(base::get() + 0x4a12e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CheckpointGameObject::restoreObject() -> decltype(restoreObject()) {
	throw std::runtime_error("CheckpointGameObject::restoreObject not implemented");
}

auto CheckpointGameObject::updateSyncedAnimation(float p0, int p1) -> decltype(updateSyncedAnimation(p0, p1)) {
	throw std::runtime_error("CheckpointGameObject::updateSyncedAnimation not implemented");
}

auto GJValueTween::step(float delta) -> decltype(step(delta)) {
	using FunctionType = decltype(step(delta))(*)(GJValueTween*, float);
	static auto func = wrapFunction(base::get() + 0x2000b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, delta);
}

auto GJGameState::processStateTriggers() -> decltype(processStateTriggers()) {
	using FunctionType = decltype(processStateTriggers())(*)(GJGameState*);
	static auto func = wrapFunction(base::get() + 0x200290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJGameState::stopTweenAction(int p0) -> decltype(stopTweenAction(p0)) {
	using FunctionType = decltype(stopTweenAction(p0))(*)(GJGameState*, int);
	static auto func = wrapFunction(base::get() + 0x2444e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJGameState::tweenValue(float p0, float p1, int p2, float p3, int p4, float p5, int p6, int p7) -> decltype(tweenValue(p0, p1, p2, p3, p4, p5, p6, p7)) {
	using FunctionType = decltype(tweenValue(p0, p1, p2, p3, p4, p5, p6, p7))(*)(GJGameState*, float, float, int, float, int, float, int, int);
	static auto func = wrapFunction(base::get() + 0x200140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7);
}

CheckpointObject::CheckpointObject() : CheckpointObject(geode::CutoffConstructor, sizeof(CheckpointObject)) {
	// here we construct it as normal as we can, then destruct it
	// using the generated functions. this ensures no memory gets leaked
	// no crashes :pray:
	CCDestructor::lock(this) = true;
	CheckpointObject::~CheckpointObject();
	using FunctionType = void(*)(CheckpointObject*);
	static auto func = wrapFunction(base::get() + 0x38e330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
}

CheckpointObject* CheckpointObject::create() {
        auto ret = new CheckpointObject();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto CheckpointObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CheckpointObject::init), this);
	using FunctionType = decltype(init())(*)(CheckpointObject*);
	static auto func = wrapFunction(base::get() + 0x77db0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CollisionBlockPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CollisionBlockPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(CollisionBlockPopup*);
	static auto func = wrapFunction(base::get() + 0x8bb20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CollisionBlockPopup::show() -> decltype(show()) {
	throw std::runtime_error("CollisionBlockPopup::show not implemented");
}

auto CollisionBlockPopup::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	throw std::runtime_error("CollisionBlockPopup::textInputClosed not implemented");
}

auto CollisionBlockPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&CollisionBlockPopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(CollisionBlockPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x8b7a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CollisionBlockPopup::textInputShouldOffset(CCTextInputNode* p0, float p1) -> decltype(textInputShouldOffset(p0, p1)) {
	throw std::runtime_error("CollisionBlockPopup::textInputShouldOffset not implemented");
}

auto CollisionBlockPopup::textInputReturn(CCTextInputNode* p0) -> decltype(textInputReturn(p0)) {
	throw std::runtime_error("CollisionBlockPopup::textInputReturn not implemented");
}

auto ColorAction::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x251b40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

void ColorAction::loadFromState(CAState& state) {
        m_fromColor = state.m_fromColor;
        m_toColor = state.m_toColor;
        m_color = state.m_color;
        m_property19 = state.m_property19;
        m_blending = state.m_blending;
        m_copyOpacity = state.m_copyOpacity;
        m_unknown = state.m_unknown;
        m_playerColor = state.m_playerColor;
        m_colorID = state.m_colorID;
        m_copyID = state.m_copyID;
        m_unknown2 = state.m_unknown2;
        m_duration = state.m_duration;
        m_fromOpacity = state.m_fromOpacity;
        m_toOpacity = state.m_toOpacity;
        m_deltaTime = state.m_deltaTime;
        m_copyHSV = state.m_copyHSV;
    }

void ColorAction::saveToState(CAState& state) {
        state.m_fromColor = m_fromColor;
        state.m_toColor = m_toColor;
        state.m_color = m_color;
        state.m_property19 = m_property19;
        state.m_blending = m_blending;
        state.m_copyOpacity = m_copyOpacity;
        state.m_unknown = m_unknown;
        state.m_playerColor = m_playerColor;
        state.m_colorID = m_colorID;
        state.m_copyID = m_copyID;
        state.m_unknown2 = m_unknown2;
        state.m_duration = m_duration;
        state.m_fromOpacity = m_fromOpacity;
        state.m_toOpacity = m_toOpacity;
        state.m_deltaTime = m_deltaTime;
        state.m_copyHSV = m_copyHSV;
    }

auto ColorAction::setupFromMap(gd::map<gd::string, gd::string>& p0) -> decltype(setupFromMap(p0)) {
	using FunctionType = decltype(setupFromMap(p0))(*)(ColorAction*, gd::map<gd::string, gd::string>&);
	static auto func = wrapFunction(base::get() + 0x252800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ColorAction::setupFromString(gd::string p0) -> decltype(setupFromString(p0)) {
	using FunctionType = decltype(setupFromString(p0))(*)(ColorAction*, gd::string);
	static auto func = wrapFunction(base::get() + 0x252720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ColorAction::step(float p0) -> decltype(step(p0)) {
	using FunctionType = decltype(step(p0))(*)(ColorAction*, float);
	static auto func = wrapFunction(base::get() + 0x251c30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ColorActionSprite::init() -> decltype(init()) {
	throw std::runtime_error("ColorActionSprite::init not implemented");
}

auto ColorChannelSprite::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x2515d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto ColorChannelSprite::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ColorChannelSprite::init), this);
	using FunctionType = decltype(init())(*)(ColorChannelSprite*);
	static auto func = wrapFunction(base::get() + 0x251690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ColorChannelSprite::updateBlending(bool enabled) -> decltype(updateBlending(enabled)) {
	using FunctionType = decltype(updateBlending(enabled))(*)(ColorChannelSprite*, bool);
	static auto func = wrapFunction(base::get() + 0x2519c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, enabled);
}

auto ColorChannelSprite::updateCopyLabel(int channelID, bool copyOpacity) -> decltype(updateCopyLabel(channelID, copyOpacity)) {
	using FunctionType = decltype(updateCopyLabel(channelID, copyOpacity))(*)(ColorChannelSprite*, int, bool);
	static auto func = wrapFunction(base::get() + 0x2516b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, channelID, copyOpacity);
}

auto ColorChannelSprite::updateOpacity(float alpha) -> decltype(updateOpacity(alpha)) {
	using FunctionType = decltype(updateOpacity(alpha))(*)(ColorChannelSprite*, float);
	static auto func = wrapFunction(base::get() + 0x251870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, alpha);
}

void ColorChannelSprite::updateValues(ColorAction* action) {
        if (!action) {
            this->setColor(cocos2d::ccWHITE);
            this->updateCopyLabel(0, false);
            this->updateOpacity(1.f);
            this->updateBlending(false);
            return;
        }
        this->updateCopyLabel(action->m_copyID, action->m_copyOpacity);
        this->updateOpacity(action->m_fromOpacity);
        this->updateBlending(action->m_blending);
        if (action->m_copyID != 0 && !action->m_copyOpacity) {
            this->setColor(cocos2d::ccGRAY);
        }
        else {
            this->setColor(action->m_fromColor);
        }
    }

auto ColorSelectDelegate::colorSelectClosed(cocos2d::CCNode* p0) -> decltype(colorSelectClosed(p0)) {
	throw std::runtime_error("ColorSelectDelegate::colorSelectClosed not implemented");
}

auto ColorSelectLiveOverlay::create(ColorAction* p0, ColorAction* p1, EffectGameObject* p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(ColorAction*, ColorAction*, EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x8bc50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto ColorSelectLiveOverlay::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ColorSelectLiveOverlay::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(ColorSelectLiveOverlay*);
	static auto func = wrapFunction(base::get() + 0x8d1b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ColorSelectLiveOverlay::show() -> decltype(show()) {
	throw std::runtime_error("ColorSelectLiveOverlay::show not implemented");
}

auto ColorSelectLiveOverlay::init(ColorAction* p0, ColorAction* p1, EffectGameObject* p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(ColorSelectLiveOverlay*, ColorAction*, ColorAction*, EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x8bda0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto ConfigureValuePopupDelegate::valuePopupClosed(ConfigureValuePopup* p0, float p1) -> decltype(valuePopupClosed(p0, p1)) {
	throw std::runtime_error("ConfigureValuePopupDelegate::valuePopupClosed not implemented");
}

void SliderDelegate::sliderBegan(Slider* p0) {}

void SliderDelegate::sliderEnded(Slider* p0) {}

auto SetupTriggerPopup::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&SetupTriggerPopup::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(SetupTriggerPopup*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x93d98, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupTriggerPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupTriggerPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SetupTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x44f1d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupTriggerPopup::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupTriggerPopup::show), this);
	using FunctionType = decltype(show())(*)(SetupTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x8ba30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void SetupTriggerPopup::pageChanged() {}

auto SetupTriggerPopup::toggleGroup(int group, bool visible) -> decltype(toggleGroup(group, visible)) {
	auto self = addresser::thunkAdjust(Resolve<int, bool>::func(&SetupTriggerPopup::toggleGroup), this);
	using FunctionType = decltype(toggleGroup(group, visible))(*)(SetupTriggerPopup*, int, bool);
	static auto func = wrapFunction(base::get() + 0x45c310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, group, visible);
}

auto SetupTriggerPopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupTriggerPopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x45d060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupTriggerPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupTriggerPopup::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(SetupTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x45d6a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupTriggerPopup::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	throw std::runtime_error("SetupTriggerPopup::textInputClosed not implemented");
}

auto SetupTriggerPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupTriggerPopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupTriggerPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x45d4e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupTriggerPopup::textInputShouldOffset(CCTextInputNode* p0, float p1) -> decltype(textInputShouldOffset(p0, p1)) {
	throw std::runtime_error("SetupTriggerPopup::textInputShouldOffset not implemented");
}

auto SetupTriggerPopup::textInputReturn(CCTextInputNode* p0) -> decltype(textInputReturn(p0)) {
	throw std::runtime_error("SetupTriggerPopup::textInputReturn not implemented");
}

void SetupTriggerPopup::updateInputValue(int p0, float& p1) {}

auto SetupTriggerPopup::sliderBegan(Slider* p0) -> decltype(sliderBegan(p0)) {
	auto self = addresser::thunkAdjust(Resolve<Slider*>::func(&SetupTriggerPopup::sliderBegan), this);
	using FunctionType = decltype(sliderBegan(p0))(*)(SetupTriggerPopup*, Slider*);
	static auto func = wrapFunction(base::get() + 0x45d7e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupTriggerPopup::sliderEnded(Slider* p0) -> decltype(sliderEnded(p0)) {
	auto self = addresser::thunkAdjust(Resolve<Slider*>::func(&SetupTriggerPopup::sliderEnded), this);
	using FunctionType = decltype(sliderEnded(p0))(*)(SetupTriggerPopup*, Slider*);
	static auto func = wrapFunction(base::get() + 0x45d8b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

void SetupTriggerPopup::onPlusButton(cocos2d::CCObject* sender) {}

void SetupTriggerPopup::onCustomButton(cocos2d::CCObject* sender) {}

auto SetupTriggerPopup::updateDefaultTriggerValues() -> decltype(updateDefaultTriggerValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupTriggerPopup::updateDefaultTriggerValues), this);
	using FunctionType = decltype(updateDefaultTriggerValues())(*)(SetupTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x45f370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupTriggerPopup::updateInputNode(int p0, float p1) -> decltype(updateInputNode(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupTriggerPopup::updateInputNode), this);
	using FunctionType = decltype(updateInputNode(p0, p1))(*)(SetupTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x45f860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupTriggerPopup::updateToggleItem(int p0, bool p1) -> decltype(updateToggleItem(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, bool>::func(&SetupTriggerPopup::updateToggleItem), this);
	using FunctionType = decltype(updateToggleItem(p0, p1))(*)(SetupTriggerPopup*, int, bool);
	static auto func = wrapFunction(base::get() + 0x45fc00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void SetupTriggerPopup::valueDidChange(int p0, float p1) {}

auto SetupTriggerPopup::getValue(int p0) -> decltype(getValue(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&SetupTriggerPopup::getValue), this);
	using FunctionType = decltype(getValue(p0))(*)(SetupTriggerPopup*, int);
	static auto func = wrapFunction(base::get() + 0x45fc70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupTriggerPopup::triggerValueFromSliderValue(int p0, float p1) -> decltype(triggerValueFromSliderValue(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupTriggerPopup::triggerValueFromSliderValue), this);
	using FunctionType = decltype(triggerValueFromSliderValue(p0, p1))(*)(SetupTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x463c60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupTriggerPopup::triggerSliderValueFromValue(int p0, float p1) -> decltype(triggerSliderValueFromValue(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupTriggerPopup::triggerSliderValueFromValue), this);
	using FunctionType = decltype(triggerSliderValueFromValue(p0, p1))(*)(SetupTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x463cf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void SetupTriggerPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) {}

auto SetupTriggerPopup::valuePopupClosed(ConfigureValuePopup* p0, float p1) -> decltype(valuePopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<ConfigureValuePopup*, float>::func(&SetupTriggerPopup::valuePopupClosed), this);
	using FunctionType = decltype(valuePopupClosed(p0, p1))(*)(SetupTriggerPopup*, ConfigureValuePopup*, float);
	static auto func = wrapFunction(base::get() + 0x464c00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupTriggerPopup::addCloseButton(gd::string p0) -> decltype(addCloseButton(p0)) {
	using FunctionType = decltype(addCloseButton(p0))(*)(SetupTriggerPopup*, gd::string);
	static auto func = wrapFunction(base::get() + 0x45c590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SetupTriggerPopup::addHelpButton(gd::string p0, gd::string p1, float p2) -> decltype(addHelpButton(p0, p1, p2)) {
	using FunctionType = decltype(addHelpButton(p0, p1, p2))(*)(SetupTriggerPopup*, gd::string, gd::string, float);
	static auto func = wrapFunction(base::get() + 0x45c6a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto SetupTriggerPopup::addInfoLabel(gd::string p0, float p1, cocos2d::CCPoint p2, int p3, int p4) -> decltype(addInfoLabel(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(addInfoLabel(p0, p1, p2, p3, p4))(*)(SetupTriggerPopup*, gd::string, float, cocos2d::CCPoint, int, int);
	static auto func = wrapFunction(base::get() + 0x45ee90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto SetupTriggerPopup::addObjectToPage(cocos2d::CCObject* p0, int p1) -> decltype(addObjectToPage(p0, p1)) {
	using FunctionType = decltype(addObjectToPage(p0, p1))(*)(SetupTriggerPopup*, cocos2d::CCObject*, int);
	static auto func = wrapFunction(base::get() + 0x45c400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupTriggerPopup::addTitle(gd::string p0) -> decltype(addTitle(p0)) {
	using FunctionType = decltype(addTitle(p0))(*)(SetupTriggerPopup*, gd::string);
	static auto func = wrapFunction(base::get() + 0x45c490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SetupTriggerPopup::createCustomButton(int p0, gd::string p1, gd::string p2, cocos2d::CCPoint p3, float p4, float p5, bool p6, int p7, int p8) -> decltype(createCustomButton(p0, p1, p2, p3, p4, p5, p6, p7, p8)) {
	using FunctionType = decltype(createCustomButton(p0, p1, p2, p3, p4, p5, p6, p7, p8))(*)(SetupTriggerPopup*, int, gd::string, gd::string, cocos2d::CCPoint, float, float, bool, int, int);
	static auto func = wrapFunction(base::get() + 0x45f110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7, p8);
}

auto SetupTriggerPopup::createCustomEasingControls(gd::string p0, cocos2d::CCPoint p1, float p2, int p3, int p4, int p5, int p6) -> decltype(createCustomEasingControls(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(createCustomEasingControls(p0, p1, p2, p3, p4, p5, p6))(*)(SetupTriggerPopup*, gd::string, cocos2d::CCPoint, float, int, int, int, int);
	static auto func = wrapFunction(base::get() + 0x464cc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6);
}

auto SetupTriggerPopup::createCustomToggleValueControl(int p0, bool p1, bool p2, gd::string p3, cocos2d::CCPoint p4, bool p5, int p6, int p7) -> decltype(createCustomToggleValueControl(p0, p1, p2, p3, p4, p5, p6, p7)) {
	using FunctionType = decltype(createCustomToggleValueControl(p0, p1, p2, p3, p4, p5, p6, p7))(*)(SetupTriggerPopup*, int, bool, bool, gd::string, cocos2d::CCPoint, bool, int, int);
	static auto func = wrapFunction(base::get() + 0x45ec10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7);
}

auto SetupTriggerPopup::createEasingControls(cocos2d::CCPoint p0, float p1, int p2, int p3) -> decltype(createEasingControls(p0, p1, p2, p3)) {
	using FunctionType = decltype(createEasingControls(p0, p1, p2, p3))(*)(SetupTriggerPopup*, cocos2d::CCPoint, float, int, int);
	static auto func = wrapFunction(base::get() + 0x463da0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto SetupTriggerPopup::createMultiTriggerItems(cocos2d::CCPoint touchPos, cocos2d::CCPoint spawnPos, cocos2d::CCPoint multiPos) -> decltype(createMultiTriggerItems(touchPos, spawnPos, multiPos)) {
	using FunctionType = decltype(createMultiTriggerItems(touchPos, spawnPos, multiPos))(*)(SetupTriggerPopup*, cocos2d::CCPoint, cocos2d::CCPoint, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x45cd50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, touchPos, spawnPos, multiPos);
}

auto SetupTriggerPopup::createMultiTriggerItemsCorner() -> decltype(createMultiTriggerItemsCorner()) {
	using FunctionType = decltype(createMultiTriggerItemsCorner())(*)(SetupTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x45ca40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SetupTriggerPopup::createMultiTriggerItemsDefault() -> decltype(createMultiTriggerItemsDefault()) {
	using FunctionType = decltype(createMultiTriggerItemsDefault())(*)(SetupTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x45c930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SetupTriggerPopup::createMultiTriggerItemsDefaultHorizontal() -> decltype(createMultiTriggerItemsDefaultHorizontal()) {
	using FunctionType = decltype(createMultiTriggerItemsDefaultHorizontal())(*)(SetupTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x45cc40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SetupTriggerPopup::createMultiTriggerItemsDefaultVertical() -> decltype(createMultiTriggerItemsDefaultVertical()) {
	using FunctionType = decltype(createMultiTriggerItemsDefaultVertical())(*)(SetupTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x45cb40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SetupTriggerPopup::createPageButtons(float p0, int p1) -> decltype(createPageButtons(p0, p1)) {
	using FunctionType = decltype(createPageButtons(p0, p1))(*)(SetupTriggerPopup*, float, int);
	static auto func = wrapFunction(base::get() + 0x45bc80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupTriggerPopup::createPlusButton(int p0, cocos2d::CCPoint p1, float p2, gd::string p3, int p4, int p5) -> decltype(createPlusButton(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(createPlusButton(p0, p1, p2, p3, p4, p5))(*)(SetupTriggerPopup*, int, cocos2d::CCPoint, float, gd::string, int, int);
	static auto func = wrapFunction(base::get() + 0x45ef70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto SetupTriggerPopup::createToggleButton(gd::string p0, cocos2d::SEL_MenuHandler p1, bool p2, cocos2d::CCPoint p3) -> decltype(createToggleButton(p0, p1, p2, p3)) {
	using FunctionType = decltype(createToggleButton(p0, p1, p2, p3))(*)(SetupTriggerPopup*, gd::string, cocos2d::SEL_MenuHandler, bool, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x45c800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto SetupTriggerPopup::createToggleValueControl(int p0, gd::string p1, cocos2d::CCPoint p2, bool p3, int p4, int p5, float p6) -> decltype(createToggleValueControl(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(createToggleValueControl(p0, p1, p2, p3, p4, p5, p6))(*)(SetupTriggerPopup*, int, gd::string, cocos2d::CCPoint, bool, int, int, float);
	static auto func = wrapFunction(base::get() + 0x45e900, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6);
}

auto SetupTriggerPopup::createValueControl(int p0, gd::string p1, cocos2d::CCPoint p2, float p3, float p4, float p5) -> decltype(createValueControl(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(createValueControl(p0, p1, p2, p3, p4, p5))(*)(SetupTriggerPopup*, int, gd::string, cocos2d::CCPoint, float, float, float);
	static auto func = wrapFunction(base::get() + 0x45db40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto SetupTriggerPopup::createValueControlAdvanced(int p0, gd::string p1, cocos2d::CCPoint p2, float p3, bool p4, InputValueType p5, int p6, bool p7, float p8, float p9, int p10, int p11, GJInputStyle p12, int p13, bool p14) -> decltype(createValueControlAdvanced(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14)) {
	using FunctionType = decltype(createValueControlAdvanced(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14))(*)(SetupTriggerPopup*, int, gd::string, cocos2d::CCPoint, float, bool, InputValueType, int, bool, float, float, int, int, GJInputStyle, int, bool);
	static auto func = wrapFunction(base::get() + 0x45dc30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14);
}

auto SetupTriggerPopup::getTriggerValue(int property, GameObject* object) -> decltype(getTriggerValue(property, object)) {
	using FunctionType = decltype(getTriggerValue(property, object))(*)(SetupTriggerPopup*, int, GameObject*);
	static auto func = wrapFunction(base::get() + 0x4620f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, property, object);
}

auto SetupTriggerPopup::getTruncatedValue(float p0, int p1) -> decltype(getTruncatedValue(p0, p1)) {
	using FunctionType = decltype(getTruncatedValue(p0, p1))(*)(SetupTriggerPopup*, float, int);
	static auto func = wrapFunction(base::get() + 0x45f750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupTriggerPopup::goToPage(int p0, bool p1) -> decltype(goToPage(p0, p1)) {
	using FunctionType = decltype(goToPage(p0, p1))(*)(SetupTriggerPopup*, int, bool);
	static auto func = wrapFunction(base::get() + 0x45c010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupTriggerPopup::init(EffectGameObject* trigger, cocos2d::CCArray* triggers, float width, float height, int unkEnum) -> decltype(init(trigger, triggers, width, height, unkEnum)) {
	using FunctionType = decltype(init(trigger, triggers, width, height, unkEnum))(*)(SetupTriggerPopup*, EffectGameObject*, cocos2d::CCArray*, float, float, int);
	static auto func = wrapFunction(base::get() + 0x45b900, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, trigger, triggers, width, height, unkEnum);
}

auto SetupTriggerPopup::onCustomEaseArrow(int p0, bool p1) -> decltype(onCustomEaseArrow(p0, p1)) {
	using FunctionType = decltype(onCustomEaseArrow(p0, p1))(*)(SetupTriggerPopup*, int, bool);
	static auto func = wrapFunction(base::get() + 0x465590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupTriggerPopup::onCustomEaseArrowDown(cocos2d::CCObject* sender) -> decltype(onCustomEaseArrowDown(sender)) {
	using FunctionType = decltype(onCustomEaseArrowDown(sender))(*)(SetupTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x465560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupTriggerPopup::onCustomEaseArrowUp(cocos2d::CCObject* sender) -> decltype(onCustomEaseArrowUp(sender)) {
	using FunctionType = decltype(onCustomEaseArrowUp(sender))(*)(SetupTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x465530, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupTriggerPopup::onCustomEaseRate(cocos2d::CCObject* sender) -> decltype(onCustomEaseRate(sender)) {
	using FunctionType = decltype(onCustomEaseRate(sender))(*)(SetupTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x465420, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupTriggerPopup::onDisableValue(cocos2d::CCObject* sender) -> decltype(onDisableValue(sender)) {
	using FunctionType = decltype(onDisableValue(sender))(*)(SetupTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x45e7f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupTriggerPopup::onEase(cocos2d::CCObject* sender) -> decltype(onEase(sender)) {
	using FunctionType = decltype(onEase(sender))(*)(SetupTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x464ac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupTriggerPopup::onEaseRate(cocos2d::CCObject* sender) -> decltype(onEaseRate(sender)) {
	using FunctionType = decltype(onEaseRate(sender))(*)(SetupTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x464b30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupTriggerPopup::onPage(cocos2d::CCObject* sender) -> decltype(onPage(sender)) {
	using FunctionType = decltype(onPage(sender))(*)(SetupTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x45bf30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupTriggerPopup::onSpawnedByTrigger(cocos2d::CCObject* sender) -> decltype(onSpawnedByTrigger(sender)) {
	using FunctionType = decltype(onSpawnedByTrigger(sender))(*)(SetupTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x45d2d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupTriggerPopup::onToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onToggleTriggerValue(sender)) {
	using FunctionType = decltype(onToggleTriggerValue(sender))(*)(SetupTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x45f6c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupTriggerPopup::onTouchTriggered(cocos2d::CCObject* sender) -> decltype(onTouchTriggered(sender)) {
	using FunctionType = decltype(onTouchTriggered(sender))(*)(SetupTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x45d1e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

void SetupTriggerPopup::postSetup() {
        this->updateDefaultTriggerValues();
        m_disableTextDelegate = false;
    }

void SetupTriggerPopup::preSetup() {
        m_disableTextDelegate = true;
        this->determineStartValues();
    }

auto SetupTriggerPopup::toggleCustomEaseRateVisibility(int p0, int p1) -> decltype(toggleCustomEaseRateVisibility(p0, p1)) {
	using FunctionType = decltype(toggleCustomEaseRateVisibility(p0, p1))(*)(SetupTriggerPopup*, int, int);
	static auto func = wrapFunction(base::get() + 0x465910, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupTriggerPopup::toggleDisableButtons(bool p0) -> decltype(toggleDisableButtons(p0)) {
	using FunctionType = decltype(toggleDisableButtons(p0))(*)(SetupTriggerPopup*, bool);
	static auto func = wrapFunction(base::get() + 0x45e820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SetupTriggerPopup::triggerArrowChanged(int p0, bool p1) -> decltype(triggerArrowChanged(p0, p1)) {
	using FunctionType = decltype(triggerArrowChanged(p0, p1))(*)(SetupTriggerPopup*, int, bool);
	static auto func = wrapFunction(base::get() + 0x45daa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupTriggerPopup::triggerArrowLeft(cocos2d::CCObject* p0) -> decltype(triggerArrowLeft(p0)) {
	using FunctionType = decltype(triggerArrowLeft(p0))(*)(SetupTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x45da40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SetupTriggerPopup::triggerArrowRight(cocos2d::CCObject* p0) -> decltype(triggerArrowRight(p0)) {
	using FunctionType = decltype(triggerArrowRight(p0))(*)(SetupTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x45da70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SetupTriggerPopup::triggerSliderChanged(cocos2d::CCObject* p0) -> decltype(triggerSliderChanged(p0)) {
	using FunctionType = decltype(triggerSliderChanged(p0))(*)(SetupTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x45d980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SetupTriggerPopup::updateCustomEaseLabel(int p0, int p1) -> decltype(updateCustomEaseLabel(p0, p1)) {
	using FunctionType = decltype(updateCustomEaseLabel(p0, p1))(*)(SetupTriggerPopup*, int, int);
	static auto func = wrapFunction(base::get() + 0x465630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupTriggerPopup::updateCustomEaseRateLabel(int p0, float p1) -> decltype(updateCustomEaseRateLabel(p0, p1)) {
	using FunctionType = decltype(updateCustomEaseRateLabel(p0, p1))(*)(SetupTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x465800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupTriggerPopup::updateInputNodeLabel(int p0, gd::string p1) -> decltype(updateInputNodeLabel(p0, p1)) {
	using FunctionType = decltype(updateInputNodeLabel(p0, p1))(*)(SetupTriggerPopup*, int, gd::string);
	static auto func = wrapFunction(base::get() + 0x463be0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupTriggerPopup::updateMultiTriggerBtn() -> decltype(updateMultiTriggerBtn()) {
	using FunctionType = decltype(updateMultiTriggerBtn())(*)(SetupTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x45d3c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SetupTriggerPopup::updateSpawnedByTrigger() -> decltype(updateSpawnedByTrigger()) {
	using FunctionType = decltype(updateSpawnedByTrigger())(*)(SetupTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x45d320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SetupTriggerPopup::updateTouchTriggered() -> decltype(updateTouchTriggered()) {
	using FunctionType = decltype(updateTouchTriggered())(*)(SetupTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x45d230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SetupTriggerPopup::updateValue(int property, float value) -> decltype(updateValue(property, value)) {
	using FunctionType = decltype(updateValue(property, value))(*)(SetupTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x463b50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, property, value);
}

auto SetupTriggerPopup::updateValueControls(int property, float value) -> decltype(updateValueControls(property, value)) {
	using FunctionType = decltype(updateValueControls(property, value))(*)(SetupTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x45f7c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, property, value);
}

auto SetupTriggerPopup::valueChanged(int property, float value) -> decltype(valueChanged(property, value)) {
	using FunctionType = decltype(valueChanged(property, value))(*)(SetupTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x45fd90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, property, value);
}

auto GJSpecialColorSelectDelegate::colorSelectClosed(GJSpecialColorSelect* p0, int p1) -> decltype(colorSelectClosed(p0, p1)) {
	throw std::runtime_error("GJSpecialColorSelectDelegate::colorSelectClosed not implemented");
}

auto ColorSelectPopup::colorToHex(cocos2d::ccColor3B p0) -> decltype(colorToHex(p0)) {
	using FunctionType = decltype(colorToHex(p0))(*)(cocos2d::ccColor3B);
	static auto func = wrapFunction(base::get() + 0x926d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto ColorSelectPopup::create(EffectGameObject* effect, cocos2d::CCArray* array, ColorAction* action) -> decltype(create(effect, array, action)) {
	using FunctionType = decltype(create(effect, array, action))(*)(EffectGameObject*, cocos2d::CCArray*, ColorAction*);
	static auto func = wrapFunction(base::get() + 0x8da30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(effect, array, action);
}

ColorSelectPopup* ColorSelectPopup::create(cocos2d::ccColor3B color) {
        auto action = ColorAction::create();
        action->m_color = color;
        return ColorSelectPopup::create(action);
    }

ColorSelectPopup* ColorSelectPopup::create(ColorAction* action) {
        return ColorSelectPopup::create(nullptr, nullptr, action);
    }

ColorSelectPopup* ColorSelectPopup::create(EffectGameObject* effect, cocos2d::CCArray* array) {
        return ColorSelectPopup::create(effect, array, nullptr);
    }

auto ColorSelectPopup::hexToColor(gd::string p0) -> decltype(hexToColor(p0)) {
	using FunctionType = decltype(hexToColor(p0))(*)(gd::string);
	static auto func = wrapFunction(base::get() + 0x91a60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto ColorSelectPopup::show() -> decltype(show()) {
	throw std::runtime_error("ColorSelectPopup::show not implemented");
}

auto ColorSelectPopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ColorSelectPopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(ColorSelectPopup*);
	static auto func = wrapFunction(base::get() + 0x90390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ColorSelectPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&ColorSelectPopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(ColorSelectPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x92cd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ColorSelectPopup::colorValueChanged(cocos2d::ccColor3B p0) -> decltype(colorValueChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B>::func(&ColorSelectPopup::colorValueChanged), this);
	using FunctionType = decltype(colorValueChanged(p0))(*)(ColorSelectPopup*, cocos2d::ccColor3B);
	static auto func = wrapFunction(base::get() + 0x91750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ColorSelectPopup::colorSelectClosed(GJSpecialColorSelect* p0, int p1) -> decltype(colorSelectClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<GJSpecialColorSelect*, int>::func(&ColorSelectPopup::colorSelectClosed), this);
	using FunctionType = decltype(colorSelectClosed(p0, p1))(*)(ColorSelectPopup*, GJSpecialColorSelect*, int);
	static auto func = wrapFunction(base::get() + 0x93690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ColorSelectPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("ColorSelectPopup::keyBackClicked not implemented");
}

auto ColorSelectPopup::closeColorSelect(cocos2d::CCObject* p0) -> decltype(closeColorSelect(p0)) {
	using FunctionType = decltype(closeColorSelect(p0))(*)(ColorSelectPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x914a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ColorSelectPopup::init(EffectGameObject* p0, cocos2d::CCArray* p1, ColorAction* p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(ColorSelectPopup*, EffectGameObject*, cocos2d::CCArray*, ColorAction*);
	static auto func = wrapFunction(base::get() + 0x8dc20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto ColorSelectPopup::onCopy(cocos2d::CCObject* sender) -> decltype(onCopy(sender)) {
	using FunctionType = decltype(onCopy(sender))(*)(ColorSelectPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x90d60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ColorSelectPopup::onCopyOpacity(cocos2d::CCObject* sender) -> decltype(onCopyOpacity(sender)) {
	using FunctionType = decltype(onCopyOpacity(sender))(*)(ColorSelectPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x90b00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ColorSelectPopup::onDefault(cocos2d::CCObject* sender) -> decltype(onDefault(sender)) {
	using FunctionType = decltype(onDefault(sender))(*)(ColorSelectPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x90e60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ColorSelectPopup::onPaste(cocos2d::CCObject* sender) -> decltype(onPaste(sender)) {
	using FunctionType = decltype(onPaste(sender))(*)(ColorSelectPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x90de0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ColorSelectPopup::onToggleHSVMode(cocos2d::CCObject* sender) -> decltype(onToggleHSVMode(sender)) {
	using FunctionType = decltype(onToggleHSVMode(sender))(*)(ColorSelectPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x93500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ColorSelectPopup::onToggleTintMode(cocos2d::CCObject* sender) -> decltype(onToggleTintMode(sender)) {
	using FunctionType = decltype(onToggleTintMode(sender))(*)(ColorSelectPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x909b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ColorSelectPopup::onUpdateCopyColor(cocos2d::CCObject* sender) -> decltype(onUpdateCopyColor(sender)) {
	using FunctionType = decltype(onUpdateCopyColor(sender))(*)(ColorSelectPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x93420, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ColorSelectPopup::onUpdateCustomColor(cocos2d::CCObject* sender) -> decltype(onUpdateCustomColor(sender)) {
	using FunctionType = decltype(onUpdateCustomColor(sender))(*)(ColorSelectPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x92c50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ColorSelectPopup::updateCopyColor() -> decltype(updateCopyColor()) {
	using FunctionType = decltype(updateCopyColor())(*)(ColorSelectPopup*);
	static auto func = wrapFunction(base::get() + 0x93830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ColorSelectPopup::updateCustomColorIdx() -> decltype(updateCustomColorIdx()) {
	using FunctionType = decltype(updateCustomColorIdx())(*)(ColorSelectPopup*);
	static auto func = wrapFunction(base::get() + 0x93270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ColorSelectPopup::updateHSVMode() -> decltype(updateHSVMode()) {
	using FunctionType = decltype(updateHSVMode())(*)(ColorSelectPopup*);
	static auto func = wrapFunction(base::get() + 0x93540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ColorSelectPopup::updateOpacity() -> decltype(updateOpacity()) {
	using FunctionType = decltype(updateOpacity())(*)(ColorSelectPopup*);
	static auto func = wrapFunction(base::get() + 0x912b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ColorSelectPopup::updateOpacityLabel() -> decltype(updateOpacityLabel()) {
	using FunctionType = decltype(updateOpacityLabel())(*)(ColorSelectPopup*);
	static auto func = wrapFunction(base::get() + 0x91430, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ColorSetupDelegate::colorSetupClosed(int p0) -> decltype(colorSetupClosed(p0)) {
	throw std::runtime_error("ColorSetupDelegate::colorSetupClosed not implemented");
}

void LikeItemDelegate::likedItem(LikeItemType p0, int p1, bool p2) {}

auto CommentCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CommentCell::init), this);
	using FunctionType = decltype(init())(*)(CommentCell*);
	static auto func = wrapFunction(base::get() + 0xb5460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CommentCell::draw() -> decltype(draw()) {
	throw std::runtime_error("CommentCell::draw not implemented");
}

auto CommentCell::likedItem(LikeItemType p0, int p1, bool p2) -> decltype(likedItem(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<LikeItemType, int, bool>::func(&CommentCell::likedItem), this);
	using FunctionType = decltype(likedItem(p0, p1, p2))(*)(CommentCell*, LikeItemType, int, bool);
	static auto func = wrapFunction(base::get() + 0xb7750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto CommentCell::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&CommentCell::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(CommentCell*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0xb79c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CommentCell::loadFromComment(GJComment* p0) -> decltype(loadFromComment(p0)) {
	using FunctionType = decltype(loadFromComment(p0))(*)(CommentCell*, GJComment*);
	static auto func = wrapFunction(base::get() + 0xb5480, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CommentCell::onConfirmDelete(cocos2d::CCObject* sender) -> decltype(onConfirmDelete(sender)) {
	using FunctionType = decltype(onConfirmDelete(sender))(*)(CommentCell*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xb7850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CommentCell::onGoToLevel(cocos2d::CCObject* sender) -> decltype(onGoToLevel(sender)) {
	using FunctionType = decltype(onGoToLevel(sender))(*)(CommentCell*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xb7b20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CommentCell::onLike(cocos2d::CCObject* sender) -> decltype(onLike(sender)) {
	using FunctionType = decltype(onLike(sender))(*)(CommentCell*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xb75f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CommentCell::onUnhide(cocos2d::CCObject* sender) -> decltype(onUnhide(sender)) {
	using FunctionType = decltype(onUnhide(sender))(*)(CommentCell*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xb7b00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CommentUploadDelegate::commentUploadFinished(int p0) -> decltype(commentUploadFinished(p0)) {
	throw std::runtime_error("CommentUploadDelegate::commentUploadFinished not implemented");
}

auto CommentUploadDelegate::commentUploadFailed(int p0, CommentError p1) -> decltype(commentUploadFailed(p0, p1)) {
	throw std::runtime_error("CommentUploadDelegate::commentUploadFailed not implemented");
}

void CommentUploadDelegate::commentDeleteFailed(int p0, int p1) {}

auto CommunityCreditNode::create(int p0, int p1, int p2, gd::string p3) -> decltype(create(p0, p1, p2, p3)) {
	using FunctionType = decltype(create(p0, p1, p2, p3))(*)(int, int, int, gd::string);
	static auto func = wrapFunction(base::get() + 0x93ec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3);
}

bool CommunityCreditNode::init(int unlockType, int iconID, int unknown, gd::string author) {
        if (!CCNode::init()) return false;
        m_unlockType = unlockType;
        m_iconID = iconID;
        m_unknown = unknown;
        m_author = author;
        return true;
    }

CommunityCreditsPage::CommunityCreditsPage() {
        m_pageObjects = nullptr;
        m_prevButton = nullptr;
        m_nextButton = nullptr;
        m_page = -1;
    }

CommunityCreditsPage* CommunityCreditsPage::create() {
        auto ret = new CommunityCreditsPage();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto CommunityCreditsPage::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CommunityCreditsPage::init), this);
	using FunctionType = decltype(init())(*)(CommunityCreditsPage*);
	static auto func = wrapFunction(base::get() + 0x94000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CommunityCreditsPage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("CommunityCreditsPage::registerWithTouchDispatcher not implemented");
}

auto CommunityCreditsPage::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("CommunityCreditsPage::keyBackClicked not implemented");
}

auto CommunityCreditsPage::show() -> decltype(show()) {
	throw std::runtime_error("CommunityCreditsPage::show not implemented");
}

auto CommunityCreditsPage::goToPage(int p0) -> decltype(goToPage(p0)) {
	using FunctionType = decltype(goToPage(p0))(*)(CommunityCreditsPage*, int);
	static auto func = wrapFunction(base::get() + 0x96040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ConfigureHSVWidget::create(cocos2d::ccHSVValue p0, bool p1, bool p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(cocos2d::ccHSVValue, bool, bool);
	static auto func = wrapFunction(base::get() + 0x96950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto ConfigureHSVWidget::getHSV(GameObject* p0, cocos2d::CCArray* p1, int p2) -> decltype(getHSV(p0, p1, p2)) {
	using FunctionType = decltype(getHSV(p0, p1, p2))(*)(GameObject*, cocos2d::CCArray*, int);
	static auto func = wrapFunction(base::get() + 0x980a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

void ConfigureHSVWidget::textInputOpened(CCTextInputNode* p0) {}

auto ConfigureHSVWidget::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&ConfigureHSVWidget::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(ConfigureHSVWidget*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x8b790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ConfigureHSVWidget::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&ConfigureHSVWidget::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(ConfigureHSVWidget*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x97560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ConfigureHSVWidget::createTextInputNode(cocos2d::CCPoint p0, int p1) -> decltype(createTextInputNode(p0, p1)) {
	using FunctionType = decltype(createTextInputNode(p0, p1))(*)(ConfigureHSVWidget*, cocos2d::CCPoint, int);
	static auto func = wrapFunction(base::get() + 0x97300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto ConfigureHSVWidget::init(cocos2d::ccHSVValue p0, bool p1, bool p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(ConfigureHSVWidget*, cocos2d::ccHSVValue, bool, bool);
	static auto func = wrapFunction(base::get() + 0x96a20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto ConfigureHSVWidget::onResetHSV(cocos2d::CCObject* sender) -> decltype(onResetHSV(sender)) {
	using FunctionType = decltype(onResetHSV(sender))(*)(ConfigureHSVWidget*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x97b10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ConfigureHSVWidget::updateLabels() -> decltype(updateLabels()) {
	using FunctionType = decltype(updateLabels())(*)(ConfigureHSVWidget*);
	static auto func = wrapFunction(base::get() + 0x97b90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ConfigureHSVWidget::updateSliders() -> decltype(updateSliders()) {
	using FunctionType = decltype(updateSliders())(*)(ConfigureHSVWidget*);
	static auto func = wrapFunction(base::get() + 0x97820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ConfigureValuePopup::create(ConfigureValuePopupDelegate* p0, float p1, float p2, float p3, gd::string p4, gd::string p5) -> decltype(create(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5))(*)(ConfigureValuePopupDelegate*, float, float, float, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x983a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5);
}

auto ConfigureValuePopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ConfigureValuePopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(ConfigureValuePopup*);
	static auto func = wrapFunction(base::get() + 0x98fb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ConfigureValuePopup::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	throw std::runtime_error("ConfigureValuePopup::textInputClosed not implemented");
}

auto ConfigureValuePopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&ConfigureValuePopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(ConfigureValuePopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x98de0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ConfigureValuePopup::init(ConfigureValuePopupDelegate* p0, float p1, float p2, float p3, gd::string p4, gd::string p5) -> decltype(init(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5))(*)(ConfigureValuePopup*, ConfigureValuePopupDelegate*, float, float, float, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x98550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto ConfigureValuePopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(ConfigureValuePopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x98f30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ConfigureValuePopup::sliderChanged(cocos2d::CCObject* sender) -> decltype(sliderChanged(sender)) {
	using FunctionType = decltype(sliderChanged(sender))(*)(ConfigureValuePopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x98d00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ConfigureValuePopup::updateTextInputLabel() -> decltype(updateTextInputLabel()) {
	using FunctionType = decltype(updateTextInputLabel())(*)(ConfigureValuePopup*);
	static auto func = wrapFunction(base::get() + 0x98d50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CountTriggerGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*, int, gd::vector<int> const*>::func(&CountTriggerGameObject::triggerObject), this);
	using FunctionType = decltype(triggerObject(p0, p1, p2))(*)(CountTriggerGameObject*, GJBaseGameLayer*, int, gd::vector<int> const*);
	static auto func = wrapFunction(base::get() + 0x4a26c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto CountTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("CountTriggerGameObject::customObjectSetup not implemented");
}

auto CountTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("CountTriggerGameObject::getSaveString not implemented");
}

auto CreateGuidelinesLayer::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CreateGuidelinesLayer::update), this);
	using FunctionType = decltype(update(p0))(*)(CreateGuidelinesLayer*, float);
	static auto func = wrapFunction(base::get() + 0x9adf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CreateGuidelinesLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CreateGuidelinesLayer::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(CreateGuidelinesLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x9b0c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void CreateGuidelinesLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

auto CreateGuidelinesLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CreateGuidelinesLayer::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(CreateGuidelinesLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x9b140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CreateGuidelinesLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	throw std::runtime_error("CreateGuidelinesLayer::ccTouchCancelled not implemented");
}

auto CreateGuidelinesLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("CreateGuidelinesLayer::registerWithTouchDispatcher not implemented");
}

auto CreateGuidelinesLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CreateGuidelinesLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(CreateGuidelinesLayer*);
	static auto func = wrapFunction(base::get() + 0x9b040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CreateGuidelinesLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&CreateGuidelinesLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(CreateGuidelinesLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x9b1f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CreateGuidelinesLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&CreateGuidelinesLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(CreateGuidelinesLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x9af60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CreateGuidelinesLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&CreateGuidelinesLayer::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(CreateGuidelinesLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x84620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

void CreateGuidelinesLayer::keyUp(cocos2d::enumKeyCodes p0) {}

auto CreateGuidelinesLayer::playMusic() -> decltype(playMusic()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CreateGuidelinesLayer::playMusic), this);
	using FunctionType = decltype(playMusic())(*)(CreateGuidelinesLayer*);
	static auto func = wrapFunction(base::get() + 0x9a6a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CreateGuidelinesLayer::registerTouch() -> decltype(registerTouch()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CreateGuidelinesLayer::registerTouch), this);
	using FunctionType = decltype(registerTouch())(*)(CreateGuidelinesLayer*);
	static auto func = wrapFunction(base::get() + 0x9b060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CreateGuidelinesLayer::onInfo(cocos2d::CCObject* sender) -> decltype(onInfo(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&CreateGuidelinesLayer::onInfo), this);
	using FunctionType = decltype(onInfo(sender))(*)(CreateGuidelinesLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x9ae10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto CreateGuidelinesLayer::onRecord(cocos2d::CCObject* sender) -> decltype(onRecord(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&CreateGuidelinesLayer::onRecord), this);
	using FunctionType = decltype(onRecord(sender))(*)(CreateGuidelinesLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x9a510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto CreateGuidelinesLayer::recordingDidStop() -> decltype(recordingDidStop()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CreateGuidelinesLayer::recordingDidStop), this);
	using FunctionType = decltype(recordingDidStop())(*)(CreateGuidelinesLayer*);
	static auto func = wrapFunction(base::get() + 0x9a800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CreateMenuItem::create(cocos2d::CCNode* p0, cocos2d::CCNode* p1, cocos2d::CCObject* p2, cocos2d::SEL_MenuHandler p3) -> decltype(create(p0, p1, p2, p3)) {
	using FunctionType = decltype(create(p0, p1, p2, p3))(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
	static auto func = wrapFunction(base::get() + 0x127700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3);
}

auto CreateParticlePopup::create(ParticleGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(ParticleGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x414180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto CreateParticlePopup::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("CreateParticlePopup::update not implemented");
}

auto CreateParticlePopup::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CreateParticlePopup::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(CreateParticlePopup*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x41d070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CreateParticlePopup::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CreateParticlePopup::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(CreateParticlePopup*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x41d170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CreateParticlePopup::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CreateParticlePopup::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(CreateParticlePopup*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x41d5a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CreateParticlePopup::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	throw std::runtime_error("CreateParticlePopup::ccTouchCancelled not implemented");
}

auto CreateParticlePopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CreateParticlePopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(CreateParticlePopup*);
	static auto func = wrapFunction(base::get() + 0x41d060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CreateParticlePopup::sliderBegan(Slider* p0) -> decltype(sliderBegan(p0)) {
	auto self = addresser::thunkAdjust(Resolve<Slider*>::func(&CreateParticlePopup::sliderBegan), this);
	using FunctionType = decltype(sliderBegan(p0))(*)(CreateParticlePopup*, Slider*);
	static auto func = wrapFunction(base::get() + 0x41c7a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CreateParticlePopup::sliderEnded(Slider* p0) -> decltype(sliderEnded(p0)) {
	auto self = addresser::thunkAdjust(Resolve<Slider*>::func(&CreateParticlePopup::sliderEnded), this);
	using FunctionType = decltype(sliderEnded(p0))(*)(CreateParticlePopup*, Slider*);
	static auto func = wrapFunction(base::get() + 0x41c860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CreateParticlePopup::colorSelectClosed(cocos2d::CCNode* p0) -> decltype(colorSelectClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*>::func(&CreateParticlePopup::colorSelectClosed), this);
	using FunctionType = decltype(colorSelectClosed(p0))(*)(CreateParticlePopup*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x419e10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CreateParticlePopup::textInputShouldOffset(CCTextInputNode* p0, float p1) -> decltype(textInputShouldOffset(p0, p1)) {
	throw std::runtime_error("CreateParticlePopup::textInputShouldOffset not implemented");
}

auto CreateParticlePopup::textInputReturn(CCTextInputNode* p0) -> decltype(textInputReturn(p0)) {
	throw std::runtime_error("CreateParticlePopup::textInputReturn not implemented");
}

auto CreateParticlePopup::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	throw std::runtime_error("CreateParticlePopup::textInputClosed not implemented");
}

auto CreateParticlePopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&CreateParticlePopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(CreateParticlePopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x41a6b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CreateParticlePopup::init(ParticleGameObject* p0, cocos2d::CCArray* p1, gd::string p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(CreateParticlePopup*, ParticleGameObject*, cocos2d::CCArray*, gd::string);
	static auto func = wrapFunction(base::get() + 0x414370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto CreateParticlePopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(CreateParticlePopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x41cf20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

void DialogDelegate::dialogClosed(DialogLayer* p0) {}

CreatorLayer::CreatorLayer() {
        m_secretDoorSprite = nullptr;
        m_questsSprite = nullptr;
        m_vaultDialogIndex = -1;
        m_versusDialogIndex = 0;
    }

CreatorLayer* CreatorLayer::create() {
        auto ret = new CreatorLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto CreatorLayer::scene() -> decltype(scene()) {
	using FunctionType = decltype(scene())(*)();
	static auto func = wrapFunction(base::get() + 0x9b9a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto CreatorLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CreatorLayer::init), this);
	using FunctionType = decltype(init())(*)(CreatorLayer*);
	static auto func = wrapFunction(base::get() + 0x9bb10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CreatorLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CreatorLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(CreatorLayer*);
	static auto func = wrapFunction(base::get() + 0x9f2b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CreatorLayer::sceneWillResume() -> decltype(sceneWillResume()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CreatorLayer::sceneWillResume), this);
	using FunctionType = decltype(sceneWillResume())(*)(CreatorLayer*);
	static auto func = wrapFunction(base::get() + 0x9f1f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CreatorLayer::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DialogLayer*>::func(&CreatorLayer::dialogClosed), this);
	using FunctionType = decltype(dialogClosed(p0))(*)(CreatorLayer*, DialogLayer*);
	static auto func = wrapFunction(base::get() + 0x9f0d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CreatorLayer::onAdventureMap(cocos2d::CCObject* sender) -> decltype(onAdventureMap(sender)) {
	using FunctionType = decltype(onAdventureMap(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x9dbe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	using FunctionType = decltype(onBack(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x9f190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onChallenge(cocos2d::CCObject* sender) -> decltype(onChallenge(sender)) {
	using FunctionType = decltype(onChallenge(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x9ddb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onDailyLevel(cocos2d::CCObject* sender) -> decltype(onDailyLevel(sender)) {
	using FunctionType = decltype(onDailyLevel(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x9dd50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onEventLevel(cocos2d::CCObject* sender) -> decltype(onEventLevel(sender)) {
	using FunctionType = decltype(onEventLevel(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x9dd90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onFeaturedLevels(cocos2d::CCObject* sender) -> decltype(onFeaturedLevels(sender)) {
	using FunctionType = decltype(onFeaturedLevels(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x9d2a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onGauntlets(cocos2d::CCObject* sender) -> decltype(onGauntlets(sender)) {
	using FunctionType = decltype(onGauntlets(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x9d590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onLeaderboards(cocos2d::CCObject* sender) -> decltype(onLeaderboards(sender)) {
	using FunctionType = decltype(onLeaderboards(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x9d0f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onMapPacks(cocos2d::CCObject* sender) -> decltype(onMapPacks(sender)) {
	using FunctionType = decltype(onMapPacks(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x9d4d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onMultiplayer(cocos2d::CCObject* sender) -> decltype(onMultiplayer(sender)) {
	using FunctionType = decltype(onMultiplayer(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x9d610, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onMyLevels(cocos2d::CCObject* sender) -> decltype(onMyLevels(sender)) {
	using FunctionType = decltype(onMyLevels(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x9cce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onOnlineLevels(cocos2d::CCObject* sender) -> decltype(onOnlineLevels(sender)) {
	using FunctionType = decltype(onOnlineLevels(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x9d450, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onPaths(cocos2d::CCObject* sender) -> decltype(onPaths(sender)) {
	using FunctionType = decltype(onPaths(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x9d360, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onSavedLevels(cocos2d::CCObject* sender) -> decltype(onSavedLevels(sender)) {
	using FunctionType = decltype(onSavedLevels(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x9cef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onSecretVault(cocos2d::CCObject* sender) -> decltype(onSecretVault(sender)) {
	using FunctionType = decltype(onSecretVault(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x9df20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onTopLists(cocos2d::CCObject* sender) -> decltype(onTopLists(sender)) {
	using FunctionType = decltype(onTopLists(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x9d380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onTreasureRoom(cocos2d::CCObject* sender) -> decltype(onTreasureRoom(sender)) {
	using FunctionType = decltype(onTreasureRoom(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x9e730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onWeeklyLevel(cocos2d::CCObject* sender) -> decltype(onWeeklyLevel(sender)) {
	using FunctionType = decltype(onWeeklyLevel(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x9dd70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CurrencyRewardLayer::create(int orbs, int stars, int moons, int diamonds, CurrencySpriteType demonKey, int keyCount, CurrencySpriteType shardType, int shardsCount, cocos2d::CCPoint position, CurrencyRewardType p9, float p10, float time) -> decltype(create(orbs, stars, moons, diamonds, demonKey, keyCount, shardType, shardsCount, position, p9, p10, time)) {
	using FunctionType = decltype(create(orbs, stars, moons, diamonds, demonKey, keyCount, shardType, shardsCount, position, p9, p10, time))(*)(int, int, int, int, CurrencySpriteType, int, CurrencySpriteType, int, cocos2d::CCPoint, CurrencyRewardType, float, float);
	static auto func = wrapFunction(base::get() + 0x9f500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(orbs, stars, moons, diamonds, demonKey, keyCount, shardType, shardsCount, position, p9, p10, time);
}

auto CurrencyRewardLayer::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CurrencyRewardLayer::update), this);
	using FunctionType = decltype(update(p0))(*)(CurrencyRewardLayer*, float);
	static auto func = wrapFunction(base::get() + 0xa2230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

void CurrencyRewardLayer::createObjects(CurrencySpriteType type, int count, cocos2d::CCPoint position, float time) {
        this->createObjectsFull(type, count, nullptr, position, time);
    }

auto CurrencyRewardLayer::createObjectsFull(CurrencySpriteType p0, int p1, cocos2d::CCSprite* p2, cocos2d::CCPoint p3, float p4) -> decltype(createObjectsFull(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(createObjectsFull(p0, p1, p2, p3, p4))(*)(CurrencyRewardLayer*, CurrencySpriteType, int, cocos2d::CCSprite*, cocos2d::CCPoint, float);
	static auto func = wrapFunction(base::get() + 0xa1520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

void CurrencyRewardLayer::createUnlockObject(cocos2d::CCSprite* sprite, cocos2d::CCPoint position, float time) {
        this->createObjectsFull(CurrencySpriteType::Icon, 1, sprite, position, time);
    }

void CurrencyRewardLayer::incrementCount(int count) {
        if (m_orbsLabel == nullptr) return;
        m_orbs += count;
        this->pulseSprite(m_orbsSprite);
        m_orbsLabel->setString(cocos2d::CCString::createWithFormat("%i", count)->getCString());
    }

void CurrencyRewardLayer::incrementDiamondsCount(int count) {
        if (m_diamondsLabel == nullptr) return;
        m_diamonds += count;
        this->pulseSprite(m_diamondsSprite);
        m_diamondsLabel->setString(cocos2d::CCString::createWithFormat("%i", count)->getCString());
    }

void CurrencyRewardLayer::incrementMoonsCount(int count) {
        if (m_moonsLabel == nullptr) return;
        m_moons += count;
        this->pulseSprite(m_moonsSprite);
        m_moonsLabel->setString(cocos2d::CCString::createWithFormat("%i", count)->getCString());
    }

void CurrencyRewardLayer::incrementSpecialCount1(int count) {
        if (m_keysLabel == nullptr) return;
        m_keys += count;
        this->pulseSprite(m_keysSprite);
        m_keysLabel->setString(cocos2d::CCString::createWithFormat("%i", count)->getCString());
    }

void CurrencyRewardLayer::incrementSpecialCount2(int count) {
        if (m_shardsLabel == nullptr) return;
        m_shards += count;
        this->pulseSprite(m_shardsSprite);
        m_shardsLabel->setString(cocos2d::CCString::createWithFormat("%i", count)->getCString());
    }

void CurrencyRewardLayer::incrementStarsCount(int count) {
        if (m_starsLabel == nullptr) return;
        m_stars += count;
        this->pulseSprite(m_starsSprite);
        m_starsLabel->setString(cocos2d::CCString::createWithFormat("%i", count)->getCString());
    }

auto CurrencyRewardLayer::init(int p0, int p1, int p2, int p3, CurrencySpriteType p4, int p5, CurrencySpriteType p6, int p7, cocos2d::CCPoint p8, CurrencyRewardType p9, float p10, float p11) -> decltype(init(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11))(*)(CurrencyRewardLayer*, int, int, int, int, CurrencySpriteType, int, CurrencySpriteType, int, cocos2d::CCPoint, CurrencyRewardType, float, float);
	static auto func = wrapFunction(base::get() + 0x9f750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11);
}

auto CurrencyRewardLayer::pulseSprite(cocos2d::CCSprite* p0) -> decltype(pulseSprite(p0)) {
	using FunctionType = decltype(pulseSprite(p0))(*)(CurrencyRewardLayer*, cocos2d::CCSprite*);
	static auto func = wrapFunction(base::get() + 0xa2c00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

CurrencySprite::CurrencySprite() : CurrencySprite(geode::CutoffConstructor, sizeof(CurrencySprite)) {
	// here we construct it as normal as we can, then destruct it
	// using the generated functions. this ensures no memory gets leaked
	// no crashes :pray:
	CCDestructor::lock(this) = true;
	CurrencySprite::~CurrencySprite();
	using FunctionType = void(*)(CurrencySprite*);
	static auto func = wrapFunction(base::get() + 0x9f3c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
}

CurrencySprite* CurrencySprite::create(CurrencySpriteType type, bool burst) {
        auto ret = new CurrencySprite();
        if (ret->init(type, burst)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto CurrencySprite::createWithSprite(cocos2d::CCSprite* p0) -> decltype(createWithSprite(p0)) {
	using FunctionType = decltype(createWithSprite(p0))(*)(cocos2d::CCSprite*);
	static auto func = wrapFunction(base::get() + 0xa44b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto CurrencySprite::spriteTypeToStat(CurrencySpriteType p0) -> decltype(spriteTypeToStat(p0)) {
	using FunctionType = decltype(spriteTypeToStat(p0))(*)(CurrencySpriteType);
	static auto func = wrapFunction(base::get() + 0xa4780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto CurrencySprite::init(CurrencySpriteType p0, bool p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(CurrencySprite*, CurrencySpriteType, bool);
	static auto func = wrapFunction(base::get() + 0xa2cd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

void HSVWidgetDelegate::hsvPopupClosed(HSVWidgetPopup* p0, cocos2d::ccHSVValue p1) {}

void HSVWidgetDelegate::hsvChanged(ConfigureHSVWidget* p0) {}

auto CustomizeObjectLayer::create(GameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(GameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0xa4b60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto CustomizeObjectLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CustomizeObjectLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(CustomizeObjectLayer*);
	static auto func = wrapFunction(base::get() + 0xa99e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CustomizeObjectLayer::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&CustomizeObjectLayer::textInputOpened), this);
	using FunctionType = decltype(textInputOpened(p0))(*)(CustomizeObjectLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0xa8f70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomizeObjectLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	throw std::runtime_error("CustomizeObjectLayer::textInputClosed not implemented");
}

auto CustomizeObjectLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&CustomizeObjectLayer::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(CustomizeObjectLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0xa9100, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomizeObjectLayer::hsvPopupClosed(HSVWidgetPopup* p0, cocos2d::ccHSVValue p1) -> decltype(hsvPopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<HSVWidgetPopup*, cocos2d::ccHSVValue>::func(&CustomizeObjectLayer::hsvPopupClosed), this);
	using FunctionType = decltype(hsvPopupClosed(p0, p1))(*)(CustomizeObjectLayer*, HSVWidgetPopup*, cocos2d::ccHSVValue);
	static auto func = wrapFunction(base::get() + 0xa86a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CustomizeObjectLayer::colorSelectClosed(cocos2d::CCNode* p0) -> decltype(colorSelectClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*>::func(&CustomizeObjectLayer::colorSelectClosed), this);
	using FunctionType = decltype(colorSelectClosed(p0))(*)(CustomizeObjectLayer*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0xa8030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomizeObjectLayer::colorSetupClosed(int p0) -> decltype(colorSetupClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&CustomizeObjectLayer::colorSetupClosed), this);
	using FunctionType = decltype(colorSetupClosed(p0))(*)(CustomizeObjectLayer*, int);
	static auto func = wrapFunction(base::get() + 0xa7c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomizeObjectLayer::getActiveMode(bool p0) -> decltype(getActiveMode(p0)) {
	using FunctionType = decltype(getActiveMode(p0))(*)(CustomizeObjectLayer*, bool);
	static auto func = wrapFunction(base::get() + 0xa8cb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CustomizeObjectLayer::getButtonByTag(int p0) -> decltype(getButtonByTag(p0)) {
	using FunctionType = decltype(getButtonByTag(p0))(*)(CustomizeObjectLayer*, int);
	static auto func = wrapFunction(base::get() + 0xa9520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CustomizeObjectLayer::highlightSelected(ButtonSprite* p0) -> decltype(highlightSelected(p0)) {
	using FunctionType = decltype(highlightSelected(p0))(*)(CustomizeObjectLayer*, ButtonSprite*);
	static auto func = wrapFunction(base::get() + 0xa97d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CustomizeObjectLayer::init(GameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(CustomizeObjectLayer*, GameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0xa4d00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto CustomizeObjectLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(CustomizeObjectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xa9900, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomizeObjectLayer::onHSV(cocos2d::CCObject* sender) -> decltype(onHSV(sender)) {
	using FunctionType = decltype(onHSV(sender))(*)(CustomizeObjectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xa8470, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomizeObjectLayer::onSelectColor(cocos2d::CCObject* sender) -> decltype(onSelectColor(sender)) {
	using FunctionType = decltype(onSelectColor(sender))(*)(CustomizeObjectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xa95a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomizeObjectLayer::onSelectMode(cocos2d::CCObject* sender) -> decltype(onSelectMode(sender)) {
	using FunctionType = decltype(onSelectMode(sender))(*)(CustomizeObjectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xa88e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomizeObjectLayer::onUpdateCustomColor(cocos2d::CCObject* sender) -> decltype(onUpdateCustomColor(sender)) {
	using FunctionType = decltype(onUpdateCustomColor(sender))(*)(CustomizeObjectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xa8ea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomizeObjectLayer::toggleVisible() -> decltype(toggleVisible()) {
	using FunctionType = decltype(toggleVisible())(*)(CustomizeObjectLayer*);
	static auto func = wrapFunction(base::get() + 0xa8af0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void CustomizeObjectLayer::updateChannelLabel(int channel) {
        if (channel > 999) {
            m_selectedColorLabel->setString(GJSpecialColorSelect::textForColorIdx(channel));
        }
        else if (channel > 0) {
            // Technically not identical to RobTop impl which uses `CCString::createWithFormat`
            m_selectedColorLabel->setString(std::to_string(channel).c_str());
        }
        else {
            m_selectedColorLabel->setString(" ");
        }
    }

auto CustomizeObjectLayer::updateColorSprite() -> decltype(updateColorSprite()) {
	using FunctionType = decltype(updateColorSprite())(*)(CustomizeObjectLayer*);
	static auto func = wrapFunction(base::get() + 0xa7e20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CustomizeObjectLayer::updateCustomColorLabels() -> decltype(updateCustomColorLabels()) {
	using FunctionType = decltype(updateCustomColorLabels())(*)(CustomizeObjectLayer*);
	static auto func = wrapFunction(base::get() + 0xa9490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CustomizeObjectLayer::updateHSVButtons() -> decltype(updateHSVButtons()) {
	using FunctionType = decltype(updateHSVButtons())(*)(CustomizeObjectLayer*);
	static auto func = wrapFunction(base::get() + 0xa8270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CustomizeObjectLayer::updateSelected(int p0) -> decltype(updateSelected(p0)) {
	using FunctionType = decltype(updateSelected(p0))(*)(CustomizeObjectLayer*, int);
	static auto func = wrapFunction(base::get() + 0xa9660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CustomizeObjectSettingsPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&CustomizeObjectSettingsPopup::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(CustomizeObjectSettingsPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xa9e50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto CustomizeObjectSettingsPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&CustomizeObjectSettingsPopup::onCustomToggleTriggerValue), this);
	using FunctionType = decltype(onCustomToggleTriggerValue(sender))(*)(CustomizeObjectSettingsPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xa9da0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

CustomListView::~CustomListView() {}

auto CustomListView::create(cocos2d::CCArray* p0, TableViewCellDelegate* p1, float p2, float p3, int p4, BoomListType p5, float p6) -> decltype(create(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5, p6))(*)(cocos2d::CCArray*, TableViewCellDelegate*, float, float, int, BoomListType, float);
	static auto func = wrapFunction(base::get() + 0xaa010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5, p6);
}

CustomListView* CustomListView::create(cocos2d::CCArray* entries, BoomListType type, float width, float height) {
        return CustomListView::create(entries, nullptr, width, height, 0, type, 0.0f);
    }

auto CustomListView::setupList(float p0) -> decltype(setupList(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CustomListView::setupList), this);
	using FunctionType = decltype(setupList(p0))(*)(CustomListView*, float);
	static auto func = wrapFunction(base::get() + 0xab5c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomListView::getListCell(char const* p0) -> decltype(getListCell(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&CustomListView::getListCell), this);
	using FunctionType = decltype(getListCell(p0))(*)(CustomListView*, char const*);
	static auto func = wrapFunction(base::get() + 0xaa140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomListView::loadCell(TableViewCell* p0, int p1) -> decltype(loadCell(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<TableViewCell*, int>::func(&CustomListView::loadCell), this);
	using FunctionType = decltype(loadCell(p0, p1))(*)(CustomListView*, TableViewCell*, int);
	static auto func = wrapFunction(base::get() + 0xaaf00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CustomListView::reloadAll() -> decltype(reloadAll()) {
	using FunctionType = decltype(reloadAll())(*)(CustomListView*);
	static auto func = wrapFunction(base::get() + 0xabc90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CustomSongDelegate::songIDChanged(int p0) -> decltype(songIDChanged(p0)) {
	throw std::runtime_error("CustomSongDelegate::songIDChanged not implemented");
}

auto CustomSongDelegate::getActiveSongID() -> decltype(getActiveSongID()) {
	throw std::runtime_error("CustomSongDelegate::getActiveSongID not implemented");
}

auto CustomSongDelegate::getSongFileName() -> decltype(getSongFileName()) {
	throw std::runtime_error("CustomSongDelegate::getSongFileName not implemented");
}

auto CustomSongDelegate::getLevelSettings() -> decltype(getLevelSettings()) {
	throw std::runtime_error("CustomSongDelegate::getLevelSettings not implemented");
}

auto CustomSongCell::init() -> decltype(init()) {
	throw std::runtime_error("CustomSongCell::init not implemented");
}

auto CustomSongCell::draw() -> decltype(draw()) {
	throw std::runtime_error("CustomSongCell::draw not implemented");
}

auto CustomSongCell::songIDChanged(int p0) -> decltype(songIDChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&CustomSongCell::songIDChanged), this);
	using FunctionType = decltype(songIDChanged(p0))(*)(CustomSongCell*, int);
	static auto func = wrapFunction(base::get() + 0xb40d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomSongCell::getActiveSongID() -> decltype(getActiveSongID()) {
	throw std::runtime_error("CustomSongCell::getActiveSongID not implemented");
}

auto CustomSongCell::getSongFileName() -> decltype(getSongFileName()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CustomSongCell::getSongFileName), this);
	using FunctionType = decltype(getSongFileName())(*)(CustomSongCell*);
	static auto func = wrapFunction(base::get() + 0xb4130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CustomSongCell::getLevelSettings() -> decltype(getLevelSettings()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CustomSongCell::getLevelSettings), this);
	using FunctionType = decltype(getLevelSettings())(*)(CustomSongCell*);
	static auto func = wrapFunction(base::get() + 0x83630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CustomSongCell::loadFromObject(SongInfoObject* p0) -> decltype(loadFromObject(p0)) {
	using FunctionType = decltype(loadFromObject(p0))(*)(CustomSongCell*, SongInfoObject*);
	static auto func = wrapFunction(base::get() + 0xb3f10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CustomMusicCell::loadFromObject(SongInfoObject* p0) -> decltype(loadFromObject(p0)) {
	using FunctionType = decltype(loadFromObject(p0))(*)(CustomMusicCell*, SongInfoObject*);
	static auto func = wrapFunction(base::get() + 0xb46f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CustomSFXDelegate::sfxObjectSelected(SFXInfoObject* p0) -> decltype(sfxObjectSelected(p0)) {
	throw std::runtime_error("CustomSFXDelegate::sfxObjectSelected not implemented");
}

auto CustomSFXDelegate::getActiveSFXID() -> decltype(getActiveSFXID()) {
	throw std::runtime_error("CustomSFXDelegate::getActiveSFXID not implemented");
}

auto CustomSFXDelegate::overridePlaySFX(SFXInfoObject* p0) -> decltype(overridePlaySFX(p0)) {
	throw std::runtime_error("CustomSFXDelegate::overridePlaySFX not implemented");
}

auto CustomSFXCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CustomSFXCell::init), this);
	using FunctionType = decltype(init())(*)(CustomSFXCell*);
	static auto func = wrapFunction(base::get() + 0xb4410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CustomSFXCell::draw() -> decltype(draw()) {
	throw std::runtime_error("CustomSFXCell::draw not implemented");
}

auto CustomSFXCell::sfxObjectSelected(SFXInfoObject* p0) -> decltype(sfxObjectSelected(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SFXInfoObject*>::func(&CustomSFXCell::sfxObjectSelected), this);
	using FunctionType = decltype(sfxObjectSelected(p0))(*)(CustomSFXCell*, SFXInfoObject*);
	static auto func = wrapFunction(base::get() + 0xb4520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomSFXCell::getActiveSFXID() -> decltype(getActiveSFXID()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CustomSFXCell::getActiveSFXID), this);
	using FunctionType = decltype(getActiveSFXID())(*)(CustomSFXCell*);
	static auto func = wrapFunction(base::get() + 0xb4110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CustomSFXCell::loadFromObject(SFXInfoObject* p0) -> decltype(loadFromObject(p0)) {
	using FunctionType = decltype(loadFromObject(p0))(*)(CustomSFXCell*, SFXInfoObject*);
	static auto func = wrapFunction(base::get() + 0xb4430, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CustomSFXCell::updateBGColor(int p0) -> decltype(updateBGColor(p0)) {
	using FunctionType = decltype(updateBGColor(p0))(*)(CustomSFXCell*, int);
	static auto func = wrapFunction(base::get() + 0xb4560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CustomSFXWidget::downloadSFXFinished(int p0) -> decltype(downloadSFXFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&CustomSFXWidget::downloadSFXFinished), this);
	using FunctionType = decltype(downloadSFXFinished(p0))(*)(CustomSFXWidget*, int);
	static auto func = wrapFunction(base::get() + 0xc18e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomSFXWidget::downloadSFXFailed(int p0, GJSongError p1) -> decltype(downloadSFXFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, GJSongError>::func(&CustomSFXWidget::downloadSFXFailed), this);
	using FunctionType = decltype(downloadSFXFailed(p0, p1))(*)(CustomSFXWidget*, int, GJSongError);
	static auto func = wrapFunction(base::get() + 0xc1960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CustomSFXWidget::songStateChanged() -> decltype(songStateChanged()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CustomSFXWidget::songStateChanged), this);
	using FunctionType = decltype(songStateChanged())(*)(CustomSFXWidget*);
	static auto func = wrapFunction(base::get() + 0xc1230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CustomSFXWidget::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&CustomSFXWidget::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(CustomSFXWidget*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0xc1a60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void GJDropDownLayerDelegate::dropDownLayerWillClose(GJDropDownLayer* p0) {}

void MusicBrowserDelegate::musicBrowserClosed(MusicBrowser* p0) {}

CustomSongLayer::CustomSongLayer() {
        m_songDelegate = nullptr;
        m_songIDInput = nullptr;
        m_delegate = nullptr;
    }

CustomSongLayer* CustomSongLayer::create(CustomSongDelegate* delegate) {
        auto ret = new CustomSongLayer();
        if (ret->init(delegate)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto CustomSongLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CustomSongLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(CustomSongLayer*);
	static auto func = wrapFunction(base::get() + 0xc3760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CustomSongLayer::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CustomSongLayer::show), this);
	using FunctionType = decltype(show())(*)(CustomSongLayer*);
	static auto func = wrapFunction(base::get() + 0xc3770, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CustomSongLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("CustomSongLayer::textChanged not implemented");
}

auto CustomSongLayer::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	throw std::runtime_error("CustomSongLayer::textInputOpened not implemented");
}

auto CustomSongLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	throw std::runtime_error("CustomSongLayer::textInputClosed not implemented");
}

auto CustomSongLayer::textInputShouldOffset(CCTextInputNode* p0, float p1) -> decltype(textInputShouldOffset(p0, p1)) {
	throw std::runtime_error("CustomSongLayer::textInputShouldOffset not implemented");
}

auto CustomSongLayer::textInputReturn(CCTextInputNode* p0) -> decltype(textInputReturn(p0)) {
	throw std::runtime_error("CustomSongLayer::textInputReturn not implemented");
}

auto CustomSongLayer::dropDownLayerWillClose(GJDropDownLayer* p0) -> decltype(dropDownLayerWillClose(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJDropDownLayer*>::func(&CustomSongLayer::dropDownLayerWillClose), this);
	using FunctionType = decltype(dropDownLayerWillClose(p0))(*)(CustomSongLayer*, GJDropDownLayer*);
	static auto func = wrapFunction(base::get() + 0xc34f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomSongLayer::musicBrowserClosed(MusicBrowser* p0) -> decltype(musicBrowserClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<MusicBrowser*>::func(&CustomSongLayer::musicBrowserClosed), this);
	using FunctionType = decltype(musicBrowserClosed(p0))(*)(CustomSongLayer*, MusicBrowser*);
	static auto func = wrapFunction(base::get() + 0xc35c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomSongLayer::init(CustomSongDelegate* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(CustomSongLayer*, CustomSongDelegate*);
	static auto func = wrapFunction(base::get() + 0xc1f00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CustomSongLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(CustomSongLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xc3690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomSongLayer::onMusicBrowser(cocos2d::CCObject* sender) -> decltype(onMusicBrowser(sender)) {
	using FunctionType = decltype(onMusicBrowser(sender))(*)(CustomSongLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xc31a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomSongLayer::onNewgroundsBrowser(cocos2d::CCObject* sender) -> decltype(onNewgroundsBrowser(sender)) {
	using FunctionType = decltype(onNewgroundsBrowser(sender))(*)(CustomSongLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xc3300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomSongLayer::onSearch(cocos2d::CCObject* sender) -> decltype(onSearch(sender)) {
	using FunctionType = decltype(onSearch(sender))(*)(CustomSongLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xc2c80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

void CustomSongLayerDelegate::customSongLayerClosed() {}

CustomSongWidget::CustomSongWidget() {
        m_songInfoObject = nullptr;
        m_buttonMenu = nullptr;
        m_songLabel = nullptr;
        m_artistLabel = nullptr;
        m_songIDLabel = nullptr;
        m_errorLabel = nullptr;
        m_downloadBtn = nullptr;
        m_cancelDownloadBtn = nullptr;
        m_selectSongBtn = nullptr;
        m_getSongInfoBtn = nullptr;
        m_playbackBtn = nullptr;
        m_moreBtn = nullptr;
        m_deleteBtn = nullptr;
        m_infoBtn = nullptr;
        m_sliderGroove = nullptr;
        m_sliderBar = nullptr;
        m_ncsLogo = nullptr;
        m_bgSpr = nullptr;
        m_songDelegate = nullptr;
        m_showSelectSongBtn = false;
        m_showPlayMusicBtn = false;
        m_showDownloadBtn = false;
        m_isNotDownloading = false;
        m_isRobtopSong = false;
        m_isMusicLibrary = false;
        m_customSongID = 0;
        m_lengthMod = 0.f;
        m_unkPtr = nullptr;
        m_unkPtr2 = nullptr;
        m_hasLibrarySongs = false;
        m_hasSFX = false;
        m_unkBool2 = false;
        m_songs = {};
        m_sfx = {};
        m_undownloadedAssets = {};
    }

auto CustomSongWidget::create(SongInfoObject* songInfo, CustomSongDelegate* songDelegate, bool showSongSelect, bool showPlayMusic, bool showDownload, bool isRobtopSong, bool unkBool, bool isMusicLibrary, int unk) -> decltype(create(songInfo, songDelegate, showSongSelect, showPlayMusic, showDownload, isRobtopSong, unkBool, isMusicLibrary, unk)) {
	using FunctionType = decltype(create(songInfo, songDelegate, showSongSelect, showPlayMusic, showDownload, isRobtopSong, unkBool, isMusicLibrary, unk))(*)(SongInfoObject*, CustomSongDelegate*, bool, bool, bool, bool, bool, bool, int);
	static auto func = wrapFunction(base::get() + 0xc74f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(songInfo, songDelegate, showSongSelect, showPlayMusic, showDownload, isRobtopSong, unkBool, isMusicLibrary, unk);
}

auto CustomSongWidget::loadSongInfoFinished(SongInfoObject* p0) -> decltype(loadSongInfoFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SongInfoObject*>::func(&CustomSongWidget::loadSongInfoFinished), this);
	using FunctionType = decltype(loadSongInfoFinished(p0))(*)(CustomSongWidget*, SongInfoObject*);
	static auto func = wrapFunction(base::get() + 0xcbd40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomSongWidget::loadSongInfoFailed(int p0, GJSongError p1) -> decltype(loadSongInfoFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, GJSongError>::func(&CustomSongWidget::loadSongInfoFailed), this);
	using FunctionType = decltype(loadSongInfoFailed(p0, p1))(*)(CustomSongWidget*, int, GJSongError);
	static auto func = wrapFunction(base::get() + 0xcbe90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CustomSongWidget::downloadSongFinished(int p0) -> decltype(downloadSongFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&CustomSongWidget::downloadSongFinished), this);
	using FunctionType = decltype(downloadSongFinished(p0))(*)(CustomSongWidget*, int);
	static auto func = wrapFunction(base::get() + 0xcbf20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomSongWidget::downloadSongFailed(int p0, GJSongError p1) -> decltype(downloadSongFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, GJSongError>::func(&CustomSongWidget::downloadSongFailed), this);
	using FunctionType = decltype(downloadSongFailed(p0, p1))(*)(CustomSongWidget*, int, GJSongError);
	static auto func = wrapFunction(base::get() + 0xcbfe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CustomSongWidget::downloadSFXFinished(int p0) -> decltype(downloadSFXFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&CustomSongWidget::downloadSFXFinished), this);
	using FunctionType = decltype(downloadSFXFinished(p0))(*)(CustomSongWidget*, int);
	static auto func = wrapFunction(base::get() + 0xcc060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomSongWidget::downloadSFXFailed(int p0, GJSongError p1) -> decltype(downloadSFXFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, GJSongError>::func(&CustomSongWidget::downloadSFXFailed), this);
	using FunctionType = decltype(downloadSFXFailed(p0, p1))(*)(CustomSongWidget*, int, GJSongError);
	static auto func = wrapFunction(base::get() + 0xcc080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CustomSongWidget::musicActionFinished(GJMusicAction p0) -> decltype(musicActionFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJMusicAction>::func(&CustomSongWidget::musicActionFinished), this);
	using FunctionType = decltype(musicActionFinished(p0))(*)(CustomSongWidget*, GJMusicAction);
	static auto func = wrapFunction(base::get() + 0xcc5c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomSongWidget::musicActionFailed(GJMusicAction p0) -> decltype(musicActionFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJMusicAction>::func(&CustomSongWidget::musicActionFailed), this);
	using FunctionType = decltype(musicActionFailed(p0))(*)(CustomSongWidget*, GJMusicAction);
	static auto func = wrapFunction(base::get() + 0xcc5f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomSongWidget::songStateChanged() -> decltype(songStateChanged()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CustomSongWidget::songStateChanged), this);
	using FunctionType = decltype(songStateChanged())(*)(CustomSongWidget*);
	static auto func = wrapFunction(base::get() + 0xca5d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CustomSongWidget::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&CustomSongWidget::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(CustomSongWidget*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0xcc960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CustomSongWidget::deleteSong() -> decltype(deleteSong()) {
	using FunctionType = decltype(deleteSong())(*)(CustomSongWidget*);
	static auto func = wrapFunction(base::get() + 0xc9160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CustomSongWidget::downloadAssetFailed(int p0, GJAssetType p1, GJSongError p2) -> decltype(downloadAssetFailed(p0, p1, p2)) {
	using FunctionType = decltype(downloadAssetFailed(p0, p1, p2))(*)(CustomSongWidget*, int, GJAssetType, GJSongError);
	static auto func = wrapFunction(base::get() + 0xcc4a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto CustomSongWidget::downloadAssetFinished(int p0, GJAssetType p1) -> decltype(downloadAssetFinished(p0, p1)) {
	using FunctionType = decltype(downloadAssetFinished(p0, p1))(*)(CustomSongWidget*, int, GJAssetType);
	static auto func = wrapFunction(base::get() + 0xcc3e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto CustomSongWidget::getSongInfoIfUnloaded() -> decltype(getSongInfoIfUnloaded()) {
	using FunctionType = decltype(getSongInfoIfUnloaded())(*)(CustomSongWidget*);
	static auto func = wrapFunction(base::get() + 0xc9af0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CustomSongWidget::init(SongInfoObject* songInfo, CustomSongDelegate* songDelegate, bool showSongSelect, bool showPlayMusic, bool showDownload, bool isRobtopSong, bool unkBool, bool isMusicLibrary, int unk) -> decltype(init(songInfo, songDelegate, showSongSelect, showPlayMusic, showDownload, isRobtopSong, unkBool, isMusicLibrary, unk)) {
	using FunctionType = decltype(init(songInfo, songDelegate, showSongSelect, showPlayMusic, showDownload, isRobtopSong, unkBool, isMusicLibrary, unk))(*)(CustomSongWidget*, SongInfoObject*, CustomSongDelegate*, bool, bool, bool, bool, bool, bool, int);
	static auto func = wrapFunction(base::get() + 0xc7700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, songInfo, songDelegate, showSongSelect, showPlayMusic, showDownload, isRobtopSong, unkBool, isMusicLibrary, unk);
}

auto CustomSongWidget::onDelete(cocos2d::CCObject* sender) -> decltype(onDelete(sender)) {
	using FunctionType = decltype(onDelete(sender))(*)(CustomSongWidget*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xc9040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomSongWidget::onDownload(cocos2d::CCObject* sender) -> decltype(onDownload(sender)) {
	using FunctionType = decltype(onDownload(sender))(*)(CustomSongWidget*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xc9cd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomSongWidget::onGetSongInfo(cocos2d::CCObject* sender) -> decltype(onGetSongInfo(sender)) {
	using FunctionType = decltype(onGetSongInfo(sender))(*)(CustomSongWidget*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xc9c40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomSongWidget::onInfo(cocos2d::CCObject* sender) -> decltype(onInfo(sender)) {
	using FunctionType = decltype(onInfo(sender))(*)(CustomSongWidget*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xc8d50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomSongWidget::onMore(cocos2d::CCObject* sender) -> decltype(onMore(sender)) {
	using FunctionType = decltype(onMore(sender))(*)(CustomSongWidget*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xc9360, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomSongWidget::onPlayback(cocos2d::CCObject* sender) -> decltype(onPlayback(sender)) {
	using FunctionType = decltype(onPlayback(sender))(*)(CustomSongWidget*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xc9fd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomSongWidget::onSelect(cocos2d::CCObject* sender) -> decltype(onSelect(sender)) {
	using FunctionType = decltype(onSelect(sender))(*)(CustomSongWidget*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xc9f70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomSongWidget::positionInfoObjects() -> decltype(positionInfoObjects()) {
	using FunctionType = decltype(positionInfoObjects())(*)(CustomSongWidget*);
	static auto func = wrapFunction(base::get() + 0xc88c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CustomSongWidget::processNextMultiAsset() -> decltype(processNextMultiAsset()) {
	using FunctionType = decltype(processNextMultiAsset())(*)(CustomSongWidget*);
	static auto func = wrapFunction(base::get() + 0xcc240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CustomSongWidget::showError(bool p0) -> decltype(showError(p0)) {
	using FunctionType = decltype(showError(p0))(*)(CustomSongWidget*, bool);
	static auto func = wrapFunction(base::get() + 0xcc710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CustomSongWidget::startDownload() -> decltype(startDownload()) {
	using FunctionType = decltype(startDownload())(*)(CustomSongWidget*);
	static auto func = wrapFunction(base::get() + 0xc9eb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CustomSongWidget::startMultiAssetDownload() -> decltype(startMultiAssetDownload()) {
	using FunctionType = decltype(startMultiAssetDownload())(*)(CustomSongWidget*);
	static auto func = wrapFunction(base::get() + 0xcc0a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CustomSongWidget::updateDownloadProgress(float p0) -> decltype(updateDownloadProgress(p0)) {
	using FunctionType = decltype(updateDownloadProgress(p0))(*)(CustomSongWidget*, float);
	static auto func = wrapFunction(base::get() + 0xca4a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CustomSongWidget::updateError(GJSongError p0) -> decltype(updateError(p0)) {
	using FunctionType = decltype(updateError(p0))(*)(CustomSongWidget*, GJSongError);
	static auto func = wrapFunction(base::get() + 0xcc640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void CustomSongWidget::updateLengthMod(float lengthMod) {
        this->m_lengthMod = lengthMod;
        this->updateSongInfo();
    }

auto CustomSongWidget::updateMultiAssetInfo(bool p0) -> decltype(updateMultiAssetInfo(p0)) {
	using FunctionType = decltype(updateMultiAssetInfo(p0))(*)(CustomSongWidget*, bool);
	static auto func = wrapFunction(base::get() + 0xcb760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CustomSongWidget::updatePlaybackBtn() -> decltype(updatePlaybackBtn()) {
	using FunctionType = decltype(updatePlaybackBtn())(*)(CustomSongWidget*);
	static auto func = wrapFunction(base::get() + 0xca3b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CustomSongWidget::updateProgressBar(int p0) -> decltype(updateProgressBar(p0)) {
	using FunctionType = decltype(updateProgressBar(p0))(*)(CustomSongWidget*, int);
	static auto func = wrapFunction(base::get() + 0xca550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CustomSongWidget::updateSongInfo() -> decltype(updateSongInfo()) {
	using FunctionType = decltype(updateSongInfo())(*)(CustomSongWidget*);
	static auto func = wrapFunction(base::get() + 0xca600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void CustomSongWidget::updateSongObject(SongInfoObject* songInfo) {
        m_errorLabel->setVisible(false);
        if (m_bgSpr) m_bgSpr->setVisible(false);
        if (m_songInfoObject != songInfo) {
            CC_SAFE_RETAIN(songInfo);
            CC_SAFE_RELEASE(m_songInfoObject);
            m_songInfoObject = songInfo;
        }
        m_customSongID = songInfo ? songInfo->m_songID : 0;
        this->updateSongInfo();
    }

auto CustomSongWidget::updateWithMultiAssets(gd::string p0, gd::string p1, int p2) -> decltype(updateWithMultiAssets(p0, p1, p2)) {
	using FunctionType = decltype(updateWithMultiAssets(p0, p1, p2))(*)(CustomSongWidget*, gd::string, gd::string, int);
	static auto func = wrapFunction(base::get() + 0xcb410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto DailyLevelNode::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&DailyLevelNode::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(DailyLevelNode*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0xd1c30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto DailyLevelNode::init(GJGameLevel* p0, DailyLevelPage* p1, bool p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(DailyLevelNode*, GJGameLevel*, DailyLevelPage*, bool);
	static auto func = wrapFunction(base::get() + 0xd0c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto DailyLevelNode::onClaimReward(cocos2d::CCObject* sender) -> decltype(onClaimReward(sender)) {
	using FunctionType = decltype(onClaimReward(sender))(*)(DailyLevelNode*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xd18f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto DailyLevelNode::onSkipLevel(cocos2d::CCObject* sender) -> decltype(onSkipLevel(sender)) {
	using FunctionType = decltype(onSkipLevel(sender))(*)(DailyLevelNode*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xd1a10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto DailyLevelNode::showSkipButton() -> decltype(showSkipButton()) {
	using FunctionType = decltype(showSkipButton())(*)(DailyLevelNode*);
	static auto func = wrapFunction(base::get() + 0xd1890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJDailyLevelDelegate::dailyStatusFinished(GJTimedLevelType p0) -> decltype(dailyStatusFinished(p0)) {
	throw std::runtime_error("GJDailyLevelDelegate::dailyStatusFinished not implemented");
}

auto GJDailyLevelDelegate::dailyStatusFailed(GJTimedLevelType p0, GJErrorCode p1) -> decltype(dailyStatusFailed(p0, p1)) {
	throw std::runtime_error("GJDailyLevelDelegate::dailyStatusFailed not implemented");
}

void LevelDownloadDelegate::levelDownloadFinished(GJGameLevel* p0) {}

void LevelDownloadDelegate::levelDownloadFailed(int p0) {}

auto DailyLevelPage::create(GJTimedLevelType p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(GJTimedLevelType);
	static auto func = wrapFunction(base::get() + 0xccfd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto DailyLevelPage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("DailyLevelPage::registerWithTouchDispatcher not implemented");
}

auto DailyLevelPage::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("DailyLevelPage::keyBackClicked not implemented");
}

auto DailyLevelPage::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&DailyLevelPage::show), this);
	using FunctionType = decltype(show())(*)(DailyLevelPage*);
	static auto func = wrapFunction(base::get() + 0x867a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void DailyLevelPage::FLAlert_Clicked(FLAlertLayer* p0, bool p1) {}

auto DailyLevelPage::dailyStatusFinished(GJTimedLevelType p0) -> decltype(dailyStatusFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJTimedLevelType>::func(&DailyLevelPage::dailyStatusFinished), this);
	using FunctionType = decltype(dailyStatusFinished(p0))(*)(DailyLevelPage*, GJTimedLevelType);
	static auto func = wrapFunction(base::get() + 0xce560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto DailyLevelPage::dailyStatusFailed(GJTimedLevelType p0, GJErrorCode p1) -> decltype(dailyStatusFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<GJTimedLevelType, GJErrorCode>::func(&DailyLevelPage::dailyStatusFailed), this);
	using FunctionType = decltype(dailyStatusFailed(p0, p1))(*)(DailyLevelPage*, GJTimedLevelType, GJErrorCode);
	static auto func = wrapFunction(base::get() + 0xce860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto DailyLevelPage::levelDownloadFinished(GJGameLevel* p0) -> decltype(levelDownloadFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJGameLevel*>::func(&DailyLevelPage::levelDownloadFinished), this);
	using FunctionType = decltype(levelDownloadFinished(p0))(*)(DailyLevelPage*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0xceb90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto DailyLevelPage::levelDownloadFailed(int p0) -> decltype(levelDownloadFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&DailyLevelPage::levelDownloadFailed), this);
	using FunctionType = decltype(levelDownloadFailed(p0))(*)(DailyLevelPage*, int);
	static auto func = wrapFunction(base::get() + 0xcebf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto DailyLevelPage::claimLevelReward(DailyLevelNode* p0, GJGameLevel* p1, cocos2d::CCPoint p2) -> decltype(claimLevelReward(p0, p1, p2)) {
	using FunctionType = decltype(claimLevelReward(p0, p1, p2))(*)(DailyLevelPage*, DailyLevelNode*, GJGameLevel*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0xd06b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto DailyLevelPage::createDailyNode(GJGameLevel* p0, bool p1, float p2, bool p3) -> decltype(createDailyNode(p0, p1, p2, p3)) {
	using FunctionType = decltype(createDailyNode(p0, p1, p2, p3))(*)(DailyLevelPage*, GJGameLevel*, bool, float, bool);
	static auto func = wrapFunction(base::get() + 0xcee40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto DailyLevelPage::getDailyTimeString(int timeLeft) -> decltype(getDailyTimeString(timeLeft)) {
	using FunctionType = decltype(getDailyTimeString(timeLeft))(*)(DailyLevelPage*, int);
	static auto func = wrapFunction(base::get() + 0xcf200, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, timeLeft);
}

auto DailyLevelPage::init(GJTimedLevelType p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(DailyLevelPage*, GJTimedLevelType);
	static auto func = wrapFunction(base::get() + 0xcd110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto DailyLevelPage::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(DailyLevelPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x86940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto DailyLevelPage::onTheSafe(cocos2d::CCObject* sender) -> decltype(onTheSafe(sender)) {
	using FunctionType = decltype(onTheSafe(sender))(*)(DailyLevelPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xd0bb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto DailyLevelPage::tryGetDailyStatus() -> decltype(tryGetDailyStatus()) {
	using FunctionType = decltype(tryGetDailyStatus())(*)(DailyLevelPage*);
	static auto func = wrapFunction(base::get() + 0xcec10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto DailyLevelPage::updateTimers(float p0) -> decltype(updateTimers(p0)) {
	using FunctionType = decltype(updateTimers(p0))(*)(DailyLevelPage*, float);
	static auto func = wrapFunction(base::get() + 0xd0360, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto RingObject::create(char const* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(char const*);
	static auto func = wrapFunction(base::get() + 0x489570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto RingObject::setScale(float p0) -> decltype(setScale(p0)) {
	throw std::runtime_error("RingObject::setScale not implemented");
}

auto RingObject::setRotation(float p0) -> decltype(setRotation(p0)) {
	throw std::runtime_error("RingObject::setRotation not implemented");
}

auto RingObject::resetObject() -> decltype(resetObject()) {
	throw std::runtime_error("RingObject::resetObject not implemented");
}

auto RingObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("RingObject::customObjectSetup not implemented");
}

auto RingObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("RingObject::getSaveString not implemented");
}

auto RingObject::setRScale(float p0) -> decltype(setRScale(p0)) {
	throw std::runtime_error("RingObject::setRScale not implemented");
}

auto RingObject::triggerActivated(float p0) -> decltype(triggerActivated(p0)) {
	throw std::runtime_error("RingObject::triggerActivated not implemented");
}

auto RingObject::shouldDrawEditorHitbox() -> decltype(shouldDrawEditorHitbox()) {
	throw std::runtime_error("RingObject::shouldDrawEditorHitbox not implemented");
}

auto RingObject::powerOnObject(int p0) -> decltype(powerOnObject(p0)) {
	throw std::runtime_error("RingObject::powerOnObject not implemented");
}

auto DashRingObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("DashRingObject::customObjectSetup not implemented");
}

auto DashRingObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("DashRingObject::getSaveString not implemented");
}

void DemonFilterDelegate::demonFilterSelectClosed(int p0) {}

DemonFilterSelectLayer::DemonFilterSelectLayer() {}

DemonFilterSelectLayer* DemonFilterSelectLayer::create() {
        auto ret = new DemonFilterSelectLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto DemonFilterSelectLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&DemonFilterSelectLayer::init), this);
	using FunctionType = decltype(init())(*)(DemonFilterSelectLayer*);
	static auto func = wrapFunction(base::get() + 0x302da0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto DemonFilterSelectLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&DemonFilterSelectLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(DemonFilterSelectLayer*);
	static auto func = wrapFunction(base::get() + 0x3034f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto DemonFilterSelectLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(DemonFilterSelectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3034a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto DemonFilterSelectLayer::selectRating(cocos2d::CCObject* sender) -> decltype(selectRating(sender)) {
	using FunctionType = decltype(selectRating(sender))(*)(DemonFilterSelectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3033e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto DemonInfoPopup::create(int easyClassic, int mediumClassic, int hardClassic, int insaneClassic, int extremeClassic, int easyPlatformer, int mediumPlatformer, int hardPlatformer, int insanePlatformer, int extremePlatformer, int weekly, int gauntlet) -> decltype(create(easyClassic, mediumClassic, hardClassic, insaneClassic, extremeClassic, easyPlatformer, mediumPlatformer, hardPlatformer, insanePlatformer, extremePlatformer, weekly, gauntlet)) {
	using FunctionType = decltype(create(easyClassic, mediumClassic, hardClassic, insaneClassic, extremeClassic, easyPlatformer, mediumPlatformer, hardPlatformer, insanePlatformer, extremePlatformer, weekly, gauntlet))(*)(int, int, int, int, int, int, int, int, int, int, int, int);
	static auto func = wrapFunction(base::get() + 0x3afc90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(easyClassic, mediumClassic, hardClassic, insaneClassic, extremeClassic, easyPlatformer, mediumPlatformer, hardPlatformer, insanePlatformer, extremePlatformer, weekly, gauntlet);
}

auto DemonInfoPopup::createFromString(gd::string p0) -> decltype(createFromString(p0)) {
	using FunctionType = decltype(createFromString(p0))(*)(gd::string);
	static auto func = wrapFunction(base::get() + 0x3af8c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto DemonInfoPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("DemonInfoPopup::keyBackClicked not implemented");
}

auto DemonInfoPopup::init(int easyClassic, int mediumClassic, int hardClassic, int insaneClassic, int extremeClassic, int easyPlatformer, int mediumPlatformer, int hardPlatformer, int insanePlatformer, int extremePlatformer, int weekly, int gauntlet) -> decltype(init(easyClassic, mediumClassic, hardClassic, insaneClassic, extremeClassic, easyPlatformer, mediumPlatformer, hardPlatformer, insanePlatformer, extremePlatformer, weekly, gauntlet)) {
	using FunctionType = decltype(init(easyClassic, mediumClassic, hardClassic, insaneClassic, extremeClassic, easyPlatformer, mediumPlatformer, hardPlatformer, insanePlatformer, extremePlatformer, weekly, gauntlet))(*)(DemonInfoPopup*, int, int, int, int, int, int, int, int, int, int, int, int);
	static auto func = wrapFunction(base::get() + 0x3afdf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, easyClassic, mediumClassic, hardClassic, insaneClassic, extremeClassic, easyPlatformer, mediumPlatformer, hardPlatformer, insanePlatformer, extremePlatformer, weekly, gauntlet);
}

auto TextAreaDelegate::fadeInTextFinished(TextArea* p0) -> decltype(fadeInTextFinished(p0)) {
	throw std::runtime_error("TextAreaDelegate::fadeInTextFinished not implemented");
}

DialogLayer* DialogLayer::create(DialogObject* object, int background) {
        return DialogLayer::createDialogLayer(object, nullptr, background);
    }

auto DialogLayer::createDialogLayer(DialogObject* object, cocos2d::CCArray* objects, int background) -> decltype(createDialogLayer(object, objects, background)) {
	using FunctionType = decltype(createDialogLayer(object, objects, background))(*)(DialogObject*, cocos2d::CCArray*, int);
	static auto func = wrapFunction(base::get() + 0xd1f60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(object, objects, background);
}

DialogLayer* DialogLayer::createWithObjects(cocos2d::CCArray* objects, int background) {
        return DialogLayer::createDialogLayer(nullptr, objects, background);
    }

auto DialogLayer::onEnter() -> decltype(onEnter()) {
	throw std::runtime_error("DialogLayer::onEnter not implemented");
}

auto DialogLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&DialogLayer::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(DialogLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0xd2b60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void DialogLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

auto DialogLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&DialogLayer::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(DialogLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0xd2b90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto DialogLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&DialogLayer::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(DialogLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0xd2bb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto DialogLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("DialogLayer::registerWithTouchDispatcher not implemented");
}

auto DialogLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&DialogLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(DialogLayer*);
	static auto func = wrapFunction(base::get() + 0xd2ad0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto DialogLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&DialogLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(DialogLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0xd2e80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto DialogLayer::fadeInTextFinished(TextArea* p0) -> decltype(fadeInTextFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<TextArea*>::func(&DialogLayer::fadeInTextFinished), this);
	using FunctionType = decltype(fadeInTextFinished(p0))(*)(DialogLayer*, TextArea*);
	static auto func = wrapFunction(base::get() + 0xd2bd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto DialogLayer::addToMainScene() -> decltype(addToMainScene()) {
	using FunctionType = decltype(addToMainScene())(*)(DialogLayer*);
	static auto func = wrapFunction(base::get() + 0xd2a70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto DialogLayer::animateInRandomSide() -> decltype(animateInRandomSide()) {
	using FunctionType = decltype(animateInRandomSide())(*)(DialogLayer*);
	static auto func = wrapFunction(base::get() + 0xd2c40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto DialogLayer::displayDialogObject(DialogObject* p0) -> decltype(displayDialogObject(p0)) {
	using FunctionType = decltype(displayDialogObject(p0))(*)(DialogLayer*, DialogObject*);
	static auto func = wrapFunction(base::get() + 0xd2570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto DialogLayer::displayNextObject() -> decltype(displayNextObject()) {
	using FunctionType = decltype(displayNextObject())(*)(DialogLayer*);
	static auto func = wrapFunction(base::get() + 0xd2510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto DialogLayer::handleDialogTap() -> decltype(handleDialogTap()) {
	using FunctionType = decltype(handleDialogTap())(*)(DialogLayer*);
	static auto func = wrapFunction(base::get() + 0xd2940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto DialogLayer::init(DialogObject* p0, cocos2d::CCArray* p1, int p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(DialogLayer*, DialogObject*, cocos2d::CCArray*, int);
	static auto func = wrapFunction(base::get() + 0xd20b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto DialogLayer::onClose() -> decltype(onClose()) {
	using FunctionType = decltype(onClose())(*)(DialogLayer*);
	static auto func = wrapFunction(base::get() + 0xd2ae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void DialogLayer::updateChatPlacement(DialogChatPlacement placement) {
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
            switch (placement) {
                case DialogChatPlacement::Center:
                        m_mainLayer->setPosition({winSize.width * 0.5F, winSize.height * 0.5F});
                        break;
                case DialogChatPlacement::Top:
                        m_mainLayer->setPosition({winSize.width * 0.5F, (winSize.height - 50.F) - 20.F});
                        break;
                case DialogChatPlacement::Bottom:
                        m_mainLayer->setPosition({winSize.width * 0.5F, 70.F});
                        break;
            }
    }

auto DialogLayer::updateNavButtonFrame() -> decltype(updateNavButtonFrame()) {
	using FunctionType = decltype(updateNavButtonFrame())(*)(DialogLayer*);
	static auto func = wrapFunction(base::get() + 0xd28c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto DialogObject::create(gd::string character, gd::string text, int characterFrame, float textScale, bool skippable, cocos2d::ccColor3B color) -> decltype(create(character, text, characterFrame, textScale, skippable, color)) {
	using FunctionType = decltype(create(character, text, characterFrame, textScale, skippable, color))(*)(gd::string, gd::string, int, float, bool, cocos2d::ccColor3B);
	static auto func = wrapFunction(base::get() + 0xd1da0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(character, text, characterFrame, textScale, skippable, color);
}

bool DialogObject::init(gd::string character, gd::string text, int characterFrame, float textScale, bool skippable, cocos2d::ccColor3B color) {
        m_character = character;
        m_text = text;
        m_characterFrame = characterFrame;
        m_textScale = textScale;
        m_color = color;
        m_skippable = skippable;
        return true;
    }

auto DownloadMessageDelegate::downloadMessageFinished(GJUserMessage* p0) -> decltype(downloadMessageFinished(p0)) {
	throw std::runtime_error("DownloadMessageDelegate::downloadMessageFinished not implemented");
}

auto DownloadMessageDelegate::downloadMessageFailed(int p0) -> decltype(downloadMessageFailed(p0)) {
	throw std::runtime_error("DownloadMessageDelegate::downloadMessageFailed not implemented");
}

auto DrawGridLayer::create(cocos2d::CCNode* p0, LevelEditorLayer* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(cocos2d::CCNode*, LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x2db1f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto DrawGridLayer::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&DrawGridLayer::update), this);
	using FunctionType = decltype(update(p0))(*)(DrawGridLayer*, float);
	static auto func = wrapFunction(base::get() + 0x2db6f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto DrawGridLayer::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&DrawGridLayer::draw), this);
	using FunctionType = decltype(draw())(*)(DrawGridLayer*);
	static auto func = wrapFunction(base::get() + 0x2db8f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto DrawGridLayer::loadTimeMarkers(gd::string p0) -> decltype(loadTimeMarkers(p0)) {
	using FunctionType = decltype(loadTimeMarkers(p0))(*)(DrawGridLayer*, gd::string);
	static auto func = wrapFunction(base::get() + 0x2db3d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

DungeonBarsSprite::DungeonBarsSprite() {
        m_barsSprite = nullptr;
    }

DungeonBarsSprite* DungeonBarsSprite::create() {
        auto ret = new DungeonBarsSprite();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto DungeonBarsSprite::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&DungeonBarsSprite::init), this);
	using FunctionType = decltype(init())(*)(DungeonBarsSprite*);
	static auto func = wrapFunction(base::get() + 0x3d8470, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto DungeonBarsSprite::visit() -> decltype(visit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&DungeonBarsSprite::visit), this);
	using FunctionType = decltype(visit())(*)(DungeonBarsSprite*);
	static auto func = wrapFunction(base::get() + 0x3d84f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void DungeonBarsSprite::animateOutBars() {
        auto a1 = cocos2d::CCMoveBy::create(0.08, { -1.5f, 0.0f });
        auto a2 = cocos2d::CCMoveBy::create(0.08, { 1.5f, 0.0f });
        auto a3 = cocos2d::CCMoveBy::create(0.08, { -1.5f, 0.0f });
        auto a4 = cocos2d::CCMoveBy::create(0.08, { 1.5f, 0.0f });
        auto a5 = cocos2d::CCMoveBy::create(0.08, { -1.5f, 0.0f });
        auto a6 = cocos2d::CCMoveBy::create(0.08, { 1.5f, 0.0f });
        auto a7 = cocos2d::CCMoveBy::create(2.5, { 0.0f, -130.0f });

        auto seq = cocos2d::CCSequence::create(
            a1, a2, a3, a4, a5, a6,
            cocos2d::CCEaseElasticIn::create(a7, 1.6f),
            nullptr
        );
        this->m_barsSprite->runAction(seq);
    }

void DynamicScrollDelegate::updatePageWithObject(cocos2d::CCObject* p0, cocos2d::CCObject* p1) {}

auto EditButtonBar::create(cocos2d::CCArray* objects, cocos2d::CCPoint size, int unk, bool unkBool, int columns, int rows) -> decltype(create(objects, size, unk, unkBool, columns, rows)) {
	using FunctionType = decltype(create(objects, size, unk, unkBool, columns, rows))(*)(cocos2d::CCArray*, cocos2d::CCPoint, int, bool, int, int);
	static auto func = wrapFunction(base::get() + 0xd2f40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(objects, size, unk, unkBool, columns, rows);
}

auto EditButtonBar::loadFromItems(cocos2d::CCArray* p0, int p1, int p2, bool p3) -> decltype(loadFromItems(p0, p1, p2, p3)) {
	using FunctionType = decltype(loadFromItems(p0, p1, p2, p3))(*)(EditButtonBar*, cocos2d::CCArray*, int, int, bool);
	static auto func = wrapFunction(base::get() + 0xd30a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto EditButtonBar::onLeft(cocos2d::CCObject* sender) -> decltype(onLeft(sender)) {
	using FunctionType = decltype(onLeft(sender))(*)(EditButtonBar*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xd3a90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditButtonBar::onRight(cocos2d::CCObject* sender) -> decltype(onRight(sender)) {
	using FunctionType = decltype(onRight(sender))(*)(EditButtonBar*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xd3a20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

void EditButtonBar::reloadItems(int rowCount, int columnCount) {
        if (m_buttonArray) this->loadFromItems(m_buttonArray, rowCount, columnCount, false);
    }

void UploadActionDelegate::uploadActionFinished(int p0, int p1) {}

void UploadActionDelegate::uploadActionFailed(int p0, int p1) {}

void UploadPopupDelegate::onClosePopup(UploadActionPopup* p0) {}

void SetIDPopupDelegate::setIDPopupClosed(SetIDPopup* p0, int p1) {}

EditLevelLayer::EditLevelLayer() {}

EditLevelLayer::~EditLevelLayer() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(EditLevelLayer*);
	static auto func = wrapFunction(base::get() + 0xd3c10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) EditLevelLayer(geode::CutoffConstructor, sizeof(EditLevelLayer));
	CCDestructor::lock(this) = true;
}

EditLevelLayer* EditLevelLayer::create(GJGameLevel* level) {
        auto ret = new EditLevelLayer();
        if (ret && ret->init(level)) {
            ret->autorelease();
            return ret;
        }
        CC_SAFE_DELETE(ret);
        return nullptr;
    }

auto EditLevelLayer::scene(GJGameLevel* p0) -> decltype(scene(p0)) {
	using FunctionType = decltype(scene(p0))(*)(GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0xd3d80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto EditLevelLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditLevelLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(EditLevelLayer*);
	static auto func = wrapFunction(base::get() + 0xd8570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditLevelLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&EditLevelLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(EditLevelLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0xd8580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditLevelLayer::setIDPopupClosed(SetIDPopup* p0, int p1) -> decltype(setIDPopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<SetIDPopup*, int>::func(&EditLevelLayer::setIDPopupClosed), this);
	using FunctionType = decltype(setIDPopupClosed(p0, p1))(*)(EditLevelLayer*, SetIDPopup*, int);
	static auto func = wrapFunction(base::get() + 0xd8050, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditLevelLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&EditLevelLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(EditLevelLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0xd7710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditLevelLayer::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&EditLevelLayer::textInputOpened), this);
	using FunctionType = decltype(textInputOpened(p0))(*)(EditLevelLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0xd65c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditLevelLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&EditLevelLayer::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(EditLevelLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0xd5fc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditLevelLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&EditLevelLayer::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(EditLevelLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0xd6730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditLevelLayer::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&EditLevelLayer::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(p0, p1))(*)(EditLevelLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0xd85f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditLevelLayer::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&EditLevelLayer::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(p0, p1))(*)(EditLevelLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0xd8730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditLevelLayer::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&EditLevelLayer::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(EditLevelLayer*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0xd85b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditLevelLayer::closeTextInputs() -> decltype(closeTextInputs()) {
	using FunctionType = decltype(closeTextInputs())(*)(EditLevelLayer*);
	static auto func = wrapFunction(base::get() + 0xd5f60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditLevelLayer::confirmDelete(cocos2d::CCObject* p0) -> decltype(confirmDelete(p0)) {
	using FunctionType = decltype(confirmDelete(p0))(*)(EditLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xd75d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditLevelLayer::confirmMoveToTop(cocos2d::CCObject* p0) -> decltype(confirmMoveToTop(p0)) {
	using FunctionType = decltype(confirmMoveToTop(p0))(*)(EditLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xd7e90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditLevelLayer::init(GJGameLevel* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(EditLevelLayer*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0xd3f10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditLevelLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	using FunctionType = decltype(onBack(sender))(*)(EditLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xd80e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditLevelLayer::onGuidelines(cocos2d::CCObject* sender) -> decltype(onGuidelines(sender)) {
	using FunctionType = decltype(onGuidelines(sender))(*)(EditLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xd52e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditLevelLayer::onHelp(cocos2d::CCObject* sender) -> decltype(onHelp(sender)) {
	using FunctionType = decltype(onHelp(sender))(*)(EditLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xd7c50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditLevelLayer::onLevelInfo(cocos2d::CCObject* sender) -> decltype(onLevelInfo(sender)) {
	using FunctionType = decltype(onLevelInfo(sender))(*)(EditLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xd5500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditLevelLayer::onPlay(cocos2d::CCObject* sender) -> decltype(onPlay(sender)) {
	using FunctionType = decltype(onPlay(sender))(*)(EditLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xd6920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditLevelLayer::onSetFolder(cocos2d::CCObject* sender) -> decltype(onSetFolder(sender)) {
	using FunctionType = decltype(onSetFolder(sender))(*)(EditLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xd7fc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditLevelLayer::onShare(cocos2d::CCObject* sender) -> decltype(onShare(sender)) {
	using FunctionType = decltype(onShare(sender))(*)(EditLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xd6f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditLevelLayer::setupLevelInfo() -> decltype(setupLevelInfo()) {
	using FunctionType = decltype(setupLevelInfo())(*)(EditLevelLayer*);
	static auto func = wrapFunction(base::get() + 0xd5720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditLevelLayer::verifyLevelName() -> decltype(verifyLevelName()) {
	using FunctionType = decltype(verifyLevelName())(*)(EditLevelLayer*);
	static auto func = wrapFunction(base::get() + 0xd8290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

GJOptionsLayer::GJOptionsLayer() : GJOptionsLayer(geode::CutoffConstructor, sizeof(GJOptionsLayer)) {
	// here we construct it as normal as we can, then destruct it
	// using the generated functions. this ensures no memory gets leaked
	// no crashes :pray:
	CCDestructor::lock(this) = true;
	GJOptionsLayer::~GJOptionsLayer();
	using FunctionType = void(*)(GJOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x285940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
}

void GJOptionsLayer::setupOptions() {}

auto GJOptionsLayer::didToggleGV(gd::string p0) -> decltype(didToggleGV(p0)) {
	throw std::runtime_error("GJOptionsLayer::didToggleGV not implemented");
}

void GJOptionsLayer::didToggle(int p0) {}

auto GJOptionsLayer::addGVToggle(char const* p0, char const* p1, char const* p2) -> decltype(addGVToggle(p0, p1, p2)) {
	using FunctionType = decltype(addGVToggle(p0, p1, p2))(*)(GJOptionsLayer*, char const*, char const*, char const*);
	static auto func = wrapFunction(base::get() + 0x288470, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

void GJOptionsLayer::addToggle(char const* p0, int p1, bool p2, char const* p3) {
        addToggleInternal(p0, p1, p2, p3);
    }

auto GJOptionsLayer::addToggleInternal(char const* p0, int p1, bool p2, char const* p3) -> decltype(addToggleInternal(p0, p1, p2, p3)) {
	using FunctionType = decltype(addToggleInternal(p0, p1, p2, p3))(*)(GJOptionsLayer*, char const*, int, bool, char const*);
	static auto func = wrapFunction(base::get() + 0x2885b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GJOptionsLayer::incrementCountForPage(int p0) -> decltype(incrementCountForPage(p0)) {
	using FunctionType = decltype(incrementCountForPage(p0))(*)(GJOptionsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x288b80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJOptionsLayer::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GJOptionsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x288130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJOptionsLayer::layerForPage(int p0) -> decltype(layerForPage(p0)) {
	using FunctionType = decltype(layerForPage(p0))(*)(GJOptionsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x288e10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void GJOptionsLayer::offsetToNextPage() {
        m_toggleCount += m_togglesPerPage - m_toggleCount % m_togglesPerPage;
    }

auto GJOptionsLayer::onToggle(cocos2d::CCObject* sender) -> decltype(onToggle(sender)) {
	using FunctionType = decltype(onToggle(sender))(*)(GJOptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2893e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorOptionsLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorOptionsLayer::init), this);
	using FunctionType = decltype(init())(*)(EditorOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x2896d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorOptionsLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&EditorOptionsLayer::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(EditorOptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x28a100, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto EditorOptionsLayer::setupOptions() -> decltype(setupOptions()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorOptionsLayer::setupOptions), this);
	using FunctionType = decltype(setupOptions())(*)(EditorOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x289700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorOptionsLayer::onButtonRows(cocos2d::CCObject* sender) -> decltype(onButtonRows(sender)) {
	using FunctionType = decltype(onButtonRows(sender))(*)(EditorOptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x28a070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorOptionsLayer::onButtonsPerRow(cocos2d::CCObject* sender) -> decltype(onButtonsPerRow(sender)) {
	using FunctionType = decltype(onButtonsPerRow(sender))(*)(EditorOptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x289fe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

EditorPauseLayer::EditorPauseLayer() {
        m_saved = false;
        m_guidelinesOffButton = nullptr;
        m_guidelinesOnButton = nullptr;
        m_editorLayer = nullptr;
    }

EditorPauseLayer* EditorPauseLayer::create(LevelEditorLayer* p0) {
        auto ret = new EditorPauseLayer();
        if (ret && ret->init(LevelEditorLayer::get())) {
            ret->autorelease();
            return ret;
        }
        CC_SAFE_DELETE(ret);
        return nullptr;
    }

auto EditorPauseLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorPauseLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(EditorPauseLayer*);
	static auto func = wrapFunction(base::get() + 0xdd0c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorPauseLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&EditorPauseLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(EditorPauseLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0xdd0d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorPauseLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorPauseLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(EditorPauseLayer*);
	static auto func = wrapFunction(base::get() + 0xd9020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorPauseLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&EditorPauseLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(EditorPauseLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0xdcfa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditorPauseLayer::doResetUnused() -> decltype(doResetUnused()) {
	using FunctionType = decltype(doResetUnused())(*)(EditorPauseLayer*);
	static auto func = wrapFunction(base::get() + 0x2d2b80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorPauseLayer::init(LevelEditorLayer* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(EditorPauseLayer*, LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0xd8990, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorPauseLayer::onAlignX(cocos2d::CCObject* sender) -> decltype(onAlignX(sender)) {
	using FunctionType = decltype(onAlignX(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xdb9e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onAlignY(cocos2d::CCObject* sender) -> decltype(onAlignY(sender)) {
	using FunctionType = decltype(onAlignY(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xdba10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onBuildHelper(cocos2d::CCObject* sender) -> decltype(onBuildHelper(sender)) {
	using FunctionType = decltype(onBuildHelper(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xdb7d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onCreateExtras(cocos2d::CCObject* sender) -> decltype(onCreateExtras(sender)) {
	using FunctionType = decltype(onCreateExtras(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xdb760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onExitEditor(cocos2d::CCObject* sender) -> decltype(onExitEditor(sender)) {
	using FunctionType = decltype(onExitEditor(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xdcd60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onExitNoSave(cocos2d::CCObject* sender) -> decltype(onExitNoSave(sender)) {
	using FunctionType = decltype(onExitNoSave(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xdce30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onResume(cocos2d::CCObject* sender) -> decltype(onResume(sender)) {
	using FunctionType = decltype(onResume(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xdc140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onSave(cocos2d::CCObject* sender) -> decltype(onSave(sender)) {
	using FunctionType = decltype(onSave(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xdcbf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onSaveAndExit(cocos2d::CCObject* sender) -> decltype(onSaveAndExit(sender)) {
	using FunctionType = decltype(onSaveAndExit(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xdcd20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onSaveAndPlay(cocos2d::CCObject* sender) -> decltype(onSaveAndPlay(sender)) {
	using FunctionType = decltype(onSaveAndPlay(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xdc9a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onSelectAll(cocos2d::CCObject* sender) -> decltype(onSelectAll(sender)) {
	using FunctionType = decltype(onSelectAll(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xdb870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onSelectAllLeft(cocos2d::CCObject* sender) -> decltype(onSelectAllLeft(sender)) {
	using FunctionType = decltype(onSelectAllLeft(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xdb9a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onSelectAllRight(cocos2d::CCObject* sender) -> decltype(onSelectAllRight(sender)) {
	using FunctionType = decltype(onSelectAllRight(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xdb9c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::playStep3() -> decltype(playStep3()) {
	using FunctionType = decltype(playStep3())(*)(EditorPauseLayer*);
	static auto func = wrapFunction(base::get() + 0xdcb50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorPauseLayer::saveLevel() -> decltype(saveLevel()) {
	using FunctionType = decltype(saveLevel())(*)(EditorPauseLayer*);
	static auto func = wrapFunction(base::get() + 0xdc310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorPauseLayer::togglePreviewAnim(cocos2d::CCObject* p0) -> decltype(togglePreviewAnim(p0)) {
	using FunctionType = decltype(togglePreviewAnim(p0))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xdbc10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void GJRotationControlDelegate::angleChanged(float angle) {}

void GJRotationControlDelegate::angleChangeBegin() {}

void GJRotationControlDelegate::angleChangeEnded() {}

void GJScaleControlDelegate::scaleXChanged(float scaleX, bool lock) {}

void GJScaleControlDelegate::scaleYChanged(float scaleY, bool lock) {}

void GJScaleControlDelegate::scaleXYChanged(float scaleX, float scaleY, bool lock) {}

void GJScaleControlDelegate::scaleChangeBegin() {}

void GJScaleControlDelegate::scaleChangeEnded() {}

void GJScaleControlDelegate::updateScaleControl() {}

void GJScaleControlDelegate::anchorPointMoved(cocos2d::CCPoint newAnchor) {}

auto GJTransformControlDelegate::transformScaleXChanged(float p0) -> decltype(transformScaleXChanged(p0)) {
	throw std::runtime_error("GJTransformControlDelegate::transformScaleXChanged not implemented");
}

auto GJTransformControlDelegate::transformScaleYChanged(float p0) -> decltype(transformScaleYChanged(p0)) {
	throw std::runtime_error("GJTransformControlDelegate::transformScaleYChanged not implemented");
}

auto GJTransformControlDelegate::transformScaleXYChanged(float p0, float p1) -> decltype(transformScaleXYChanged(p0, p1)) {
	throw std::runtime_error("GJTransformControlDelegate::transformScaleXYChanged not implemented");
}

auto GJTransformControlDelegate::transformRotationXChanged(float p0) -> decltype(transformRotationXChanged(p0)) {
	throw std::runtime_error("GJTransformControlDelegate::transformRotationXChanged not implemented");
}

auto GJTransformControlDelegate::transformRotationYChanged(float p0) -> decltype(transformRotationYChanged(p0)) {
	throw std::runtime_error("GJTransformControlDelegate::transformRotationYChanged not implemented");
}

auto GJTransformControlDelegate::transformRotationChanged(float p0) -> decltype(transformRotationChanged(p0)) {
	throw std::runtime_error("GJTransformControlDelegate::transformRotationChanged not implemented");
}

auto GJTransformControlDelegate::transformResetRotation() -> decltype(transformResetRotation()) {
	throw std::runtime_error("GJTransformControlDelegate::transformResetRotation not implemented");
}

auto GJTransformControlDelegate::transformRestoreRotation() -> decltype(transformRestoreRotation()) {
	throw std::runtime_error("GJTransformControlDelegate::transformRestoreRotation not implemented");
}

auto GJTransformControlDelegate::transformSkewXChanged(float p0) -> decltype(transformSkewXChanged(p0)) {
	throw std::runtime_error("GJTransformControlDelegate::transformSkewXChanged not implemented");
}

auto GJTransformControlDelegate::transformSkewYChanged(float p0) -> decltype(transformSkewYChanged(p0)) {
	throw std::runtime_error("GJTransformControlDelegate::transformSkewYChanged not implemented");
}

auto GJTransformControlDelegate::transformChangeBegin() -> decltype(transformChangeBegin()) {
	throw std::runtime_error("GJTransformControlDelegate::transformChangeBegin not implemented");
}

auto GJTransformControlDelegate::transformChangeEnded() -> decltype(transformChangeEnded()) {
	throw std::runtime_error("GJTransformControlDelegate::transformChangeEnded not implemented");
}

auto GJTransformControlDelegate::updateTransformControl() -> decltype(updateTransformControl()) {
	throw std::runtime_error("GJTransformControlDelegate::updateTransformControl not implemented");
}

auto GJTransformControlDelegate::anchorPointMoved(cocos2d::CCPoint p0) -> decltype(anchorPointMoved(p0)) {
	throw std::runtime_error("GJTransformControlDelegate::anchorPointMoved not implemented");
}

auto GJTransformControlDelegate::getTransformNode() -> decltype(getTransformNode()) {
	throw std::runtime_error("GJTransformControlDelegate::getTransformNode not implemented");
}

auto GJTransformControlDelegate::getUI() -> decltype(getUI()) {
	throw std::runtime_error("GJTransformControlDelegate::getUI not implemented");
}

EditorUI::EditorUI() : EditorUI(geode::CutoffConstructor, sizeof(EditorUI)) {
	// here we construct it as normal as we can, then destruct it
	// using the generated functions. this ensures no memory gets leaked
	// no crashes :pray:
	CCDestructor::lock(this) = true;
	EditorUI::~EditorUI();
	using FunctionType = void(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xdd4b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
}

EditorUI* EditorUI::get() {
        auto lel = LevelEditorLayer::get();
        if (!lel) return nullptr;
        return lel->m_editorUI;
    }

auto EditorUI::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::draw), this);
	using FunctionType = decltype(draw())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x121120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&EditorUI::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(EditorUI*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x121c60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditorUI::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&EditorUI::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(EditorUI*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x1222e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditorUI::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&EditorUI::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(EditorUI*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x122a30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditorUI::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	throw std::runtime_error("EditorUI::ccTouchCancelled not implemented");
}

auto EditorUI::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x9b1a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x1130e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&EditorUI::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(EditorUI*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x123770, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::getUI() -> decltype(getUI()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::getUI), this);
	using FunctionType = decltype(getUI())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xdd8f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::setIDPopupClosed(SetIDPopup* p0, int p1) -> decltype(setIDPopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<SetIDPopup*, int>::func(&EditorUI::setIDPopupClosed), this);
	using FunctionType = decltype(setIDPopupClosed(p0, p1))(*)(EditorUI*, SetIDPopup*, int);
	static auto func = wrapFunction(base::get() + 0xe5580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditorUI::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&EditorUI::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(EditorUI*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0xe5390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditorUI::updateTransformControl() -> decltype(updateTransformControl()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::updateTransformControl), this);
	using FunctionType = decltype(updateTransformControl())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x113b60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::transformChangeBegin() -> decltype(transformChangeBegin()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::transformChangeBegin), this);
	using FunctionType = decltype(transformChangeBegin())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x114050, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void EditorUI::transformChangeEnded() {}

auto EditorUI::getTransformNode() -> decltype(getTransformNode()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::getTransformNode), this);
	using FunctionType = decltype(getTransformNode())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xdd900, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::transformScaleXChanged(float p0) -> decltype(transformScaleXChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EditorUI::transformScaleXChanged), this);
	using FunctionType = decltype(transformScaleXChanged(p0))(*)(EditorUI*, float);
	static auto func = wrapFunction(base::get() + 0x11fca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::transformScaleYChanged(float p0) -> decltype(transformScaleYChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EditorUI::transformScaleYChanged), this);
	using FunctionType = decltype(transformScaleYChanged(p0))(*)(EditorUI*, float);
	static auto func = wrapFunction(base::get() + 0x11fcc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::transformScaleXYChanged(float p0, float p1) -> decltype(transformScaleXYChanged(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, float>::func(&EditorUI::transformScaleXYChanged), this);
	using FunctionType = decltype(transformScaleXYChanged(p0, p1))(*)(EditorUI*, float, float);
	static auto func = wrapFunction(base::get() + 0x11fce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditorUI::transformSkewXChanged(float p0) -> decltype(transformSkewXChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EditorUI::transformSkewXChanged), this);
	using FunctionType = decltype(transformSkewXChanged(p0))(*)(EditorUI*, float);
	static auto func = wrapFunction(base::get() + 0x11fd00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::transformSkewYChanged(float p0) -> decltype(transformSkewYChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EditorUI::transformSkewYChanged), this);
	using FunctionType = decltype(transformSkewYChanged(p0))(*)(EditorUI*, float);
	static auto func = wrapFunction(base::get() + 0x11fd20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::transformRotationXChanged(float p0) -> decltype(transformRotationXChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EditorUI::transformRotationXChanged), this);
	using FunctionType = decltype(transformRotationXChanged(p0))(*)(EditorUI*, float);
	static auto func = wrapFunction(base::get() + 0x11fd40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::transformRotationYChanged(float p0) -> decltype(transformRotationYChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EditorUI::transformRotationYChanged), this);
	using FunctionType = decltype(transformRotationYChanged(p0))(*)(EditorUI*, float);
	static auto func = wrapFunction(base::get() + 0x11fd60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::transformRotationChanged(float p0) -> decltype(transformRotationChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EditorUI::transformRotationChanged), this);
	using FunctionType = decltype(transformRotationChanged(p0))(*)(EditorUI*, float);
	static auto func = wrapFunction(base::get() + 0x11fd80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::transformResetRotation() -> decltype(transformResetRotation()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::transformResetRotation), this);
	using FunctionType = decltype(transformResetRotation())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x11fda0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::transformRestoreRotation() -> decltype(transformRestoreRotation()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::transformRestoreRotation), this);
	using FunctionType = decltype(transformRestoreRotation())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x11fdd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::songStateChanged() -> decltype(songStateChanged()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::songStateChanged), this);
	using FunctionType = decltype(songStateChanged())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x110990, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::colorSelectClosed(cocos2d::CCNode* p0) -> decltype(colorSelectClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*>::func(&EditorUI::colorSelectClosed), this);
	using FunctionType = decltype(colorSelectClosed(p0))(*)(EditorUI*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x11dcd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::keyUp(cocos2d::enumKeyCodes p0) -> decltype(keyUp(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&EditorUI::keyUp), this);
	using FunctionType = decltype(keyUp(p0))(*)(EditorUI*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x124a00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::scrollWheel(float p0, float p1) -> decltype(scrollWheel(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, float>::func(&EditorUI::scrollWheel), this);
	using FunctionType = decltype(scrollWheel(p0, p1))(*)(EditorUI*, float, float);
	static auto func = wrapFunction(base::get() + 0x124a40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditorUI::angleChangeBegin() -> decltype(angleChangeBegin()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::angleChangeBegin), this);
	using FunctionType = decltype(angleChangeBegin())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x121560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void EditorUI::angleChangeEnded() {}

auto EditorUI::angleChanged(float p0) -> decltype(angleChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EditorUI::angleChanged), this);
	using FunctionType = decltype(angleChanged(p0))(*)(EditorUI*, float);
	static auto func = wrapFunction(base::get() + 0x121570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::updateScaleControl() -> decltype(updateScaleControl()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::updateScaleControl), this);
	using FunctionType = decltype(updateScaleControl())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x113550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::anchorPointMoved(cocos2d::CCPoint p0) -> decltype(anchorPointMoved(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint>::func(&EditorUI::anchorPointMoved), this);
	using FunctionType = decltype(anchorPointMoved(p0))(*)(EditorUI*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x114060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::scaleChangeBegin() -> decltype(scaleChangeBegin()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::scaleChangeBegin), this);
	using FunctionType = decltype(scaleChangeBegin())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x1136b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void EditorUI::scaleChangeEnded() {}

auto EditorUI::scaleXChanged(float p0, bool p1) -> decltype(scaleXChanged(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, bool>::func(&EditorUI::scaleXChanged), this);
	using FunctionType = decltype(scaleXChanged(p0, p1))(*)(EditorUI*, float, bool);
	static auto func = wrapFunction(base::get() + 0x1136c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditorUI::scaleYChanged(float p0, bool p1) -> decltype(scaleYChanged(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, bool>::func(&EditorUI::scaleYChanged), this);
	using FunctionType = decltype(scaleYChanged(p0, p1))(*)(EditorUI*, float, bool);
	static auto func = wrapFunction(base::get() + 0x113770, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditorUI::scaleXYChanged(float p0, float p1, bool p2) -> decltype(scaleXYChanged(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<float, float, bool>::func(&EditorUI::scaleXYChanged), this);
	using FunctionType = decltype(scaleXYChanged(p0, p1, p2))(*)(EditorUI*, float, float, bool);
	static auto func = wrapFunction(base::get() + 0x113820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto EditorUI::activateRotationControl(cocos2d::CCObject* p0) -> decltype(activateRotationControl(p0)) {
	using FunctionType = decltype(activateRotationControl(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x121420, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::activateScaleControl(cocos2d::CCObject* p0) -> decltype(activateScaleControl(p0)) {
	using FunctionType = decltype(activateScaleControl(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x113280, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::activateTransformControl(cocos2d::CCObject* p0) -> decltype(activateTransformControl(p0)) {
	using FunctionType = decltype(activateTransformControl(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1138d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::applyOffset(GameObject* p0) -> decltype(applyOffset(p0)) {
	using FunctionType = decltype(applyOffset(p0))(*)(EditorUI*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x120d40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::checkDiffAfterTransformAnchor(cocos2d::CCPoint p0, cocos2d::CCArray* p1) -> decltype(checkDiffAfterTransformAnchor(p0, p1)) {
	using FunctionType = decltype(checkDiffAfterTransformAnchor(p0, p1))(*)(EditorUI*, cocos2d::CCPoint, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x1140e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto EditorUI::clickOnPosition(cocos2d::CCPoint p0) -> decltype(clickOnPosition(p0)) {
	using FunctionType = decltype(clickOnPosition(p0))(*)(EditorUI*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0xe1040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::colorSelectClosed(cocos2d::ccColor3B p0) -> decltype(colorSelectClosed(p0)) {
	using FunctionType = decltype(colorSelectClosed(p0))(*)(EditorUI*, cocos2d::ccColor3B);
	static auto func = wrapFunction(base::get() + 0x11dcd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::constrainGameLayerPosition() -> decltype(constrainGameLayerPosition()) {
	using FunctionType = decltype(constrainGameLayerPosition())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x120dd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::constrainGameLayerPosition(float p0, float p1) -> decltype(constrainGameLayerPosition(p0, p1)) {
	using FunctionType = decltype(constrainGameLayerPosition(p0, p1))(*)(EditorUI*, float, float);
	static auto func = wrapFunction(base::get() + 0x120dd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto EditorUI::copyObjects(cocos2d::CCArray* objects, bool copyColors, bool sort) -> decltype(copyObjects(objects, copyColors, sort)) {
	using FunctionType = decltype(copyObjects(objects, copyColors, sort))(*)(EditorUI*, cocos2d::CCArray*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x111560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, objects, copyColors, sort);
}

auto EditorUI::createCustomItems() -> decltype(createCustomItems()) {
	using FunctionType = decltype(createCustomItems())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xe30e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::createMoveMenu() -> decltype(createMoveMenu()) {
	using FunctionType = decltype(createMoveMenu())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x119350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::createObject(int p0, cocos2d::CCPoint p1) -> decltype(createObject(p0, p1)) {
	using FunctionType = decltype(createObject(p0, p1))(*)(EditorUI*, int, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x10e840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto EditorUI::createRockBases(cocos2d::CCArray* p0) -> decltype(createRockBases(p0)) {
	using FunctionType = decltype(createRockBases(p0))(*)(EditorUI*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x12da00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::createUndoObject(UndoCommand p0, bool p1) -> decltype(createUndoObject(p0, p1)) {
	using FunctionType = decltype(createUndoObject(p0, p1))(*)(EditorUI*, UndoCommand, bool);
	static auto func = wrapFunction(base::get() + 0x10f830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto EditorUI::createUndoSelectObject(bool p0) -> decltype(createUndoSelectObject(p0)) {
	using FunctionType = decltype(createUndoSelectObject(p0))(*)(EditorUI*, bool);
	static auto func = wrapFunction(base::get() + 0x10fb50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::deactivateScaleControl() -> decltype(deactivateScaleControl()) {
	using FunctionType = decltype(deactivateScaleControl())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x113480, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::deactivateTransformControl() -> decltype(deactivateTransformControl()) {
	using FunctionType = decltype(deactivateTransformControl())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x113ad0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::deselectAll() -> decltype(deselectAll()) {
	using FunctionType = decltype(deselectAll())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x10fd80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::deselectObject() -> decltype(deselectObject()) {
	using FunctionType = decltype(deselectObject())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x10fc60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::deselectObject(GameObject* p0) -> decltype(deselectObject(p0)) {
	using FunctionType = decltype(deselectObject(p0))(*)(EditorUI*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x10fc60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::doCopyObjects(bool p0) -> decltype(doCopyObjects(p0)) {
	using FunctionType = decltype(doCopyObjects(p0))(*)(EditorUI*, bool);
	static auto func = wrapFunction(base::get() + 0x111900, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::doPasteObjects(bool p0) -> decltype(doPasteObjects(p0)) {
	using FunctionType = decltype(doPasteObjects(p0))(*)(EditorUI*, bool);
	static auto func = wrapFunction(base::get() + 0x111a90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::dynamicGroupUpdate(bool p0) -> decltype(dynamicGroupUpdate(p0)) {
	using FunctionType = decltype(dynamicGroupUpdate(p0))(*)(EditorUI*, bool);
	static auto func = wrapFunction(base::get() + 0x117000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::editGroup(cocos2d::CCObject* p0) -> decltype(editGroup(p0)) {
	using FunctionType = decltype(editGroup(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x11d880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::editObject(cocos2d::CCObject* p0) -> decltype(editObject(p0)) {
	using FunctionType = decltype(editObject(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x11a510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::editObjectSpecial(int p0) -> decltype(editObjectSpecial(p0)) {
	using FunctionType = decltype(editObjectSpecial(p0))(*)(EditorUI*, int);
	static auto func = wrapFunction(base::get() + 0x11c4b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::findSnapObject(cocos2d::CCArray* p0, float p1) -> decltype(findSnapObject(p0, p1)) {
	using FunctionType = decltype(findSnapObject(p0, p1))(*)(EditorUI*, cocos2d::CCArray*, float);
	static auto func = wrapFunction(base::get() + 0x121690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto EditorUI::findSnapObject(cocos2d::CCPoint p0, float p1) -> decltype(findSnapObject(p0, p1)) {
	using FunctionType = decltype(findSnapObject(p0, p1))(*)(EditorUI*, cocos2d::CCPoint, float);
	static auto func = wrapFunction(base::get() + 0x121790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto EditorUI::flipObjectsX(cocos2d::CCArray* p0) -> decltype(flipObjectsX(p0)) {
	using FunctionType = decltype(flipObjectsX(p0))(*)(EditorUI*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x11f0f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::flipObjectsY(cocos2d::CCArray* p0) -> decltype(flipObjectsY(p0)) {
	using FunctionType = decltype(flipObjectsY(p0))(*)(EditorUI*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x11f2d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::getCreateBtn(int id, int bg) -> decltype(getCreateBtn(id, bg)) {
	using FunctionType = decltype(getCreateBtn(id, bg))(*)(EditorUI*, int, int);
	static auto func = wrapFunction(base::get() + 0x10d2a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, id, bg);
}

cocos2d::CCPoint EditorUI::getGridSnappedPos(cocos2d::CCPoint pos) {
        auto size = m_editorLayer->m_drawGridLayer->m_gridSize;
        auto xVal = std::floorf(pos.x / size);
        auto yVal = std::floorf(pos.y / size);
        return this->getLimitedPosition(ccp((xVal + 0.5) * size, (yVal + 0.5) * size));
    }

auto EditorUI::getGroupCenter(cocos2d::CCArray* objs, bool p1) -> decltype(getGroupCenter(objs, p1)) {
	using FunctionType = decltype(getGroupCenter(objs, p1))(*)(EditorUI*, cocos2d::CCArray*, bool);
	static auto func = wrapFunction(base::get() + 0x121190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, objs, p1);
}

auto EditorUI::getLimitedPosition(cocos2d::CCPoint p0) -> decltype(getLimitedPosition(p0)) {
	using FunctionType = decltype(getLimitedPosition(p0))(*)(EditorUI*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x11e6f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::getSelectedObjects() -> decltype(getSelectedObjects()) {
	using FunctionType = decltype(getSelectedObjects())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x10f780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::getSpriteButton(char const* spriteFrameName, cocos2d::SEL_MenuHandler selector, cocos2d::CCMenu* menu, float scale, int buttonKind, cocos2d::CCPoint offset) -> decltype(getSpriteButton(spriteFrameName, selector, menu, scale, buttonKind, offset)) {
	using FunctionType = decltype(getSpriteButton(spriteFrameName, selector, menu, scale, buttonKind, offset))(*)(EditorUI*, char const*, cocos2d::SEL_MenuHandler, cocos2d::CCMenu*, float, int, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0xe11d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, spriteFrameName, selector, menu, scale, buttonKind, offset);
}

CCMenuItemSpriteExtra* EditorUI::getSpriteButton(char const* spriteFrameName, cocos2d::SEL_MenuHandler selector, cocos2d::CCMenu* menu, float scale) {
        return this->getSpriteButton(spriteFrameName, selector, menu, scale, 1, {0, 0});
    }

auto EditorUI::getSpriteButton(cocos2d::CCSprite* sprite, cocos2d::SEL_MenuHandler selector, cocos2d::CCMenu* menu, float scale, int buttonKind, cocos2d::CCPoint offset) -> decltype(getSpriteButton(sprite, selector, menu, scale, buttonKind, offset)) {
	using FunctionType = decltype(getSpriteButton(sprite, selector, menu, scale, buttonKind, offset))(*)(EditorUI*, cocos2d::CCSprite*, cocos2d::SEL_MenuHandler, cocos2d::CCMenu*, float, int, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0xe1260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sprite, selector, menu, scale, buttonKind, offset);
}

auto EditorUI::init(LevelEditorLayer* editorLayer) -> decltype(init(editorLayer)) {
	using FunctionType = decltype(init(editorLayer))(*)(EditorUI*, LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0xdde60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, editorLayer);
}

auto EditorUI::isSpecialSnapObject(int p0) -> decltype(isSpecialSnapObject(p0)) {
	using FunctionType = decltype(isSpecialSnapObject(p0))(*)(EditorUI*, int);
	static auto func = wrapFunction(base::get() + 0x1272b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::menuItemFromObjectString(gd::string p0, int p1) -> decltype(menuItemFromObjectString(p0, p1)) {
	using FunctionType = decltype(menuItemFromObjectString(p0, p1))(*)(EditorUI*, gd::string, int);
	static auto func = wrapFunction(base::get() + 0x10d090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto EditorUI::moveForCommand(EditCommand command) -> decltype(moveForCommand(command)) {
	using FunctionType = decltype(moveForCommand(command))(*)(EditorUI*, EditCommand);
	static auto func = wrapFunction(base::get() + 0x11de20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, command);
}

auto EditorUI::moveGamelayer(cocos2d::CCPoint p0) -> decltype(moveGamelayer(p0)) {
	using FunctionType = decltype(moveGamelayer(p0))(*)(EditorUI*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0xe16b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::moveObject(GameObject* p0, cocos2d::CCPoint p1) -> decltype(moveObject(p0, p1)) {
	using FunctionType = decltype(moveObject(p0, p1))(*)(EditorUI*, GameObject*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x11e290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto EditorUI::moveObjectCall(cocos2d::CCObject* p0) -> decltype(moveObjectCall(p0)) {
	using FunctionType = decltype(moveObjectCall(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x11e000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::moveObjectCall(EditCommand p0) -> decltype(moveObjectCall(p0)) {
	using FunctionType = decltype(moveObjectCall(p0))(*)(EditorUI*, EditCommand);
	static auto func = wrapFunction(base::get() + 0x11e000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::offsetForKey(int p0) -> decltype(offsetForKey(p0)) {
	using FunctionType = decltype(offsetForKey(p0))(*)(EditorUI*, int);
	static auto func = wrapFunction(base::get() + 0x124bf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::onCopyState(cocos2d::CCObject* sender) -> decltype(onCopyState(sender)) {
	using FunctionType = decltype(onCopyState(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x112ac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onCreate() -> decltype(onCreate()) {
	using FunctionType = decltype(onCreate())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x10dd10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::onCreateButton(cocos2d::CCObject* sender) -> decltype(onCreateButton(sender)) {
	using FunctionType = decltype(onCreateButton(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x10d880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onCreateObject(int p0) -> decltype(onCreateObject(p0)) {
	using FunctionType = decltype(onCreateObject(p0))(*)(EditorUI*, int);
	static auto func = wrapFunction(base::get() + 0x10df10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::onDelete(cocos2d::CCObject* sender) -> decltype(onDelete(sender)) {
	using FunctionType = decltype(onDelete(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xe4760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onDeleteCustomItem(cocos2d::CCObject* sender) -> decltype(onDeleteCustomItem(sender)) {
	using FunctionType = decltype(onDeleteCustomItem(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xe2e80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onDeleteSelected(cocos2d::CCObject* sender) -> decltype(onDeleteSelected(sender)) {
	using FunctionType = decltype(onDeleteSelected(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xe4d80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onDeleteSelectedType(cocos2d::CCObject* sender) -> decltype(onDeleteSelectedType(sender)) {
	using FunctionType = decltype(onDeleteSelectedType(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xe5310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onDeleteStartPos(cocos2d::CCObject* sender) -> decltype(onDeleteStartPos(sender)) {
	using FunctionType = decltype(onDeleteStartPos(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xe5360, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onDeselectAll(cocos2d::CCObject* sender) -> decltype(onDeselectAll(sender)) {
	using FunctionType = decltype(onDeselectAll(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x10fd40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onDuplicate(cocos2d::CCObject* sender) -> decltype(onDuplicate(sender)) {
	using FunctionType = decltype(onDuplicate(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1113e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onEditColor(cocos2d::CCObject* sender) -> decltype(onEditColor(sender)) {
	using FunctionType = decltype(onEditColor(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x11d0b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onGoToBaseLayer(cocos2d::CCObject* sender) -> decltype(onGoToBaseLayer(sender)) {
	using FunctionType = decltype(onGoToBaseLayer(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x112f40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onGoToLayer(cocos2d::CCObject* sender) -> decltype(onGoToLayer(sender)) {
	using FunctionType = decltype(onGoToLayer(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x112de0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onGroupDown(cocos2d::CCObject* sender) -> decltype(onGroupDown(sender)) {
	using FunctionType = decltype(onGroupDown(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x11da90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onGroupIDFilter(cocos2d::CCObject* sender) -> decltype(onGroupIDFilter(sender)) {
	using FunctionType = decltype(onGroupIDFilter(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xe5a80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onGroupSticky(cocos2d::CCObject* sender) -> decltype(onGroupSticky(sender)) {
	using FunctionType = decltype(onGroupSticky(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1110f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onGroupUp(cocos2d::CCObject* sender) -> decltype(onGroupUp(sender)) {
	using FunctionType = decltype(onGroupUp(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x11da70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onLockLayer(cocos2d::CCObject* sender) -> decltype(onLockLayer(sender)) {
	using FunctionType = decltype(onLockLayer(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x11dc00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onNewCustomItem(cocos2d::CCObject* sender) -> decltype(onNewCustomItem(sender)) {
	using FunctionType = decltype(onNewCustomItem(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xe2990, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onPasteColor(cocos2d::CCObject* sender) -> decltype(onPasteColor(sender)) {
	using FunctionType = decltype(onPasteColor(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x112cd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onPasteState(cocos2d::CCObject* sender) -> decltype(onPasteState(sender)) {
	using FunctionType = decltype(onPasteState(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x112b40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onPause(cocos2d::CCObject* sender) -> decltype(onPause(sender)) {
	using FunctionType = decltype(onPause(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xe03d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onPlayback(cocos2d::CCObject* sender) -> decltype(onPlayback(sender)) {
	using FunctionType = decltype(onPlayback(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x110390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onPlaytest(cocos2d::CCObject* sender) -> decltype(onPlaytest(sender)) {
	using FunctionType = decltype(onPlaytest(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1109a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onSelectBuildTab(cocos2d::CCObject* sender) -> decltype(onSelectBuildTab(sender)) {
	using FunctionType = decltype(onSelectBuildTab(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x112f60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onSettings(cocos2d::CCObject* sender) -> decltype(onSettings(sender)) {
	using FunctionType = decltype(onSettings(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xe0350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onStopPlaytest(cocos2d::CCObject* sender) -> decltype(onStopPlaytest(sender)) {
	using FunctionType = decltype(onStopPlaytest(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x110d40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onUngroupSticky(cocos2d::CCObject* sender) -> decltype(onUngroupSticky(sender)) {
	using FunctionType = decltype(onUngroupSticky(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x111130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::pasteObjects(gd::string p0, bool p1, bool p2) -> decltype(pasteObjects(p0, p1, p2)) {
	using FunctionType = decltype(pasteObjects(p0, p1, p2))(*)(EditorUI*, gd::string, bool, bool);
	static auto func = wrapFunction(base::get() + 0x111d10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto EditorUI::playtestStopped() -> decltype(playtestStopped()) {
	using FunctionType = decltype(playtestStopped())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x110d80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::redoLastAction(cocos2d::CCObject* p0) -> decltype(redoLastAction(p0)) {
	using FunctionType = decltype(redoLastAction(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x110190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void EditorUI::reloadCustomItems() {
        GameManager* gm = GameManager::sharedState();
        int buttonsPerRow = gm->getIntGameVariable("0049");
        int buttonRows = gm->getIntGameVariable("0050");
        cocos2d::CCArray* customItems = createCustomItems();
        m_buttonBar->loadFromItems(customItems,buttonsPerRow,buttonRows,true);
    }

auto EditorUI::removeOffset(GameObject* p0) -> decltype(removeOffset(p0)) {
	using FunctionType = decltype(removeOffset(p0))(*)(EditorUI*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x120cb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::repositionObjectsToCenter(cocos2d::CCArray* p0, cocos2d::CCPoint p1, bool p2) -> decltype(repositionObjectsToCenter(p0, p1, p2)) {
	using FunctionType = decltype(repositionObjectsToCenter(p0, p1, p2))(*)(EditorUI*, cocos2d::CCArray*, cocos2d::CCPoint, bool);
	static auto func = wrapFunction(base::get() + 0x112a20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto EditorUI::resetUI() -> decltype(resetUI()) {
	using FunctionType = decltype(resetUI())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xe36d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::rotateObjects(cocos2d::CCArray* p0, float p1, cocos2d::CCPoint p2) -> decltype(rotateObjects(p0, p1, p2)) {
	using FunctionType = decltype(rotateObjects(p0, p1, p2))(*)(EditorUI*, cocos2d::CCArray*, float, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x11f4b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto EditorUI::scaleObjects(cocos2d::CCArray* p0, float p1, float p2, cocos2d::CCPoint p3, ObjectScaleType p4, bool p5) -> decltype(scaleObjects(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(scaleObjects(p0, p1, p2, p3, p4, p5))(*)(EditorUI*, cocos2d::CCArray*, float, float, cocos2d::CCPoint, ObjectScaleType, bool);
	static auto func = wrapFunction(base::get() + 0x11f8d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto EditorUI::selectBuildTab(int p0) -> decltype(selectBuildTab(p0)) {
	using FunctionType = decltype(selectBuildTab(p0))(*)(EditorUI*, int);
	static auto func = wrapFunction(base::get() + 0x112f90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::selectObject(GameObject* p0, bool p1) -> decltype(selectObject(p0, p1)) {
	using FunctionType = decltype(selectObject(p0, p1))(*)(EditorUI*, GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x10ee50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto EditorUI::selectObjects(cocos2d::CCArray* p0, bool p1) -> decltype(selectObjects(p0, p1)) {
	using FunctionType = decltype(selectObjects(p0, p1))(*)(EditorUI*, cocos2d::CCArray*, bool);
	static auto func = wrapFunction(base::get() + 0x10f140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto EditorUI::setupCreateMenu() -> decltype(setupCreateMenu()) {
	using FunctionType = decltype(setupCreateMenu())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xe6910, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::setupDeleteMenu() -> decltype(setupDeleteMenu()) {
	using FunctionType = decltype(setupDeleteMenu())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xe38d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void EditorUI::setupEditMenu() {
        this->createMoveMenu();
        this->updateEditMenu();
    }

auto EditorUI::shouldDeleteObject(GameObject* p0) -> decltype(shouldDeleteObject(p0)) {
	using FunctionType = decltype(shouldDeleteObject(p0))(*)(EditorUI*, GameObject*);
	static auto func = wrapFunction(base::get() + 0xe4c50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::showMaxError() -> decltype(showMaxError()) {
	using FunctionType = decltype(showMaxError())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x111170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::showUI(bool p0) -> decltype(showUI(p0)) {
	using FunctionType = decltype(showUI(p0))(*)(EditorUI*, bool);
	static auto func = wrapFunction(base::get() + 0x110200, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::sliderChanged(cocos2d::CCObject* p0) -> decltype(sliderChanged(p0)) {
	using FunctionType = decltype(sliderChanged(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xe13a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::spriteFromObjectString(gd::string str, bool p1, bool p2, int objLimit, cocos2d::CCArray* p4, cocos2d::CCArray* p5, GameObject* p6) -> decltype(spriteFromObjectString(str, p1, p2, objLimit, p4, p5, p6)) {
	using FunctionType = decltype(spriteFromObjectString(str, p1, p2, objLimit, p4, p5, p6))(*)(EditorUI*, gd::string, bool, bool, int, cocos2d::CCArray*, cocos2d::CCArray*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x10c790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, str, p1, p2, objLimit, p4, p5, p6);
}

auto EditorUI::toggleEditObjectButton() -> decltype(toggleEditObjectButton()) {
	using FunctionType = decltype(toggleEditObjectButton())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x118f10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::toggleEnableRotate(cocos2d::CCObject* p0) -> decltype(toggleEnableRotate(p0)) {
	using FunctionType = decltype(toggleEnableRotate(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x10eb00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::toggleFreeMove(cocos2d::CCObject* p0) -> decltype(toggleFreeMove(p0)) {
	using FunctionType = decltype(toggleFreeMove(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x10e980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::toggleMode(cocos2d::CCObject* p0) -> decltype(toggleMode(p0)) {
	using FunctionType = decltype(toggleMode(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xe37f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::toggleObjectInfoLabel() -> decltype(toggleObjectInfoLabel()) {
	using FunctionType = decltype(toggleObjectInfoLabel())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xe1730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::toggleSnap(cocos2d::CCObject* p0) -> decltype(toggleSnap(p0)) {
	using FunctionType = decltype(toggleSnap(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x10ea20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void EditorUI::toggleStickyControls(bool enable) {
        m_stickyControlsEnabled = enable;
        m_linkBtn->setEnabled(enable);
              m_linkBtn->setVisible(enable);
              m_unlinkBtn->setEnabled(enable);
              m_unlinkBtn->setVisible(enable);
    }

auto EditorUI::toggleSwipe(cocos2d::CCObject* p0) -> decltype(toggleSwipe(p0)) {
	using FunctionType = decltype(toggleSwipe(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x10e8e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::transformObject(GameObject* p0, EditCommand p1, bool p2) -> decltype(transformObject(p0, p1, p2)) {
	using FunctionType = decltype(transformObject(p0, p1, p2))(*)(EditorUI*, GameObject*, EditCommand, bool);
	static auto func = wrapFunction(base::get() + 0x11ed00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto EditorUI::transformObjectCall(cocos2d::CCObject* p0) -> decltype(transformObjectCall(p0)) {
	using FunctionType = decltype(transformObjectCall(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x11e7b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::transformObjectCall(EditCommand p0) -> decltype(transformObjectCall(p0)) {
	using FunctionType = decltype(transformObjectCall(p0))(*)(EditorUI*, EditCommand);
	static auto func = wrapFunction(base::get() + 0x11e7b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::transformObjects(cocos2d::CCArray* objs, cocos2d::CCPoint anchor, float scaleX, float scaleY, float rotateX, float rotateY, float warpX, float warpY) -> decltype(transformObjects(objs, anchor, scaleX, scaleY, rotateX, rotateY, warpX, warpY)) {
	using FunctionType = decltype(transformObjects(objs, anchor, scaleX, scaleY, rotateX, rotateY, warpX, warpY))(*)(EditorUI*, cocos2d::CCArray*, cocos2d::CCPoint, float, float, float, float, float, float);
	static auto func = wrapFunction(base::get() + 0x11fec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, objs, anchor, scaleX, scaleY, rotateX, rotateY, warpX, warpY);
}

auto EditorUI::undoLastAction(cocos2d::CCObject* p0) -> decltype(undoLastAction(p0)) {
	using FunctionType = decltype(undoLastAction(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x110120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::updateButtons() -> decltype(updateButtons()) {
	using FunctionType = decltype(updateButtons())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xe07e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::updateCreateMenu(bool p0) -> decltype(updateCreateMenu(p0)) {
	using FunctionType = decltype(updateCreateMenu(p0))(*)(EditorUI*, bool);
	static auto func = wrapFunction(base::get() + 0x10d8c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::updateDeleteButtons() -> decltype(updateDeleteButtons()) {
	using FunctionType = decltype(updateDeleteButtons())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xe5fb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void EditorUI::updateDeleteMenu() {
        m_deleteMenu->setVisible(m_selectedMode == 1);
    }

void EditorUI::updateEditMenu() {
        m_editButtonBar->setVisible(m_selectedMode == 3);
    }

auto EditorUI::updateGridNodeSize() -> decltype(updateGridNodeSize()) {
	using FunctionType = decltype(updateGridNodeSize())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xe1560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::updateObjectInfoLabel() -> decltype(updateObjectInfoLabel()) {
	using FunctionType = decltype(updateObjectInfoLabel())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xe17c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::updateSlider() -> decltype(updateSlider()) {
	using FunctionType = decltype(updateSlider())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xe14a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::updateZoom(float p0) -> decltype(updateZoom(p0)) {
	using FunctionType = decltype(updateZoom(p0))(*)(EditorUI*, float);
	static auto func = wrapFunction(base::get() + 0x110ef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::zoomIn(cocos2d::CCObject* p0) -> decltype(zoomIn(p0)) {
	using FunctionType = decltype(zoomIn(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x110e50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::zoomOut(cocos2d::CCObject* p0) -> decltype(zoomOut(p0)) {
	using FunctionType = decltype(zoomOut(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x110ea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditTriggersPopup::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("EditTriggersPopup::determineStartValues not implemented");
}

auto EditTriggersPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("EditTriggersPopup::onClose not implemented");
}

auto EditTriggersPopup::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(EditTriggersPopup*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x2875b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto EndLevelLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EndLevelLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(EndLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x133aa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EndLevelLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&EndLevelLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(EndLevelLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x135140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EndLevelLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EndLevelLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(EndLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x131260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EndLevelLayer::showLayer(bool p0) -> decltype(showLayer(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&EndLevelLayer::showLayer), this);
	using FunctionType = decltype(showLayer(p0))(*)(EndLevelLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x133070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

void EndLevelLayer::enterAnimFinished() {}

void EndLevelLayer::keyUp(cocos2d::enumKeyCodes p0) {}

auto EndLevelLayer::coinEnterFinished(cocos2d::CCPoint p0) -> decltype(coinEnterFinished(p0)) {
	using FunctionType = decltype(coinEnterFinished(p0))(*)(EndLevelLayer*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x134230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EndLevelLayer::coinEnterFinishedO(cocos2d::CCObject* p0) -> decltype(coinEnterFinishedO(p0)) {
	using FunctionType = decltype(coinEnterFinishedO(p0))(*)(EndLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1341f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EndLevelLayer::getCoinString() -> decltype(getCoinString()) {
	using FunctionType = decltype(getCoinString())(*)(EndLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x132d30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EndLevelLayer::getEndText() -> decltype(getEndText()) {
	using FunctionType = decltype(getEndText())(*)(EndLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x135190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EndLevelLayer::goEdit() -> decltype(goEdit()) {
	using FunctionType = decltype(goEdit())(*)(EndLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x1336e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EndLevelLayer::onEdit(cocos2d::CCObject* sender) -> decltype(onEdit(sender)) {
	using FunctionType = decltype(onEdit(sender))(*)(EndLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1335e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EndLevelLayer::onHideLayer(cocos2d::CCObject* sender) -> decltype(onHideLayer(sender)) {
	using FunctionType = decltype(onHideLayer(sender))(*)(EndLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1337b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EndLevelLayer::onLevelLeaderboard(cocos2d::CCObject* sender) -> decltype(onLevelLeaderboard(sender)) {
	using FunctionType = decltype(onLevelLeaderboard(sender))(*)(EndLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x132c30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EndLevelLayer::onMenu(cocos2d::CCObject* sender) -> decltype(onMenu(sender)) {
	using FunctionType = decltype(onMenu(sender))(*)(EndLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x133460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EndLevelLayer::onReplay(cocos2d::CCObject* sender) -> decltype(onReplay(sender)) {
	using FunctionType = decltype(onReplay(sender))(*)(EndLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x133250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EndLevelLayer::onRestartCheckpoint(cocos2d::CCObject* sender) -> decltype(onRestartCheckpoint(sender)) {
	using FunctionType = decltype(onRestartCheckpoint(sender))(*)(EndLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x133890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EndLevelLayer::playCoinEffect(float p0) -> decltype(playCoinEffect(p0)) {
	using FunctionType = decltype(playCoinEffect(p0))(*)(EndLevelLayer*, float);
	static auto func = wrapFunction(base::get() + 0x133fb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EndLevelLayer::playCurrencyEffect(float p0) -> decltype(playCurrencyEffect(p0)) {
	using FunctionType = decltype(playCurrencyEffect(p0))(*)(EndLevelLayer*, float);
	static auto func = wrapFunction(base::get() + 0x134560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EndLevelLayer::playDiamondEffect(float p0) -> decltype(playDiamondEffect(p0)) {
	using FunctionType = decltype(playDiamondEffect(p0))(*)(EndLevelLayer*, float);
	static auto func = wrapFunction(base::get() + 0x1349f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EndLevelLayer::playEndEffect() -> decltype(playEndEffect()) {
	using FunctionType = decltype(playEndEffect())(*)(EndLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x134e80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EndLevelLayer::playStarEffect(float p0) -> decltype(playStarEffect(p0)) {
	using FunctionType = decltype(playStarEffect(p0))(*)(EndLevelLayer*, float);
	static auto func = wrapFunction(base::get() + 0x133ab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EndLevelLayer::starEnterFinished() -> decltype(starEnterFinished()) {
	using FunctionType = decltype(starEnterFinished())(*)(EndLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x133e50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EndPortalObject::init() -> decltype(init()) {
	throw std::runtime_error("EndPortalObject::init not implemented");
}

auto EndPortalObject::setPosition(cocos2d::CCPoint const& p0) -> decltype(setPosition(p0)) {
	throw std::runtime_error("EndPortalObject::setPosition not implemented");
}

auto EndPortalObject::setVisible(bool p0) -> decltype(setVisible(p0)) {
	throw std::runtime_error("EndPortalObject::setVisible not implemented");
}

auto EndPortalObject::getSpawnPos() -> decltype(getSpawnPos()) {
	using FunctionType = decltype(getSpawnPos())(*)(EndPortalObject*);
	static auto func = wrapFunction(base::get() + 0x136560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EndPortalObject::updateEndPos(bool p0) -> decltype(updateEndPos(p0)) {
	using FunctionType = decltype(updateEndPos(p0))(*)(EndPortalObject*, bool);
	static auto func = wrapFunction(base::get() + 0x1367d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EndTriggerGameObject::init() -> decltype(init()) {
	throw std::runtime_error("EndTriggerGameObject::init not implemented");
}

auto EndTriggerGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*, int, gd::vector<int> const*>::func(&EndTriggerGameObject::triggerObject), this);
	using FunctionType = decltype(triggerObject(p0, p1, p2))(*)(EndTriggerGameObject*, GJBaseGameLayer*, int, gd::vector<int> const*);
	static auto func = wrapFunction(base::get() + 0x4a4180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto EndTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("EndTriggerGameObject::customObjectSetup not implemented");
}

auto EndTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("EndTriggerGameObject::getSaveString not implemented");
}

auto EnhancedTriggerObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("EnhancedTriggerObject::customObjectSetup not implemented");
}

auto EnhancedTriggerObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("EnhancedTriggerObject::getSaveString not implemented");
}

auto EnterEffectObject::customSetup() -> decltype(customSetup()) {
	throw std::runtime_error("EnterEffectObject::customSetup not implemented");
}

auto EnterEffectObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("EnterEffectObject::customObjectSetup not implemented");
}

auto EnterEffectObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("EnterEffectObject::getSaveString not implemented");
}

auto EventLinkTrigger::init() -> decltype(init()) {
	throw std::runtime_error("EventLinkTrigger::init not implemented");
}

auto EventLinkTrigger::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	throw std::runtime_error("EventLinkTrigger::triggerObject not implemented");
}

auto EventLinkTrigger::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("EventLinkTrigger::customObjectSetup not implemented");
}

auto EventLinkTrigger::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("EventLinkTrigger::getSaveString not implemented");
}

auto ExplodeItemNode::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("ExplodeItemNode::update not implemented");
}

auto ExplodeItemSprite::init() -> decltype(init()) {
	throw std::runtime_error("ExplodeItemSprite::init not implemented");
}

ExtendedLayer::ExtendedLayer() {}

ExtendedLayer* ExtendedLayer::create() {
        auto ret = new ExtendedLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto ExtendedLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ExtendedLayer::init), this);
	using FunctionType = decltype(init())(*)(ExtendedLayer*);
	static auto func = wrapFunction(base::get() + 0x3ec90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ExtendedLayer::setPosition(cocos2d::CCPoint const& p0) -> decltype(setPosition(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint const&>::func(&ExtendedLayer::setPosition), this);
	using FunctionType = decltype(setPosition(p0))(*)(ExtendedLayer*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x3ecb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GManager::init), this);
	using FunctionType = decltype(init())(*)(GManager*);
	static auto func = wrapFunction(base::get() + 0x6a7c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GManager::setup() -> decltype(setup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GManager::setup), this);
	using FunctionType = decltype(setup())(*)(GManager*);
	static auto func = wrapFunction(base::get() + 0x6a7d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GManager::encodeDataTo(DS_Dictionary* p0) -> decltype(encodeDataTo(p0)) {
	throw std::runtime_error("GManager::encodeDataTo not implemented");
}

auto GManager::dataLoaded(DS_Dictionary* p0) -> decltype(dataLoaded(p0)) {
	throw std::runtime_error("GManager::dataLoaded not implemented");
}

auto GManager::firstLoad() -> decltype(firstLoad()) {
	throw std::runtime_error("GManager::firstLoad not implemented");
}

auto GManager::loadDataFromFile(gd::string const& p0) -> decltype(loadDataFromFile(p0)) {
	using FunctionType = decltype(loadDataFromFile(p0))(*)(GManager*, gd::string const&);
	static auto func = wrapFunction(base::get() + 0x6aa90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GManager::save() -> decltype(save()) {
	using FunctionType = decltype(save())(*)(GManager*);
	static auto func = wrapFunction(base::get() + 0x6a9a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FileSaveManager::init() -> decltype(init()) {
	throw std::runtime_error("FileSaveManager::init not implemented");
}

auto FileSaveManager::firstLoad() -> decltype(firstLoad()) {
	throw std::runtime_error("FileSaveManager::firstLoad not implemented");
}

auto FindBPMLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&FindBPMLayer::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(FindBPMLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x9b870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto FindBPMLayer::playMusic() -> decltype(playMusic()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FindBPMLayer::playMusic), this);
	using FunctionType = decltype(playMusic())(*)(FindBPMLayer*);
	static auto func = wrapFunction(base::get() + 0x9b6e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FindBPMLayer::registerTouch() -> decltype(registerTouch()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FindBPMLayer::registerTouch), this);
	using FunctionType = decltype(registerTouch())(*)(FindBPMLayer*);
	static auto func = wrapFunction(base::get() + 0x9b780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void FindBPMLayer::onInfo(cocos2d::CCObject* sender) {}

auto FindBPMLayer::onRecord(cocos2d::CCObject* sender) -> decltype(onRecord(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&FindBPMLayer::onRecord), this);
	using FunctionType = decltype(onRecord(sender))(*)(FindBPMLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x9b4a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto FindBPMLayer::recordingDidStop() -> decltype(recordingDidStop()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FindBPMLayer::recordingDidStop), this);
	using FunctionType = decltype(recordingDidStop())(*)(FindBPMLayer*);
	static auto func = wrapFunction(base::get() + 0x9b660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetIDPopup::create(int current, int begin, int end, gd::string title, gd::string button, bool p5, int p6, float p7, bool p8, bool p9) -> decltype(create(current, begin, end, title, button, p5, p6, p7, p8, p9)) {
	using FunctionType = decltype(create(current, begin, end, title, button, p5, p6, p7, p8, p9))(*)(int, int, int, gd::string, gd::string, bool, int, float, bool, bool);
	static auto func = wrapFunction(base::get() + 0x293bb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(current, begin, end, title, button, p5, p6, p7, p8, p9);
}

auto SetIDPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetIDPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SetIDPopup*);
	static auto func = wrapFunction(base::get() + 0x294a90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetIDPopup::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetIDPopup::show), this);
	using FunctionType = decltype(show())(*)(SetIDPopup*);
	static auto func = wrapFunction(base::get() + 0x2948c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetIDPopup::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	throw std::runtime_error("SetIDPopup::textInputClosed not implemented");
}

auto SetIDPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetIDPopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetIDPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x294710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

void SetIDPopup::valueChanged() {}

auto SetIDPopup::init(int current, int begin, int end, gd::string title, gd::string button, bool p5, int p6, float p7, bool p8, bool p9) -> decltype(init(current, begin, end, title, button, p5, p6, p7, p8, p9)) {
	using FunctionType = decltype(init(current, begin, end, title, button, p5, p6, p7, p8, p9))(*)(SetIDPopup*, int, int, int, gd::string, gd::string, bool, int, float, bool, bool);
	static auto func = wrapFunction(base::get() + 0x293ce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, current, begin, end, title, button, p5, p6, p7, p8, p9);
}

auto SetIDPopup::onCancel(cocos2d::CCObject* sender) -> decltype(onCancel(sender)) {
	using FunctionType = decltype(onCancel(sender))(*)(SetIDPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x294950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetIDPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SetIDPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2949f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetIDPopup::onItemIDArrow(cocos2d::CCObject* sender) -> decltype(onItemIDArrow(sender)) {
	using FunctionType = decltype(onItemIDArrow(sender))(*)(SetIDPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2946a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetIDPopup::onResetValue(cocos2d::CCObject* sender) -> decltype(onResetValue(sender)) {
	using FunctionType = decltype(onResetValue(sender))(*)(SetIDPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2946f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetIDPopup::updateTextInputLabel() -> decltype(updateTextInputLabel()) {
	using FunctionType = decltype(updateTextInputLabel())(*)(SetIDPopup*);
	static auto func = wrapFunction(base::get() + 0x294810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FindObjectPopup::init() -> decltype(init()) {
	throw std::runtime_error("FindObjectPopup::init not implemented");
}

void FindObjectPopup::onFindObjectID(cocos2d::CCObject* sender) {
        m_unknownBool = !m_unknownBool;
    }

FMODAudioEngine::FMODAudioEngine() : FMODAudioEngine(geode::CutoffConstructor, sizeof(FMODAudioEngine)) {
	// here we construct it as normal as we can, then destruct it
	// using the generated functions. this ensures no memory gets leaked
	// no crashes :pray:
	CCDestructor::lock(this) = true;
	FMODAudioEngine::~FMODAudioEngine();
	using FunctionType = void(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x530d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
}

FMODAudioEngine* FMODAudioEngine::get() {
        return FMODAudioEngine::sharedEngine();
    }

FMODAudioEngine* FMODAudioEngine::sharedEngine() {
        auto** instancePtr = reinterpret_cast<FMODAudioEngine**>(geode::base::get() + 0x6a4e18);
        if (!*instancePtr) {
            *instancePtr = new FMODAudioEngine();
            (*instancePtr)->init();
        }
        return *instancePtr;
    }

auto FMODAudioEngine::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&FMODAudioEngine::update), this);
	using FunctionType = decltype(update(p0))(*)(FMODAudioEngine*, float);
	static auto func = wrapFunction(base::get() + 0x55390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto FMODAudioEngine::channelForChannelID(int p0) -> decltype(channelForChannelID(p0)) {
	using FunctionType = decltype(channelForChannelID(p0))(*)(FMODAudioEngine*, int);
	static auto func = wrapFunction(base::get() + 0x58480, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FMODAudioEngine::clearAllAudio() -> decltype(clearAllAudio()) {
	using FunctionType = decltype(clearAllAudio())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x552e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

int FMODAudioEngine::countActiveEffects() {
        return m_channelIDToChannel.size() - countActiveMusic();
    }

int FMODAudioEngine::countActiveMusic() {
        int count = 0;
        for (auto& music : m_musicChannels) {
            if (music.second.m_channelID > 0) {
                ++count;
            }
        }
        return count;
    }

void FMODAudioEngine::disableMetering() {
        this->m_metering = false;
    }

void FMODAudioEngine::enableMetering() {
        this->m_metering = true;
        this->m_pulse1 = 0.1f;
        this->m_pulse2 = 0.1f;
        this->m_pulse3 = 0.0f;
    }

auto FMODAudioEngine::fadeInMusic(float p0, int p1) -> decltype(fadeInMusic(p0, p1)) {
	using FunctionType = decltype(fadeInMusic(p0, p1))(*)(FMODAudioEngine*, float, int);
	static auto func = wrapFunction(base::get() + 0x5c3c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto FMODAudioEngine::fadeOutMusic(float p0, int p1) -> decltype(fadeOutMusic(p0, p1)) {
	using FunctionType = decltype(fadeOutMusic(p0, p1))(*)(FMODAudioEngine*, float, int);
	static auto func = wrapFunction(base::get() + 0x5c500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

FMOD::Channel* FMODAudioEngine::getActiveMusicChannel(int musicChannel) {
        // TODO: this might do other checks or whatever but i cant be bothered
        return m_channelIDToChannel[m_musicChannels[musicChannel].m_channelID];
    }

float FMODAudioEngine::getBackgroundMusicVolume() {
        return m_musicVolume;
    }

auto FMODAudioEngine::getChannelGroup(int p0, bool p1) -> decltype(getChannelGroup(p0, p1)) {
	using FunctionType = decltype(getChannelGroup(p0, p1))(*)(FMODAudioEngine*, int, bool);
	static auto func = wrapFunction(base::get() + 0x56b20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

float FMODAudioEngine::getEffectsVolume() {
        return m_sfxVolume;
    }

auto FMODAudioEngine::getFMODStatus(int p0) -> decltype(getFMODStatus(p0)) {
	using FunctionType = decltype(getFMODStatus(p0))(*)(FMODAudioEngine*, int);
	static auto func = wrapFunction(base::get() + 0x5cdb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FMODAudioEngine::getMusicLengthMS(int channel) -> decltype(getMusicLengthMS(channel)) {
	using FunctionType = decltype(getMusicLengthMS(channel))(*)(FMODAudioEngine*, int);
	static auto func = wrapFunction(base::get() + 0x5c330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, channel);
}

auto FMODAudioEngine::getMusicTimeMS(int channel) -> decltype(getMusicTimeMS(channel)) {
	using FunctionType = decltype(getMusicTimeMS(channel))(*)(FMODAudioEngine*, int);
	static auto func = wrapFunction(base::get() + 0x5c2d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, channel);
}

auto FMODAudioEngine::isMusicPlaying(gd::string path, int p1) -> decltype(isMusicPlaying(path, p1)) {
	using FunctionType = decltype(isMusicPlaying(path, p1))(*)(FMODAudioEngine*, gd::string, int);
	static auto func = wrapFunction(base::get() + 0x59ee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, path, p1);
}

auto FMODAudioEngine::isMusicPlaying(int channel) -> decltype(isMusicPlaying(channel)) {
	using FunctionType = decltype(isMusicPlaying(channel))(*)(FMODAudioEngine*, int);
	static auto func = wrapFunction(base::get() + 0x59d00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, channel);
}

auto FMODAudioEngine::loadMusic(gd::string path, float speed, float p2, float volume, bool shouldLoop, int p5, int p6) -> decltype(loadMusic(path, speed, p2, volume, shouldLoop, p5, p6)) {
	using FunctionType = decltype(loadMusic(path, speed, p2, volume, shouldLoop, p5, p6))(*)(FMODAudioEngine*, gd::string, float, float, float, bool, int, int);
	static auto func = wrapFunction(base::get() + 0x5a280, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, path, speed, p2, volume, shouldLoop, p5, p6);
}

void FMODAudioEngine::loadMusic(gd::string path) {
        this->loadMusic(path, 1.f, 0.f, 1.f, false, 0, 0);
    }

void FMODAudioEngine::pauseAllAudio() {
        if (m_allAudioPaused) return;
        m_allAudioPaused = true;
        m_backgroundMusicChannel->setPaused(true);
        m_globalChannel->setPaused(true);
    }

void FMODAudioEngine::pauseAllEffects() {
        m_globalChannel->setPaused(true);
    }

void FMODAudioEngine::pauseAllMusic(bool force) {
        for (auto& [id, channel] : m_musicChannels) {
            if (force || !channel.m_unkBool2) {
                if (auto ch = this->channelForChannelID(channel.m_channelID))
                    ch->setPaused(true);
            }
        }
    }

void FMODAudioEngine::pauseMusic(int musicChannel) {
        auto* channel = this->getActiveMusicChannel(musicChannel);
        if (channel)
            channel->setPaused(true);
    }

auto FMODAudioEngine::playEffect(gd::string path, float speed, float p2, float volume) -> decltype(playEffect(path, speed, p2, volume)) {
	using FunctionType = decltype(playEffect(path, speed, p2, volume))(*)(FMODAudioEngine*, gd::string, float, float, float);
	static auto func = wrapFunction(base::get() + 0x56e10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, path, speed, p2, volume);
}

auto FMODAudioEngine::playEffect(gd::string path) -> decltype(playEffect(path)) {
	using FunctionType = decltype(playEffect(path))(*)(FMODAudioEngine*, gd::string);
	static auto func = wrapFunction(base::get() + 0x56d90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, path);
}

auto FMODAudioEngine::playEffectAdvanced(gd::string path, float speed, float p2, float volume, float pitch, bool fastFourierTransform, bool reverb, int startMillis, int endMillis, int fadeIn, int fadeOut, bool loopEnabled, int p12, bool override, bool p14, int p15, int uniqueID, float minInterval, int sfxGroup) -> decltype(playEffectAdvanced(path, speed, p2, volume, pitch, fastFourierTransform, reverb, startMillis, endMillis, fadeIn, fadeOut, loopEnabled, p12, override, p14, p15, uniqueID, minInterval, sfxGroup)) {
	using FunctionType = decltype(playEffectAdvanced(path, speed, p2, volume, pitch, fastFourierTransform, reverb, startMillis, endMillis, fadeIn, fadeOut, loopEnabled, p12, override, p14, p15, uniqueID, minInterval, sfxGroup))(*)(FMODAudioEngine*, gd::string, float, float, float, float, bool, bool, int, int, int, int, bool, int, bool, bool, int, int, float, int);
	static auto func = wrapFunction(base::get() + 0x56f00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, path, speed, p2, volume, pitch, fastFourierTransform, reverb, startMillis, endMillis, fadeIn, fadeOut, loopEnabled, p12, override, p14, p15, uniqueID, minInterval, sfxGroup);
}

auto FMODAudioEngine::playMusic(gd::string path, bool shouldLoop, float fadeInTime, int channel) -> decltype(playMusic(path, shouldLoop, fadeInTime, channel)) {
	using FunctionType = decltype(playMusic(path, shouldLoop, fadeInTime, channel))(*)(FMODAudioEngine*, gd::string, bool, float, int);
	static auto func = wrapFunction(base::get() + 0x5a110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, path, shouldLoop, fadeInTime, channel);
}

auto FMODAudioEngine::preloadEffect(gd::string path) -> decltype(preloadEffect(path)) {
	using FunctionType = decltype(preloadEffect(path))(*)(FMODAudioEngine*, gd::string);
	static auto func = wrapFunction(base::get() + 0x59260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, path);
}

auto FMODAudioEngine::preloadMusic(gd::string path, bool p1, int p2) -> decltype(preloadMusic(path, p1, p2)) {
	using FunctionType = decltype(preloadMusic(path, p1, p2))(*)(FMODAudioEngine*, gd::string, bool, int);
	static auto func = wrapFunction(base::get() + 0x5c790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, path, p1, p2);
}

auto FMODAudioEngine::queuePlayEffect(gd::string p0, float p1, float p2, float p3, float p4, bool p5, bool p6, int p7, int p8, int p9, int p10, bool p11, int p12, bool p13, int p14, float p15, int p16) -> decltype(queuePlayEffect(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16)) {
	using FunctionType = decltype(queuePlayEffect(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16))(*)(FMODAudioEngine*, gd::string, float, float, float, float, bool, bool, int, int, int, int, bool, int, bool, int, float, int);
	static auto func = wrapFunction(base::get() + 0x57920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16);
}

auto FMODAudioEngine::queueStartMusic(gd::string audioFilename, float p1, float p2, float p3, bool p4, int ms, int p6, int p7, int p8, int p9, bool p10, int p11, bool p12, bool p13) -> decltype(queueStartMusic(audioFilename, p1, p2, p3, p4, ms, p6, p7, p8, p9, p10, p11, p12, p13)) {
	using FunctionType = decltype(queueStartMusic(audioFilename, p1, p2, p3, p4, ms, p6, p7, p8, p9, p10, p11, p12, p13))(*)(FMODAudioEngine*, gd::string, float, float, float, bool, int, int, int, int, int, bool, int, bool, bool);
	static auto func = wrapFunction(base::get() + 0x5aa70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, audioFilename, p1, p2, p3, p4, ms, p6, p7, p8, p9, p10, p11, p12, p13);
}

void FMODAudioEngine::resumeAllAudio() {
        if (!m_allAudioPaused) return;
        m_allAudioPaused = false;
        m_backgroundMusicChannel->setPaused(false);
        m_globalChannel->setPaused(false);
    }

void FMODAudioEngine::resumeAllEffects() {
        m_globalChannel->setPaused(false);
    }

auto FMODAudioEngine::resumeAllMusic() -> decltype(resumeAllMusic()) {
	using FunctionType = decltype(resumeAllMusic())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x59e80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void FMODAudioEngine::resumeAudio() {
        this->start();
    }

void FMODAudioEngine::resumeEffect(unsigned int p0) {}

void FMODAudioEngine::resumeMusic(int musicChannel) {
        auto* channel = this->getActiveMusicChannel(musicChannel);
        if (channel)
            channel->setPaused(false);
    }

auto FMODAudioEngine::saveAudioState(FMODAudioState& p0) -> decltype(saveAudioState(p0)) {
	using FunctionType = decltype(saveAudioState(p0))(*)(FMODAudioEngine*, FMODAudioState&);
	static auto func = wrapFunction(base::get() + 0x558f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void FMODAudioEngine::setBackgroundMusicVolume(float volume) {
        m_musicVolume = volume;
        if (m_backgroundMusicChannel) m_backgroundMusicChannel->setVolume(volume);
    }

auto FMODAudioEngine::setChannelVolumeMod(int p0, AudioTargetType p1, float p2) -> decltype(setChannelVolumeMod(p0, p1, p2)) {
	using FunctionType = decltype(setChannelVolumeMod(p0, p1, p2))(*)(FMODAudioEngine*, int, AudioTargetType, float);
	static auto func = wrapFunction(base::get() + 0x58f80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

void FMODAudioEngine::setEffectsVolume(float volume) {
        m_sfxVolume = volume;
        if (m_globalChannel) m_globalChannel->setVolume(volume);
    }

auto FMODAudioEngine::setMusicTimeMS(unsigned int p0, bool p1, int p2) -> decltype(setMusicTimeMS(p0, p1, p2)) {
	using FunctionType = decltype(setMusicTimeMS(p0, p1, p2))(*)(FMODAudioEngine*, unsigned int, bool, int);
	static auto func = wrapFunction(base::get() + 0x5c190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto FMODAudioEngine::setup() -> decltype(setup()) {
	using FunctionType = decltype(setup())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x53bc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FMODAudioEngine::setupAudioEngine() -> decltype(setupAudioEngine()) {
	using FunctionType = decltype(setupAudioEngine())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x540a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FMODAudioEngine::start() -> decltype(start()) {
	using FunctionType = decltype(start())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x55280, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FMODAudioEngine::stopAllEffects() -> decltype(stopAllEffects()) {
	using FunctionType = decltype(stopAllEffects())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x598b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FMODAudioEngine::stopAllMusic(bool p0) -> decltype(stopAllMusic(p0)) {
	using FunctionType = decltype(stopAllMusic(p0))(*)(FMODAudioEngine*, bool);
	static auto func = wrapFunction(base::get() + 0x59d70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FMODAudioEngine::stopChannel(FMOD::Channel* p0, bool p1, float p2) -> decltype(stopChannel(p0, p1, p2)) {
	using FunctionType = decltype(stopChannel(p0, p1, p2))(*)(FMODAudioEngine*, FMOD::Channel*, bool, float);
	static auto func = wrapFunction(base::get() + 0x58810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto FMODAudioEngine::storeEffect(FMOD::Sound* sound, gd::string path) -> decltype(storeEffect(sound, path)) {
	using FunctionType = decltype(storeEffect(sound, path))(*)(FMODAudioEngine*, FMOD::Sound*, gd::string);
	static auto func = wrapFunction(base::get() + 0x59510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sound, path);
}

auto FMODAudioEngine::unloadAllEffects() -> decltype(unloadAllEffects()) {
	using FunctionType = decltype(unloadAllEffects())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x59aa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FMODAudioEngine::updateQueuedEffects() -> decltype(updateQueuedEffects()) {
	using FunctionType = decltype(updateQueuedEffects())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x5aec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FMODAudioEngine::updateReverb(FMODReverbPreset p0, bool p1) -> decltype(updateReverb(p0, p1)) {
	using FunctionType = decltype(updateReverb(p0, p1))(*)(FMODAudioEngine*, FMODReverbPreset, bool);
	static auto func = wrapFunction(base::get() + 0x54400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto FMODAudioEngine::updateTemporaryEffects() -> decltype(updateTemporaryEffects()) {
	using FunctionType = decltype(updateTemporaryEffects())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x5b410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FMODLevelVisualizer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x297150, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto FMODLevelVisualizer::init() -> decltype(init()) {
	throw std::runtime_error("FMODLevelVisualizer::init not implemented");
}

auto FMODLevelVisualizer::updateVisualizer(float p0, float p1, float p2) -> decltype(updateVisualizer(p0, p1, p2)) {
	using FunctionType = decltype(updateVisualizer(p0, p1, p2))(*)(FMODLevelVisualizer*, float, float, float);
	static auto func = wrapFunction(base::get() + 0x297690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameRateDelegate::updateRate() -> decltype(updateRate()) {
	throw std::runtime_error("GameRateDelegate::updateRate not implemented");
}

auto RewardedVideoDelegate::rewardedVideoFinished() -> decltype(rewardedVideoFinished()) {
	throw std::runtime_error("RewardedVideoDelegate::rewardedVideoFinished not implemented");
}

auto RewardedVideoDelegate::shouldOffsetRewardCurrency() -> decltype(shouldOffsetRewardCurrency()) {
	throw std::runtime_error("RewardedVideoDelegate::shouldOffsetRewardCurrency not implemented");
}

auto FollowRewardPage::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x137fc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto FollowRewardPage::init() -> decltype(init()) {
	throw std::runtime_error("FollowRewardPage::init not implemented");
}

auto FollowRewardPage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("FollowRewardPage::registerWithTouchDispatcher not implemented");
}

auto FollowRewardPage::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("FollowRewardPage::keyBackClicked not implemented");
}

auto FollowRewardPage::show() -> decltype(show()) {
	throw std::runtime_error("FollowRewardPage::show not implemented");
}

auto FollowRewardPage::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&FollowRewardPage::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(FollowRewardPage*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x13b5f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FollowRewardPage::rewardedVideoFinished() -> decltype(rewardedVideoFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FollowRewardPage::rewardedVideoFinished), this);
	using FunctionType = decltype(rewardedVideoFinished())(*)(FollowRewardPage*);
	static auto func = wrapFunction(base::get() + 0x13a330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FollowRewardPage::updateRate() -> decltype(updateRate()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FollowRewardPage::updateRate), this);
	using FunctionType = decltype(updateRate())(*)(FollowRewardPage*);
	static auto func = wrapFunction(base::get() + 0x139e00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FollowRewardPage::onSpecialItem(cocos2d::CCObject* sender) -> decltype(onSpecialItem(sender)) {
	using FunctionType = decltype(onSpecialItem(sender))(*)(FollowRewardPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x13a340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto FollowRewardPage::switchToOpenedState(CCMenuItemSpriteExtra* p0) -> decltype(switchToOpenedState(p0)) {
	using FunctionType = decltype(switchToOpenedState(p0))(*)(FollowRewardPage*, CCMenuItemSpriteExtra*);
	static auto func = wrapFunction(base::get() + 0x13b510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

FontObject::FontObject() {}

FontObject* FontObject::createWithConfigFile(char const* p0, float p1) {
        auto ret = new FontObject();
        if (ret->initWithConfigFile(p0, p1)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

int FontObject::getFontWidth(int p0) {
        return m_hugeIntArray[p0];
    }

bool FontObject::initWithConfigFile(char const* p0, float p1) {
        this->parseConfigFile(p0, p1);
        return true;
    }

auto FontObject::parseConfigFile(char const* p0, float p1) -> decltype(parseConfigFile(p0, p1)) {
	using FunctionType = decltype(parseConfigFile(p0, p1))(*)(FontObject*, char const*, float);
	static auto func = wrapFunction(base::get() + 0x3b620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto ForceBlockGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("ForceBlockGameObject::customObjectSetup not implemented");
}

auto ForceBlockGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("ForceBlockGameObject::getSaveString not implemented");
}

auto FriendRequestDelegate::loadFRequestsFinished(cocos2d::CCArray* p0, char const* p1) -> decltype(loadFRequestsFinished(p0, p1)) {
	throw std::runtime_error("FriendRequestDelegate::loadFRequestsFinished not implemented");
}

auto FriendRequestDelegate::loadFRequestsFailed(char const* p0, GJErrorCode p1) -> decltype(loadFRequestsFailed(p0, p1)) {
	throw std::runtime_error("FriendRequestDelegate::loadFRequestsFailed not implemented");
}

auto FriendRequestDelegate::setupPageInfo(gd::string p0, char const* p1) -> decltype(setupPageInfo(p0, p1)) {
	throw std::runtime_error("FriendRequestDelegate::setupPageInfo not implemented");
}

auto FriendRequestDelegate::forceReloadRequests(bool p0) -> decltype(forceReloadRequests(p0)) {
	throw std::runtime_error("FriendRequestDelegate::forceReloadRequests not implemented");
}

auto FRequestProfilePage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("FRequestProfilePage::registerWithTouchDispatcher not implemented");
}

auto FRequestProfilePage::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FRequestProfilePage::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(FRequestProfilePage*);
	static auto func = wrapFunction(base::get() + 0x13d290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FRequestProfilePage::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&FRequestProfilePage::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(FRequestProfilePage*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x13d070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FRequestProfilePage::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&FRequestProfilePage::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(FRequestProfilePage*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x13d2a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto FRequestProfilePage::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&FRequestProfilePage::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(p0, p1))(*)(FRequestProfilePage*, int, int);
	static auto func = wrapFunction(base::get() + 0x13d2f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FRequestProfilePage::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&FRequestProfilePage::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(p0, p1))(*)(FRequestProfilePage*, int, int);
	static auto func = wrapFunction(base::get() + 0x13d460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FRequestProfilePage::loadFRequestsFinished(cocos2d::CCArray* p0, char const* p1) -> decltype(loadFRequestsFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*, char const*>::func(&FRequestProfilePage::loadFRequestsFinished), this);
	using FunctionType = decltype(loadFRequestsFinished(p0, p1))(*)(FRequestProfilePage*, cocos2d::CCArray*, char const*);
	static auto func = wrapFunction(base::get() + 0x13dbd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FRequestProfilePage::loadFRequestsFailed(char const* p0, GJErrorCode p1) -> decltype(loadFRequestsFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<char const*, GJErrorCode>::func(&FRequestProfilePage::loadFRequestsFailed), this);
	using FunctionType = decltype(loadFRequestsFailed(p0, p1))(*)(FRequestProfilePage*, char const*, GJErrorCode);
	static auto func = wrapFunction(base::get() + 0x13dc50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FRequestProfilePage::setupPageInfo(gd::string p0, char const* p1) -> decltype(setupPageInfo(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string, char const*>::func(&FRequestProfilePage::setupPageInfo), this);
	using FunctionType = decltype(setupPageInfo(p0, p1))(*)(FRequestProfilePage*, gd::string, char const*);
	static auto func = wrapFunction(base::get() + 0x13dcf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FRequestProfilePage::forceReloadRequests(bool p0) -> decltype(forceReloadRequests(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&FRequestProfilePage::forceReloadRequests), this);
	using FunctionType = decltype(forceReloadRequests(p0))(*)(FRequestProfilePage*, bool);
	static auto func = wrapFunction(base::get() + 0x13dcd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto FRequestProfilePage::init(bool p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(FRequestProfilePage*, bool);
	static auto func = wrapFunction(base::get() + 0x13be30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FRequestProfilePage::setupCommentsBrowser(cocos2d::CCArray* p0) -> decltype(setupCommentsBrowser(p0)) {
	using FunctionType = decltype(setupCommentsBrowser(p0))(*)(FRequestProfilePage*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x13da30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FriendRequestPopup::create(GJFriendRequest* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(GJFriendRequest*);
	static auto func = wrapFunction(base::get() + 0x28e370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto FriendRequestPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FriendRequestPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(FriendRequestPopup*);
	static auto func = wrapFunction(base::get() + 0x28f950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FriendRequestPopup::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&FriendRequestPopup::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(p0, p1))(*)(FriendRequestPopup*, int, int);
	static auto func = wrapFunction(base::get() + 0x28f960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FriendRequestPopup::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&FriendRequestPopup::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(p0, p1))(*)(FriendRequestPopup*, int, int);
	static auto func = wrapFunction(base::get() + 0x28fb10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FriendRequestPopup::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&FriendRequestPopup::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(FriendRequestPopup*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x28fbd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto FriendRequestPopup::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&FriendRequestPopup::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(FriendRequestPopup*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x28fc30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FriendRequestPopup::init(GJFriendRequest* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(FriendRequestPopup*, GJFriendRequest*);
	static auto func = wrapFunction(base::get() + 0x28e4b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FriendRequestPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(FriendRequestPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x28f440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto UserListDelegate::getUserListFinished(cocos2d::CCArray* p0, UserListType p1) -> decltype(getUserListFinished(p0, p1)) {
	throw std::runtime_error("UserListDelegate::getUserListFinished not implemented");
}

auto UserListDelegate::getUserListFailed(UserListType p0, GJErrorCode p1) -> decltype(getUserListFailed(p0, p1)) {
	throw std::runtime_error("UserListDelegate::getUserListFailed not implemented");
}

auto UserListDelegate::userListChanged(cocos2d::CCArray* p0, UserListType p1) -> decltype(userListChanged(p0, p1)) {
	throw std::runtime_error("UserListDelegate::userListChanged not implemented");
}

auto UserListDelegate::forceReloadList(UserListType p0) -> decltype(forceReloadList(p0)) {
	throw std::runtime_error("UserListDelegate::forceReloadList not implemented");
}

auto FriendsProfilePage::create(UserListType p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(UserListType);
	static auto func = wrapFunction(base::get() + 0x13e010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto FriendsProfilePage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("FriendsProfilePage::registerWithTouchDispatcher not implemented");
}

auto FriendsProfilePage::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FriendsProfilePage::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(FriendsProfilePage*);
	static auto func = wrapFunction(base::get() + 0x13f0a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FriendsProfilePage::getUserListFinished(cocos2d::CCArray* p0, UserListType p1) -> decltype(getUserListFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*, UserListType>::func(&FriendsProfilePage::getUserListFinished), this);
	using FunctionType = decltype(getUserListFinished(p0, p1))(*)(FriendsProfilePage*, cocos2d::CCArray*, UserListType);
	static auto func = wrapFunction(base::get() + 0x13ebd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FriendsProfilePage::getUserListFailed(UserListType p0, GJErrorCode p1) -> decltype(getUserListFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<UserListType, GJErrorCode>::func(&FriendsProfilePage::getUserListFailed), this);
	using FunctionType = decltype(getUserListFailed(p0, p1))(*)(FriendsProfilePage*, UserListType, GJErrorCode);
	static auto func = wrapFunction(base::get() + 0x13ed20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FriendsProfilePage::userListChanged(cocos2d::CCArray* p0, UserListType p1) -> decltype(userListChanged(p0, p1)) {
	throw std::runtime_error("FriendsProfilePage::userListChanged not implemented");
}

auto FriendsProfilePage::forceReloadList(UserListType p0) -> decltype(forceReloadList(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UserListType>::func(&FriendsProfilePage::forceReloadList), this);
	using FunctionType = decltype(forceReloadList(p0))(*)(FriendsProfilePage*, UserListType);
	static auto func = wrapFunction(base::get() + 0x13ed90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto FriendsProfilePage::init(UserListType type) -> decltype(init(type)) {
	using FunctionType = decltype(init(type))(*)(FriendsProfilePage*, UserListType);
	static auto func = wrapFunction(base::get() + 0x13e160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, type);
}

auto FriendsProfilePage::onBlocked(cocos2d::CCObject* sender) -> decltype(onBlocked(sender)) {
	using FunctionType = decltype(onBlocked(sender))(*)(FriendsProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x13ef50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto FriendsProfilePage::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(FriendsProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x13efe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto FriendsProfilePage::setupUsersBrowser(cocos2d::CCArray* users, UserListType type) -> decltype(setupUsersBrowser(users, type)) {
	using FunctionType = decltype(setupUsersBrowser(users, type))(*)(FriendsProfilePage*, cocos2d::CCArray*, UserListType);
	static auto func = wrapFunction(base::get() + 0x13e870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, users, type);
}

auto GameCell::init() -> decltype(init()) {
	throw std::runtime_error("GameCell::init not implemented");
}

auto GameCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameCell::draw), this);
	using FunctionType = decltype(draw())(*)(GameCell*);
	static auto func = wrapFunction(base::get() + 0x3cbf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

GameLevelManager* GameLevelManager::get() {
        return GameLevelManager::sharedState();
    }

auto GameLevelManager::responseToDict(gd::string p0, bool p1) -> decltype(responseToDict(p0, p1)) {
	using FunctionType = decltype(responseToDict(p0, p1))(*)(gd::string, bool);
	static auto func = wrapFunction(base::get() + 0x168140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GameLevelManager::sharedState() -> decltype(sharedState()) {
	using FunctionType = decltype(sharedState())(*)();
	static auto func = wrapFunction(base::get() + 0x140b20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GameLevelManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameLevelManager::init), this);
	using FunctionType = decltype(init())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0x142230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameLevelManager::addDLToActive(char const* p0) -> decltype(addDLToActive(p0)) {
	using FunctionType = decltype(addDLToActive(p0))(*)(GameLevelManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x147a20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::cleanupDailyLevels() -> decltype(cleanupDailyLevels()) {
	using FunctionType = decltype(cleanupDailyLevels())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0x1485e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameLevelManager::createNewLevel() -> decltype(createNewLevel()) {
	using FunctionType = decltype(createNewLevel())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0x142800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameLevelManager::createNewLevelList() -> decltype(createNewLevelList()) {
	using FunctionType = decltype(createNewLevelList())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0x1432b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameLevelManager::dataLoaded(DS_Dictionary* p0) -> decltype(dataLoaded(p0)) {
	using FunctionType = decltype(dataLoaded(p0))(*)(GameLevelManager*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x149310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::deleteFriendRequests(int p0, cocos2d::CCArray* p1, bool p2) -> decltype(deleteFriendRequests(p0, p1, p2)) {
	using FunctionType = decltype(deleteFriendRequests(p0, p1, p2))(*)(GameLevelManager*, int, cocos2d::CCArray*, bool);
	static auto func = wrapFunction(base::get() + 0x15e180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameLevelManager::deleteLevel(GJGameLevel* p0) -> decltype(deleteLevel(p0)) {
	using FunctionType = decltype(deleteLevel(p0))(*)(GameLevelManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x142fe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::deleteLevelList(GJLevelList* p0) -> decltype(deleteLevelList(p0)) {
	using FunctionType = decltype(deleteLevelList(p0))(*)(GameLevelManager*, GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x143890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::deleteServerLevel(int p0) -> decltype(deleteServerLevel(p0)) {
	using FunctionType = decltype(deleteServerLevel(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x152350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::deleteUserMessages(GJUserMessage* message, cocos2d::CCArray* messages, bool isSender) -> decltype(deleteUserMessages(message, messages, isSender)) {
	using FunctionType = decltype(deleteUserMessages(message, messages, isSender))(*)(GameLevelManager*, GJUserMessage*, cocos2d::CCArray*, bool);
	static auto func = wrapFunction(base::get() + 0x158f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, message, messages, isSender);
}

auto GameLevelManager::downloadLevel(int p0, bool p1) -> decltype(downloadLevel(p0, p1)) {
	using FunctionType = decltype(downloadLevel(p0, p1))(*)(GameLevelManager*, int, bool);
	static auto func = wrapFunction(base::get() + 0x14fde0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::encodeDataTo(DS_Dictionary* p0) -> decltype(encodeDataTo(p0)) {
	using FunctionType = decltype(encodeDataTo(p0))(*)(GameLevelManager*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x148e00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

char const* GameLevelManager::getAccountCommentKey(int p0, int p1) {
        return cocos2d::CCString::createWithFormat("%i_%i", p0, p1)->getCString();
    }

auto GameLevelManager::getBasePostString() -> decltype(getBasePostString()) {
	using FunctionType = decltype(getBasePostString())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0x14a4b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

bool GameLevelManager::getBoolForKey(char const* key) {
        return m_searchFilters->valueForKey(key)->boolValue();
    }

gd::string GameLevelManager::getCommentKey(int ID, int page, int mode, CommentKeyType keytype) {
        return cocos2d::CCString::createWithFormat("comment_%i_%i_%i_%i", ID, page, mode, (int) keytype)->getCString();
    }

auto GameLevelManager::getCompletedLevels(bool p0) -> decltype(getCompletedLevels(p0)) {
	using FunctionType = decltype(getCompletedLevels(p0))(*)(GameLevelManager*, bool);
	static auto func = wrapFunction(base::get() + 0x145860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getFolderName(int p0, bool p1) -> decltype(getFolderName(p0, p1)) {
	using FunctionType = decltype(getFolderName(p0, p1))(*)(GameLevelManager*, int, bool);
	static auto func = wrapFunction(base::get() + 0x148910, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::getGJChallenges() -> decltype(getGJChallenges()) {
	using FunctionType = decltype(getGJChallenges())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0x164ad0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameLevelManager::getGJDailyLevelState(GJTimedLevelType p0) -> decltype(getGJDailyLevelState(p0)) {
	using FunctionType = decltype(getGJDailyLevelState(p0))(*)(GameLevelManager*, GJTimedLevelType);
	static auto func = wrapFunction(base::get() + 0x165ec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getGJRewards(int p0) -> decltype(getGJRewards(p0)) {
	using FunctionType = decltype(getGJRewards(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x1635e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getGJUserInfo(int p0) -> decltype(getGJUserInfo(p0)) {
	using FunctionType = decltype(getGJUserInfo(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x157880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

int GameLevelManager::getIntForKey(char const* key) {
        return m_searchFilters->valueForKey(key)->intValue();
    }

auto GameLevelManager::getLeaderboardScores(char const* p0) -> decltype(getLeaderboardScores(p0)) {
	using FunctionType = decltype(getLeaderboardScores(p0))(*)(GameLevelManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x1554b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getLevelComments(int ID, int page, int total, int mode, CommentKeyType keytype) -> decltype(getLevelComments(ID, page, total, mode, keytype)) {
	using FunctionType = decltype(getLevelComments(ID, page, total, mode, keytype))(*)(GameLevelManager*, int, int, int, int, CommentKeyType);
	static auto func = wrapFunction(base::get() + 0x159870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, ID, page, total, mode, keytype);
}

const char* GameLevelManager::getLevelDownloadKey(int levelID, bool isGauntlet) {
        return cocos2d::CCString::createWithFormat("%i_%i", levelID, isGauntlet)->getCString();
    }

const char* GameLevelManager::getLevelKey(int levelID) {
        return cocos2d::CCString::createWithFormat("%i", levelID)->getCString();
    }

auto GameLevelManager::getLevelLeaderboard(GJGameLevel* p0, LevelLeaderboardType p1, LevelLeaderboardMode p2) -> decltype(getLevelLeaderboard(p0, p1, p2)) {
	using FunctionType = decltype(getLevelLeaderboard(p0, p1, p2))(*)(GameLevelManager*, GJGameLevel*, LevelLeaderboardType, LevelLeaderboardMode);
	static auto func = wrapFunction(base::get() + 0x155ff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameLevelManager::getLevelLists(GJSearchObject* p0) -> decltype(getLevelLists(p0)) {
	using FunctionType = decltype(getLevelLists(p0))(*)(GameLevelManager*, GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0x14e6e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getLevelSaveData() -> decltype(getLevelSaveData()) {
	using FunctionType = decltype(getLevelSaveData())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0x14cd40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameLevelManager::getMainLevel(int levelID, bool dontGetLevelString) -> decltype(getMainLevel(levelID, dontGetLevelString)) {
	using FunctionType = decltype(getMainLevel(levelID, dontGetLevelString))(*)(GameLevelManager*, int, bool);
	static auto func = wrapFunction(base::get() + 0x1423e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, levelID, dontGetLevelString);
}

auto GameLevelManager::getMapPacks(GJSearchObject* p0) -> decltype(getMapPacks(p0)) {
	using FunctionType = decltype(getMapPacks(p0))(*)(GameLevelManager*, GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0x14d470, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getOnlineLevels(GJSearchObject* p0) -> decltype(getOnlineLevels(p0)) {
	using FunctionType = decltype(getOnlineLevels(p0))(*)(GameLevelManager*, GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0x14bb70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getSavedDailyLevel(int p0) -> decltype(getSavedDailyLevel(p0)) {
	using FunctionType = decltype(getSavedDailyLevel(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x146ba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getSavedGauntletLevel(int p0) -> decltype(getSavedGauntletLevel(p0)) {
	using FunctionType = decltype(getSavedGauntletLevel(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x146c70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

GJGameLevel* GameLevelManager::getSavedLevel(GJGameLevel* level) {
        if (!level) return nullptr;
        else if (level->m_dailyID.value() > 0) return this->getSavedDailyLevel(level->m_dailyID.value());
        else if (level->m_gauntletLevel) return this->getSavedGauntletLevel(level->m_levelID.value());
        else return this->getSavedLevel(level->m_levelID.value());
    }

auto GameLevelManager::getSavedLevel(int p0) -> decltype(getSavedLevel(p0)) {
	using FunctionType = decltype(getSavedLevel(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x146ad0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getSavedLevels(bool p0, int p1) -> decltype(getSavedLevels(p0, p1)) {
	using FunctionType = decltype(getSavedLevels(p0, p1))(*)(GameLevelManager*, bool, int);
	static auto func = wrapFunction(base::get() + 0x145410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::getStoredLevelComments(char const* p0) -> decltype(getStoredLevelComments(p0)) {
	using FunctionType = decltype(getStoredLevelComments(p0))(*)(GameLevelManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x15b420, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getStoredOnlineLevels(char const* p0) -> decltype(getStoredOnlineLevels(p0)) {
	using FunctionType = decltype(getStoredOnlineLevels(p0))(*)(GameLevelManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x147780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getTimeLeft(char const* p0, float p1) -> decltype(getTimeLeft(p0, p1)) {
	using FunctionType = decltype(getTimeLeft(p0, p1))(*)(GameLevelManager*, char const*, float);
	static auto func = wrapFunction(base::get() + 0x147dd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

const char* GameLevelManager::getTopArtistsKey(int page) {
        return cocos2d::CCString::createWithFormat("topArtists_%i", page)->getCString();
    }

auto GameLevelManager::getUserList(UserListType p0) -> decltype(getUserList(p0)) {
	using FunctionType = decltype(getUserList(p0))(*)(GameLevelManager*, UserListType);
	static auto func = wrapFunction(base::get() + 0x15ffa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getUsers(GJSearchObject* p0) -> decltype(getUsers(p0)) {
	using FunctionType = decltype(getUsers(p0))(*)(GameLevelManager*, GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0x1571c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::gotoLevelPage(GJGameLevel* p0) -> decltype(gotoLevelPage(p0)) {
	using FunctionType = decltype(gotoLevelPage(p0))(*)(GameLevelManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x1473c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::handleIt(bool p0, gd::string p1, gd::string p2, GJHttpType p3) -> decltype(handleIt(p0, p1, p2, p3)) {
	using FunctionType = decltype(handleIt(p0, p1, p2, p3))(*)(GameLevelManager*, bool, gd::string, gd::string, GJHttpType);
	static auto func = wrapFunction(base::get() + 0x140e00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GameLevelManager::hasLikedItem(LikeItemType p0, int p1, bool p2, int p3) -> decltype(hasLikedItem(p0, p1, p2, p3)) {
	using FunctionType = decltype(hasLikedItem(p0, p1, p2, p3))(*)(GameLevelManager*, LikeItemType, int, bool, int);
	static auto func = wrapFunction(base::get() + 0x1623d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GameLevelManager::hasLikedItemFullCheck(LikeItemType p0, int p1, int p2) -> decltype(hasLikedItemFullCheck(p0, p1, p2)) {
	using FunctionType = decltype(hasLikedItemFullCheck(p0, p1, p2))(*)(GameLevelManager*, LikeItemType, int, int);
	static auto func = wrapFunction(base::get() + 0x162340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameLevelManager::invalidateUserList(UserListType p0, bool p1) -> decltype(invalidateUserList(p0, p1)) {
	using FunctionType = decltype(invalidateUserList(p0, p1))(*)(GameLevelManager*, UserListType, bool);
	static auto func = wrapFunction(base::get() + 0x160840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::isFollowingUser(int p0) -> decltype(isFollowingUser(p0)) {
	using FunctionType = decltype(isFollowingUser(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x148840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::isTimeValid(char const* p0, float p1) -> decltype(isTimeValid(p0, p1)) {
	using FunctionType = decltype(isTimeValid(p0, p1))(*)(GameLevelManager*, char const*, float);
	static auto func = wrapFunction(base::get() + 0x147c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

bool GameLevelManager::isUpdateValid(int id) {
        const char* str = cocos2d::CCString::createWithFormat("%i", id)->getCString();

        return this->isTimeValid(str, 3600.f);
    }

auto GameLevelManager::likeItem(LikeItemType p0, int p1, bool p2, int p3) -> decltype(likeItem(p0, p1, p2, p3)) {
	using FunctionType = decltype(likeItem(p0, p1, p2, p3))(*)(GameLevelManager*, LikeItemType, int, bool, int);
	static auto func = wrapFunction(base::get() + 0x161270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GameLevelManager::limitSavedLevels() -> decltype(limitSavedLevels()) {
	using FunctionType = decltype(limitSavedLevels())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0x148090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameLevelManager::makeTimeStamp(char const* p0) -> decltype(makeTimeStamp(p0)) {
	using FunctionType = decltype(makeTimeStamp(p0))(*)(GameLevelManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x147b90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::markLevelAsDownloaded(int p0) -> decltype(markLevelAsDownloaded(p0)) {
	using FunctionType = decltype(markLevelAsDownloaded(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x151510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void GameLevelManager::markListAsDownloaded(int id) {
        this->markLevelAsDownloaded(-id);
    }

auto GameLevelManager::onGetFriendRequestsCompleted(gd::string response, gd::string tag) -> decltype(onGetFriendRequestsCompleted(response, tag)) {
	using FunctionType = decltype(onGetFriendRequestsCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x15d510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onGetGJChallengesCompleted(gd::string response, gd::string tag) -> decltype(onGetGJChallengesCompleted(response, tag)) {
	using FunctionType = decltype(onGetGJChallengesCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x164f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onGetGJDailyLevelStateCompleted(gd::string response, gd::string tag) -> decltype(onGetGJDailyLevelStateCompleted(response, tag)) {
	using FunctionType = decltype(onGetGJDailyLevelStateCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x1663a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onGetLeaderboardScoresCompleted(gd::string response, gd::string tag) -> decltype(onGetLeaderboardScoresCompleted(response, tag)) {
	using FunctionType = decltype(onGetLeaderboardScoresCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x155b80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onGetLevelListsCompleted(gd::string response, gd::string tag) -> decltype(onGetLevelListsCompleted(response, tag)) {
	using FunctionType = decltype(onGetLevelListsCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x14e970, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onGetMapPacksCompleted(gd::string response, gd::string tag) -> decltype(onGetMapPacksCompleted(response, tag)) {
	using FunctionType = decltype(onGetMapPacksCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x14d680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onGetOnlineLevelsCompleted(gd::string response, gd::string tag) -> decltype(onGetOnlineLevelsCompleted(response, tag)) {
	using FunctionType = decltype(onGetOnlineLevelsCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x14c3d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onProcessHttpRequestCompleted(cocos2d::extension::CCHttpClient* p0, cocos2d::extension::CCHttpResponse* p1) -> decltype(onProcessHttpRequestCompleted(p0, p1)) {
	using FunctionType = decltype(onProcessHttpRequestCompleted(p0, p1))(*)(GameLevelManager*, cocos2d::extension::CCHttpClient*, cocos2d::extension::CCHttpResponse*);
	static auto func = wrapFunction(base::get() + 0x140d10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::onUploadCommentCompleted(gd::string response, gd::string tag) -> decltype(onUploadCommentCompleted(response, tag)) {
	using FunctionType = decltype(onUploadCommentCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x15bde0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onUploadLevelCompleted(gd::string response, gd::string tag) -> decltype(onUploadLevelCompleted(response, tag)) {
	using FunctionType = decltype(onUploadLevelCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x14b1a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::ProcessHttpRequest(gd::string endpoint, gd::string params, gd::string tag, GJHttpType httpType) -> decltype(ProcessHttpRequest(endpoint, params, tag, httpType)) {
	using FunctionType = decltype(ProcessHttpRequest(endpoint, params, tag, httpType))(*)(GameLevelManager*, gd::string, gd::string, gd::string, GJHttpType);
	static auto func = wrapFunction(base::get() + 0x140b70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, endpoint, params, tag, httpType);
}

auto GameLevelManager::processOnDownloadLevelCompleted(gd::string response, gd::string tag, bool p2) -> decltype(processOnDownloadLevelCompleted(response, tag, p2)) {
	using FunctionType = decltype(processOnDownloadLevelCompleted(response, tag, p2))(*)(GameLevelManager*, gd::string, gd::string, bool);
	static auto func = wrapFunction(base::get() + 0x150350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag, p2);
}

auto GameLevelManager::purgeUnusedLevels() -> decltype(purgeUnusedLevels()) {
	using FunctionType = decltype(purgeUnusedLevels())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0x148330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameLevelManager::removeDelimiterChars(gd::string p0, bool p1) -> decltype(removeDelimiterChars(p0, p1)) {
	using FunctionType = decltype(removeDelimiterChars(p0, p1))(*)(GameLevelManager*, gd::string, bool);
	static auto func = wrapFunction(base::get() + 0x167f10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

void GameLevelManager::resetAccountComments(int accountID) {
        for(int i = 0; i <= 1; i++) {
            auto key = getAccountCommentKey(accountID, i);
            if(getStoredOnlineLevels(key)) {
                m_storedLevels->removeObjectForKey(key);
            }
        }
    }

auto GameLevelManager::resetCommentTimersForLevelID(int p0, CommentKeyType p1) -> decltype(resetCommentTimersForLevelID(p0, p1)) {
	using FunctionType = decltype(resetCommentTimersForLevelID(p0, p1))(*)(GameLevelManager*, int, CommentKeyType);
	static auto func = wrapFunction(base::get() + 0x15c770, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

void GameLevelManager::resetStoredUserInfo(int id) {
        m_storedUserInfo->removeObjectForKey(id);
    }

void GameLevelManager::saveFetchedLevelLists(cocos2d::CCArray* lists) {
        for (int i = 0; i < lists->count(); i++) {
            this->saveLevelList(static_cast<GJLevelList*>(lists->objectAtIndex(i)));
        }
    }

auto GameLevelManager::saveFetchedLevels(cocos2d::CCArray* p0) -> decltype(saveFetchedLevels(p0)) {
	using FunctionType = decltype(saveFetchedLevels(p0))(*)(GameLevelManager*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x144960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::saveLevel(GJGameLevel* p0) -> decltype(saveLevel(p0)) {
	using FunctionType = decltype(saveLevel(p0))(*)(GameLevelManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x146d40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::saveLevelList(GJLevelList* p0) -> decltype(saveLevelList(p0)) {
	using FunctionType = decltype(saveLevelList(p0))(*)(GameLevelManager*, GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x14ee60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void GameLevelManager::setBoolForKey(bool value, char const* key) {
        m_searchFilters->setObject(cocos2d::CCString::createWithFormat("%i", (int)value), key);
    }

void GameLevelManager::setIntForKey(int value, char const* key) {
        m_searchFilters->setObject(cocos2d::CCString::createWithFormat("%i", value), key);
    }

auto GameLevelManager::storeSearchResult(cocos2d::CCArray* levels, gd::string pageInfo, char const* searchKey) -> decltype(storeSearchResult(levels, pageInfo, searchKey)) {
	using FunctionType = decltype(storeSearchResult(levels, pageInfo, searchKey))(*)(GameLevelManager*, cocos2d::CCArray*, gd::string, char const*);
	static auto func = wrapFunction(base::get() + 0x147570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, levels, pageInfo, searchKey);
}

auto GameLevelManager::storeUserName(int userID, int accountID, gd::string userName) -> decltype(storeUserName(userID, accountID, userName)) {
	using FunctionType = decltype(storeUserName(userID, accountID, userName))(*)(GameLevelManager*, int, int, gd::string);
	static auto func = wrapFunction(base::get() + 0x143ca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, userID, accountID, userName);
}

auto GameLevelManager::tryGetUsername(int p0) -> decltype(tryGetUsername(p0)) {
	using FunctionType = decltype(tryGetUsername(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x144000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::updateLevelOrders() -> decltype(updateLevelOrders()) {
	using FunctionType = decltype(updateLevelOrders())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0x145680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameLevelManager::updateLevelRewards(GJGameLevel* p0) -> decltype(updateLevelRewards(p0)) {
	using FunctionType = decltype(updateLevelRewards(p0))(*)(GameLevelManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x144380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::updateSavedLevelList(GJLevelList* p0) -> decltype(updateSavedLevelList(p0)) {
	using FunctionType = decltype(updateSavedLevelList(p0))(*)(GameLevelManager*, GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x14ef40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::updateUserScore() -> decltype(updateUserScore()) {
	using FunctionType = decltype(updateUserScore())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0x153790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameLevelManager::uploadUserMessage(int p0, gd::string p1, gd::string p2) -> decltype(uploadUserMessage(p0, p1, p2)) {
	using FunctionType = decltype(uploadUserMessage(p0, p1, p2))(*)(GameLevelManager*, int, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x1588b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameLevelManager::userNameForUserID(int p0) -> decltype(userNameForUserID(p0)) {
	using FunctionType = decltype(userNameForUserID(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x143e80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::writeSpecialFilters(GJSearchObject* p0) -> decltype(writeSpecialFilters(p0)) {
	using FunctionType = decltype(writeSpecialFilters(p0))(*)(GameLevelManager*, GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0x14b8b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelOptionsLayer::create(GJGameLevel* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x2993c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GameLevelOptionsLayer::setupOptions() -> decltype(setupOptions()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameLevelOptionsLayer::setupOptions), this);
	using FunctionType = decltype(setupOptions())(*)(GameLevelOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x299520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameLevelOptionsLayer::didToggle(int p0) -> decltype(didToggle(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&GameLevelOptionsLayer::didToggle), this);
	using FunctionType = decltype(didToggle(p0))(*)(GameLevelOptionsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2995a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto UIButtonConfig::reset() -> decltype(reset()) {
	using FunctionType = decltype(reset())(*)(UIButtonConfig*);
	static auto func = wrapFunction(base::get() + 0x1779e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

GameManager::~GameManager() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x177af0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) GameManager(geode::CutoffConstructor, sizeof(GameManager));
	CCDestructor::lock(this) = true;
}

GameManager* GameManager::get() {
        return GameManager::sharedState();
    }

auto GameManager::sharedState() -> decltype(sharedState()) {
	using FunctionType = decltype(sharedState())(*)();
	static auto func = wrapFunction(base::get() + 0x178480, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GameManager::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameManager::update), this);
	using FunctionType = decltype(update(p0))(*)(GameManager*, float);
	static auto func = wrapFunction(base::get() + 0x186c40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameManager::init), this);
	using FunctionType = decltype(init())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x1784d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameManager::encodeDataTo(DS_Dictionary* p0) -> decltype(encodeDataTo(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&GameManager::encodeDataTo), this);
	using FunctionType = decltype(encodeDataTo(p0))(*)(GameManager*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x186050, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameManager::dataLoaded(DS_Dictionary* p0) -> decltype(dataLoaded(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&GameManager::dataLoaded), this);
	using FunctionType = decltype(dataLoaded(p0))(*)(GameManager*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x183b40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameManager::firstLoad() -> decltype(firstLoad()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameManager::firstLoad), this);
	using FunctionType = decltype(firstLoad())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x185750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameManager::activeIconForType(IconType p0) -> decltype(activeIconForType(p0)) {
	using FunctionType = decltype(activeIconForType(p0))(*)(GameManager*, IconType);
	static auto func = wrapFunction(base::get() + 0x17ea70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::addNewCustomObject(gd::string str) -> decltype(addNewCustomObject(str)) {
	using FunctionType = decltype(addNewCustomObject(str))(*)(GameManager*, gd::string);
	static auto func = wrapFunction(base::get() + 0x1807d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, str);
}

auto GameManager::applicationWillEnterForeground() -> decltype(applicationWillEnterForeground()) {
	using FunctionType = decltype(applicationWillEnterForeground())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x186cd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::checkUsedIcons() -> decltype(checkUsedIcons()) {
	using FunctionType = decltype(checkUsedIcons())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x1811b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::colorForIdx(int p0) -> decltype(colorForIdx(p0)) {
	using FunctionType = decltype(colorForIdx(p0))(*)(GameManager*, int);
	static auto func = wrapFunction(base::get() + 0x17e330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::completedAchievement(gd::string p0) -> decltype(completedAchievement(p0)) {
	using FunctionType = decltype(completedAchievement(p0))(*)(GameManager*, gd::string);
	static auto func = wrapFunction(base::get() + 0x17a1d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::countForType(IconType p0) -> decltype(countForType(p0)) {
	using FunctionType = decltype(countForType(p0))(*)(GameManager*, IconType);
	static auto func = wrapFunction(base::get() + 0x17ebe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::dpadConfigToString(UIButtonConfig& p0) -> decltype(dpadConfigToString(p0)) {
	using FunctionType = decltype(dpadConfigToString(p0))(*)(GameManager*, UIButtonConfig&);
	static auto func = wrapFunction(base::get() + 0x183540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::fadeInMenuMusic() -> decltype(fadeInMenuMusic()) {
	using FunctionType = decltype(fadeInMenuMusic())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x178a90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::fadeInMusic(gd::string p0) -> decltype(fadeInMusic(p0)) {
	using FunctionType = decltype(fadeInMusic(p0))(*)(GameManager*, gd::string);
	static auto func = wrapFunction(base::get() + 0x178b80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

const char* GameManager::getBGTexture(int id) {
        return cocos2d::CCString::createWithFormat(
            "game_bg_%02d_001.png",
            std::clamp(id, 1, 59)
        )->getCString();
    }

LevelEditorLayer* GameManager::getEditorLayer() {
        return m_levelEditorLayer;
    }

GJBaseGameLayer* GameManager::getGameLayer() {
        return m_gameLayer;
    }

auto GameManager::getGameVariable(char const* p0) -> decltype(getGameVariable(p0)) {
	using FunctionType = decltype(getGameVariable(p0))(*)(GameManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x1800f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

bool GameManager::getGameVariableDefault(const char* key, bool defaultValue) {
        //helper function
        auto object = static_cast<cocos2d::CCString*>(m_valueKeeper->objectForKey(std::string("gv_") + key));
        if (object == nullptr)
            return defaultValue;
        return object->boolValue();
    }

int GameManager::getIconRequestID() {
        return m_iconRequestID++;
    }

auto GameManager::getIntGameVariable(char const* p0) -> decltype(getIntGameVariable(p0)) {
	using FunctionType = decltype(getIntGameVariable(p0))(*)(GameManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x1806f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

int GameManager::getIntGameVariableDefault(const char* key, int defaultValue) {
        //helper function
        auto object = static_cast<cocos2d::CCString*>(m_valueKeeper->objectForKey(std::string("gv_") + key));
        if (object == nullptr)
            return defaultValue;
        return object->intValue();
    }

auto GameManager::getMenuMusicFile() -> decltype(getMenuMusicFile()) {
	using FunctionType = decltype(getMenuMusicFile())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x178700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

int GameManager::getPlayerBall() {
        return m_playerBall;
    }

int GameManager::getPlayerBird() {
        return m_playerBird;
    }

int GameManager::getPlayerColor() {
        return m_playerColor;
    }

int GameManager::getPlayerColor2() {
        return m_playerColor2;
    }

int GameManager::getPlayerDart() {
        return m_playerDart;
    }

int GameManager::getPlayerDeathEffect() {
        return m_playerDeathEffect;
    }

int GameManager::getPlayerFrame() {
        return m_playerFrame;
    }

bool GameManager::getPlayerGlow() {
        return m_playerGlow;
    }

int GameManager::getPlayerGlowColor() {
        return m_playerGlowColor;
    }

int GameManager::getPlayerJetpack() {
        return m_playerJetpack;
    }

int GameManager::getPlayerRobot() {
        return m_playerRobot;
    }

int GameManager::getPlayerShip() {
        return m_playerShip;
    }

int GameManager::getPlayerShipFire() {
        return m_playerShipFire;
    }

int GameManager::getPlayerSpider() {
        return m_playerSpider;
    }

int GameManager::getPlayerStreak() {
        return m_playerStreak;
    }

int GameManager::getPlayerSwing() {
        return m_playerSwing;
    }

PlayLayer* GameManager::getPlayLayer() {
        return m_playLayer;
    }

auto GameManager::getUGV(char const* p0) -> decltype(getUGV(p0)) {
	using FunctionType = decltype(getUGV(p0))(*)(GameManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x180480, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::iconKey(int p0, IconType p1) -> decltype(iconKey(p0, p1)) {
	using FunctionType = decltype(iconKey(p0, p1))(*)(GameManager*, int, IconType);
	static auto func = wrapFunction(base::get() + 0x1792b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameManager::iconTypeToUnlockType(IconType p0) -> decltype(iconTypeToUnlockType(p0)) {
	using FunctionType = decltype(iconTypeToUnlockType(p0))(*)(GameManager*, IconType);
	static auto func = wrapFunction(base::get() + 0x1795c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::isColorUnlocked(int p0, UnlockType p1) -> decltype(isColorUnlocked(p0, p1)) {
	using FunctionType = decltype(isColorUnlocked(p0, p1))(*)(GameManager*, int, UnlockType);
	static auto func = wrapFunction(base::get() + 0x1798c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameManager::isIconUnlocked(int p0, IconType p1) -> decltype(isIconUnlocked(p0, p1)) {
	using FunctionType = decltype(isIconUnlocked(p0, p1))(*)(GameManager*, int, IconType);
	static auto func = wrapFunction(base::get() + 0x1794e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

int GameManager::keyForIcon(int iconIdx, int iconEnum) {
        return m_keyStartForIcon.at(iconEnum) + iconIdx - 1;
    }

auto GameManager::loadBackground(int p0) -> decltype(loadBackground(p0)) {
	using FunctionType = decltype(loadBackground(p0))(*)(GameManager*, int);
	static auto func = wrapFunction(base::get() + 0x17f880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void GameManager::loadDeathEffect(int id) {
        if (id < 1) id = 1;
        if (id > 19) id = 20;
        if (id != m_loadedDeathEffect) {
            if (1 < m_loadedDeathEffect) {
                cocos2d::CCTextureCache::sharedTextureCache()->removeTextureForKey(
                    cocos2d::CCString::createWithFormat("PlayerExplosion_%02d.png", m_loadedDeathEffect-1)->getCString()
                );
            }
            if (1 < id) {
                cocos2d::CCTextureCache::sharedTextureCache()->addImage(
                    cocos2d::CCString::createWithFormat("PlayerExplosion_%02d.png", id-1)->getCString(),
                    false
                );
                cocos2d::CCSpriteFrameCache::sharedSpriteFrameCache()->addSpriteFramesWithFile(
                    cocos2d::CCString::createWithFormat("PlayerExplosion_%02d.plist", id-1)->getCString()
                );
            }
            m_loadedDeathEffect = id;
        }
    }

auto GameManager::loadGround(int p0) -> decltype(loadGround(p0)) {
	using FunctionType = decltype(loadGround(p0))(*)(GameManager*, int);
	static auto func = wrapFunction(base::get() + 0x17fc30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::loadIcon(int p0, int p1, int p2) -> decltype(loadIcon(p0, p1, p2)) {
	using FunctionType = decltype(loadIcon(p0, p1, p2))(*)(GameManager*, int, int, int);
	static auto func = wrapFunction(base::get() + 0x17ecf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameManager::loadMiddleground(int p0) -> decltype(loadMiddleground(p0)) {
	using FunctionType = decltype(loadMiddleground(p0))(*)(GameManager*, int);
	static auto func = wrapFunction(base::get() + 0x17f9e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::playMenuMusic() -> decltype(playMenuMusic()) {
	using FunctionType = decltype(playMenuMusic())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x178810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::recountUserStats(gd::string p0) -> decltype(recountUserStats(p0)) {
	using FunctionType = decltype(recountUserStats(p0))(*)(GameManager*, gd::string);
	static auto func = wrapFunction(base::get() + 0x181ba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::reloadAll(bool switchingModes, bool toFullscreen, bool borderless, bool fix, bool unused) -> decltype(reloadAll(switchingModes, toFullscreen, borderless, fix, unused)) {
	using FunctionType = decltype(reloadAll(switchingModes, toFullscreen, borderless, fix, unused))(*)(GameManager*, bool, bool, bool, bool, bool);
	static auto func = wrapFunction(base::get() + 0x187490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, switchingModes, toFullscreen, borderless, fix, unused);
}

void GameManager::reloadAll(bool switchingModes, bool toFullscreen, bool unused) {
        return this->reloadAll(switchingModes, toFullscreen, false, false, unused);
    }

auto GameManager::reloadAllStep2() -> decltype(reloadAllStep2()) {
	using FunctionType = decltype(reloadAllStep2())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x187540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::reloadAllStep5() -> decltype(reloadAllStep5()) {
	using FunctionType = decltype(reloadAllStep5())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x187850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::reportAchievementWithID(char const* p0, int p1, bool p2) -> decltype(reportAchievementWithID(p0, p1, p2)) {
	using FunctionType = decltype(reportAchievementWithID(p0, p1, p2))(*)(GameManager*, char const*, int, bool);
	static auto func = wrapFunction(base::get() + 0x17afd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameManager::reportPercentageForLevel(int levelID, int percentage, bool isPlatformer) -> decltype(reportPercentageForLevel(levelID, percentage, isPlatformer)) {
	using FunctionType = decltype(reportPercentageForLevel(levelID, percentage, isPlatformer))(*)(GameManager*, int, int, bool);
	static auto func = wrapFunction(base::get() + 0x17a5f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, levelID, percentage, isPlatformer);
}

auto GameManager::resolutionForKey(int p0) -> decltype(resolutionForKey(p0)) {
	using FunctionType = decltype(resolutionForKey(p0))(*)(GameManager*, int);
	static auto func = wrapFunction(base::get() + 0x187890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::returnToLastScene(GJGameLevel* p0) -> decltype(returnToLastScene(p0)) {
	using FunctionType = decltype(returnToLastScene(p0))(*)(GameManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x187030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::safePopScene() -> decltype(safePopScene()) {
	using FunctionType = decltype(safePopScene())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x1873e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::setGameVariable(char const* p0, bool p1) -> decltype(setGameVariable(p0, p1)) {
	using FunctionType = decltype(setGameVariable(p0, p1))(*)(GameManager*, char const*, bool);
	static auto func = wrapFunction(base::get() + 0x17fe90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameManager::setIntGameVariable(char const* p0, int p1) -> decltype(setIntGameVariable(p0, p1)) {
	using FunctionType = decltype(setIntGameVariable(p0, p1))(*)(GameManager*, char const*, int);
	static auto func = wrapFunction(base::get() + 0x1805f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

void GameManager::setPlayerBall(int id) {
        m_playerBall = id;
    }

void GameManager::setPlayerBird(int id) {
        m_playerBird = id;
    }

void GameManager::setPlayerColor(int id) {
        m_playerColor = id;
    }

void GameManager::setPlayerColor2(int id) {
        m_playerColor2 = id;
    }

void GameManager::setPlayerColor3(int id) {
        m_playerGlowColor = id;
    }

void GameManager::setPlayerDart(int id) {
        m_playerDart = id;
    }

void GameManager::setPlayerDeathEffect(int id) {
        m_playerDeathEffect = id;
    }

void GameManager::setPlayerFrame(int id) {
        m_playerFrame = id;
    }

void GameManager::setPlayerGlow(bool v) {
        m_playerGlow = v;
    }

void GameManager::setPlayerJetpack(int id) {
        m_playerJetpack = id;
    }

void GameManager::setPlayerRobot(int id) {
        m_playerRobot = id;
    }

void GameManager::setPlayerShip(int id) {
        m_playerShip = id;
    }

void GameManager::setPlayerShipStreak(int id) {
        m_playerShipFire = id;
    }

void GameManager::setPlayerSpider(int id) {
        m_playerSpider = id;
    }

void GameManager::setPlayerStreak(int id) {
        m_playerStreak = id;
    }

void GameManager::setPlayerSwing(int id) {
        m_playerSwing = id;
    }

auto GameManager::setUGV(char const* p0, bool p1) -> decltype(setUGV(p0, p1)) {
	using FunctionType = decltype(setUGV(p0, p1))(*)(GameManager*, char const*, bool);
	static auto func = wrapFunction(base::get() + 0x180320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameManager::setupGameAnimations() -> decltype(setupGameAnimations()) {
	using FunctionType = decltype(setupGameAnimations())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x1a8870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::sheetNameForIcon(int p0, int p1) -> decltype(sheetNameForIcon(p0, p1)) {
	using FunctionType = decltype(sheetNameForIcon(p0, p1))(*)(GameManager*, int, int);
	static auto func = wrapFunction(base::get() + 0x17f470, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameManager::stringForCustomObject(int customObjectID) -> decltype(stringForCustomObject(customObjectID)) {
	using FunctionType = decltype(stringForCustomObject(customObjectID))(*)(GameManager*, int);
	static auto func = wrapFunction(base::get() + 0x180950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, customObjectID);
}

auto GameManager::toggleGameVariable(char const* p0) -> decltype(toggleGameVariable(p0)) {
	using FunctionType = decltype(toggleGameVariable(p0))(*)(GameManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x180270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::unloadIcon(int p0, int p1, int p2) -> decltype(unloadIcon(p0, p1, p2)) {
	using FunctionType = decltype(unloadIcon(p0, p1, p2))(*)(GameManager*, int, int, int);
	static auto func = wrapFunction(base::get() + 0x17f050, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameManager::unlockTypeToIconType(int p0) -> decltype(unlockTypeToIconType(p0)) {
	using FunctionType = decltype(unlockTypeToIconType(p0))(*)(GameManager*, int);
	static auto func = wrapFunction(base::get() + 0x1796e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::updateCustomFPS() -> decltype(updateCustomFPS()) {
	using FunctionType = decltype(updateCustomFPS())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x187cc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObjectCopy::resetObject() -> decltype(resetObject()) {
	using FunctionType = decltype(resetObject())(*)(GameObjectCopy*);
	static auto func = wrapFunction(base::get() + 0x2db140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

GameOptionsLayer::GameOptionsLayer() {
        m_practiceDialogIndex = 0;
    }

GameOptionsLayer* GameOptionsLayer::create(GJBaseGameLayer* baseGameLayer) {
        auto ret = new GameOptionsLayer();
        if (ret->init(baseGameLayer)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto GameOptionsLayer::setupOptions() -> decltype(setupOptions()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameOptionsLayer::setupOptions), this);
	using FunctionType = decltype(setupOptions())(*)(GameOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x2978e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameOptionsLayer::didToggle(int p0) -> decltype(didToggle(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&GameOptionsLayer::didToggle), this);
	using FunctionType = decltype(didToggle(p0))(*)(GameOptionsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x298ed0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

bool GameOptionsLayer::init(GJBaseGameLayer* baseGameLayer) {
        m_baseGameLayer = baseGameLayer;
        m_gap = 40.f;
        m_maxLabelScale = .4f;
        if (!GJOptionsLayer::init(2)) return false;
        this->preSetup();
        this->postSetup();
        return true;
    }

auto GameOptionsLayer::onUIOptions(cocos2d::CCObject* sender) -> decltype(onUIOptions(sender)) {
	using FunctionType = decltype(onUIOptions(sender))(*)(GameOptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x298d60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GameOptionsLayer::onUIPOptions(cocos2d::CCObject* sender) -> decltype(onUIPOptions(sender)) {
	using FunctionType = decltype(onUIPOptions(sender))(*)(GameOptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x298d80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GameOptionsLayer::showPracticeMusicSyncUnlockInfo() -> decltype(showPracticeMusicSyncUnlockInfo()) {
	using FunctionType = decltype(showPracticeMusicSyncUnlockInfo())(*)(GameOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x298380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameOptionsTrigger::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("GameOptionsTrigger::customObjectSetup not implemented");
}

auto GameOptionsTrigger::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("GameOptionsTrigger::getSaveString not implemented");
}

GameStatsManager* GameStatsManager::get() {
        return GameStatsManager::sharedState();
    }

auto GameStatsManager::sharedState() -> decltype(sharedState()) {
	using FunctionType = decltype(sharedState())(*)();
	static auto func = wrapFunction(base::get() + 0x1cdf20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GameStatsManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameStatsManager::init), this);
	using FunctionType = decltype(init())(*)(GameStatsManager*);
	static auto func = wrapFunction(base::get() + 0x1ce140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameStatsManager::addStoreItem(int p0, int p1, int p2, int p3, ShopType p4) -> decltype(addStoreItem(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(addStoreItem(p0, p1, p2, p3, p4))(*)(GameStatsManager*, int, int, int, int, ShopType);
	static auto func = wrapFunction(base::get() + 0x1d1000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto GameStatsManager::awardCurrencyForLevel(GJGameLevel* p0) -> decltype(awardCurrencyForLevel(p0)) {
	using FunctionType = decltype(awardCurrencyForLevel(p0))(*)(GameStatsManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x1dd990, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::checkAchievement(char const* p0) -> decltype(checkAchievement(p0)) {
	using FunctionType = decltype(checkAchievement(p0))(*)(GameStatsManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x1d2470, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::checkCoinAchievement(GJGameLevel* p0) -> decltype(checkCoinAchievement(p0)) {
	using FunctionType = decltype(checkCoinAchievement(p0))(*)(GameStatsManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x1da830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::completedDailyLevel(GJGameLevel* p0) -> decltype(completedDailyLevel(p0)) {
	using FunctionType = decltype(completedDailyLevel(p0))(*)(GameStatsManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x1dfe10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::completedMapPack(GJMapPack* p0) -> decltype(completedMapPack(p0)) {
	using FunctionType = decltype(completedMapPack(p0))(*)(GameStatsManager*, GJMapPack*);
	static auto func = wrapFunction(base::get() + 0x1dbe30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::createStoreItems() -> decltype(createStoreItems()) {
	using FunctionType = decltype(createStoreItems())(*)(GameStatsManager*);
	static auto func = wrapFunction(base::get() + 0x1ce830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameStatsManager::dataLoaded(DS_Dictionary* p0) -> decltype(dataLoaded(p0)) {
	using FunctionType = decltype(dataLoaded(p0))(*)(GameStatsManager*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x1ef0b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::getAwardedCurrencyForLevel(GJGameLevel* p0) -> decltype(getAwardedCurrencyForLevel(p0)) {
	using FunctionType = decltype(getAwardedCurrencyForLevel(p0))(*)(GameStatsManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x1dd750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::getBaseCurrencyForLevel(GJGameLevel* p0) -> decltype(getBaseCurrencyForLevel(p0)) {
	using FunctionType = decltype(getBaseCurrencyForLevel(p0))(*)(GameStatsManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x1dd4b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::getChallenge(int p0) -> decltype(getChallenge(p0)) {
	using FunctionType = decltype(getChallenge(p0))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x1dee70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::getCollectedCoinsForLevel(GJGameLevel* p0) -> decltype(getCollectedCoinsForLevel(p0)) {
	using FunctionType = decltype(getCollectedCoinsForLevel(p0))(*)(GameStatsManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x1dabd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::getCompletedMapPacks() -> decltype(getCompletedMapPacks()) {
	using FunctionType = decltype(getCompletedMapPacks())(*)(GameStatsManager*);
	static auto func = wrapFunction(base::get() + 0x1dc180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

gd::string GameStatsManager::getCurrencyKey(GJGameLevel* level) {
        auto dailyID = level->m_dailyID.value();
        return cocos2d::CCString::createWithFormat("%i", dailyID > 0 ? dailyID : level->m_levelID.value())->getCString();
    }

auto GameStatsManager::getGauntletRewardKey(int p0) -> decltype(getGauntletRewardKey(p0)) {
	using FunctionType = decltype(getGauntletRewardKey(p0))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x1e6e40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::getItemKey(int p0, int p1) -> decltype(getItemKey(p0, p1)) {
	using FunctionType = decltype(getItemKey(p0, p1))(*)(GameStatsManager*, int, int);
	static auto func = wrapFunction(base::get() + 0x1de9b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameStatsManager::getItemUnlockState(int itemID, UnlockType unlockType) -> decltype(getItemUnlockState(itemID, unlockType)) {
	using FunctionType = decltype(getItemUnlockState(itemID, unlockType))(*)(GameStatsManager*, int, UnlockType);
	static auto func = wrapFunction(base::get() + 0x1e2b30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, itemID, unlockType);
}

gd::string GameStatsManager::getLevelKey(GJGameLevel* level) {
        return getLevelKey(level->m_levelID, level->m_levelType != GJLevelType::Local, level->m_dailyID > 0, level->m_gauntletLevel, level->m_dailyID > 200000);
    }

auto GameStatsManager::getLevelKey(int levelID, bool isOnline, bool isDaily, bool isGauntlet, bool isEvent) -> decltype(getLevelKey(levelID, isOnline, isDaily, isGauntlet, isEvent)) {
	using FunctionType = decltype(getLevelKey(levelID, isOnline, isDaily, isGauntlet, isEvent))(*)(GameStatsManager*, int, bool, bool, bool, bool);
	static auto func = wrapFunction(base::get() + 0x1dad50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, levelID, isOnline, isDaily, isGauntlet, isEvent);
}

auto GameStatsManager::getQueuedChallenge(int p0) -> decltype(getQueuedChallenge(p0)) {
	using FunctionType = decltype(getQueuedChallenge(p0))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x1def40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::getSpecialUnlockDescription(int p0, UnlockType p1, bool p2) -> decltype(getSpecialUnlockDescription(p0, p1, p2)) {
	using FunctionType = decltype(getSpecialUnlockDescription(p0, p1, p2))(*)(GameStatsManager*, int, UnlockType, bool);
	static auto func = wrapFunction(base::get() + 0x1e6fb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameStatsManager::getStat(char const* p0) -> decltype(getStat(p0)) {
	using FunctionType = decltype(getStat(p0))(*)(GameStatsManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x1d21e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::getTotalCollectedCurrency() -> decltype(getTotalCollectedCurrency()) {
	using FunctionType = decltype(getTotalCollectedCurrency())(*)(GameStatsManager*);
	static auto func = wrapFunction(base::get() + 0x1e08b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameStatsManager::getTotalCollectedDiamonds() -> decltype(getTotalCollectedDiamonds()) {
	using FunctionType = decltype(getTotalCollectedDiamonds())(*)(GameStatsManager*);
	static auto func = wrapFunction(base::get() + 0x1e1180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameStatsManager::hasClaimedListReward(GJLevelList* p0) -> decltype(hasClaimedListReward(p0)) {
	using FunctionType = decltype(hasClaimedListReward(p0))(*)(GameStatsManager*, GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x1dfc30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::hasCompletedDailyLevel(int p0) -> decltype(hasCompletedDailyLevel(p0)) {
	using FunctionType = decltype(hasCompletedDailyLevel(p0))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x1dfd10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::hasCompletedGauntletLevel(int p0) -> decltype(hasCompletedGauntletLevel(p0)) {
	using FunctionType = decltype(hasCompletedGauntletLevel(p0))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x1db1a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

bool GameStatsManager::hasCompletedLevel(GJGameLevel* level) {
        return m_completedLevels->objectForKey(this->getLevelKey(level)) != nullptr;
    }

bool GameStatsManager::hasCompletedMainLevel(int levelID) {
        return m_completedLevels->objectForKey(this->getLevelKey(levelID, false, false, false, false)) != nullptr;
    }

auto GameStatsManager::hasCompletedOnlineLevel(int p0) -> decltype(hasCompletedOnlineLevel(p0)) {
	using FunctionType = decltype(hasCompletedOnlineLevel(p0))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x1db070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::hasPendingUserCoin(char const* p0) -> decltype(hasPendingUserCoin(p0)) {
	using FunctionType = decltype(hasPendingUserCoin(p0))(*)(GameStatsManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x1dce90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::hasSecretCoin(char const* p0) -> decltype(hasSecretCoin(p0)) {
	using FunctionType = decltype(hasSecretCoin(p0))(*)(GameStatsManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x1dcf50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::hasUserCoin(char const* p0) -> decltype(hasUserCoin(p0)) {
	using FunctionType = decltype(hasUserCoin(p0))(*)(GameStatsManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x1dcd10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::incrementChallenge(GJChallengeType p0, int p1) -> decltype(incrementChallenge(p0, p1)) {
	using FunctionType = decltype(incrementChallenge(p0, p1))(*)(GameStatsManager*, GJChallengeType, int);
	static auto func = wrapFunction(base::get() + 0x1df0f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameStatsManager::incrementStat(char const* p0, int p1) -> decltype(incrementStat(p0, p1)) {
	using FunctionType = decltype(incrementStat(p0, p1))(*)(GameStatsManager*, char const*, int);
	static auto func = wrapFunction(base::get() + 0x1d1500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

bool GameStatsManager::isItemEnabled(UnlockType type, int id) {
        return this->isItemUnlocked(type, id) && m_enabledItems->valueForKey(this->getItemKey(id, (int)type))->boolValue();
    }

auto GameStatsManager::isItemUnlocked(UnlockType p0, int p1) -> decltype(isItemUnlocked(p0, p1)) {
	using FunctionType = decltype(isItemUnlocked(p0, p1))(*)(GameStatsManager*, UnlockType, int);
	static auto func = wrapFunction(base::get() + 0x1e2850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameStatsManager::isSpecialChestUnlocked(gd::string p0) -> decltype(isSpecialChestUnlocked(p0)) {
	using FunctionType = decltype(isSpecialChestUnlocked(p0))(*)(GameStatsManager*, gd::string);
	static auto func = wrapFunction(base::get() + 0x1e7160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::preSaveGameStats() -> decltype(preSaveGameStats()) {
	using FunctionType = decltype(preSaveGameStats())(*)(GameStatsManager*);
	static auto func = wrapFunction(base::get() + 0x1f0630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameStatsManager::processChallengeQueue(int p0) -> decltype(processChallengeQueue(p0)) {
	using FunctionType = decltype(processChallengeQueue(p0))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x1df950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::removeErrorFromSpecialChests() -> decltype(removeErrorFromSpecialChests()) {
	using FunctionType = decltype(removeErrorFromSpecialChests())(*)(GameStatsManager*);
	static auto func = wrapFunction(base::get() + 0x1f0310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameStatsManager::setStarsForMapPack(int p0, int p1) -> decltype(setStarsForMapPack(p0, p1)) {
	using FunctionType = decltype(setStarsForMapPack(p0, p1))(*)(GameStatsManager*, int, int);
	static auto func = wrapFunction(base::get() + 0x1dc090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameStatsManager::setStat(char const* p0, int p1) -> decltype(setStat(p0, p1)) {
	using FunctionType = decltype(setStat(p0, p1))(*)(GameStatsManager*, char const*, int);
	static auto func = wrapFunction(base::get() + 0x1d2300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameStatsManager::setupIconCredits() -> decltype(setupIconCredits()) {
	using FunctionType = decltype(setupIconCredits())(*)(GameStatsManager*);
	static auto func = wrapFunction(base::get() + 0x1c1190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameStatsManager::toggleEnableItem(UnlockType p0, int p1, bool p2) -> decltype(toggleEnableItem(p0, p1, p2)) {
	using FunctionType = decltype(toggleEnableItem(p0, p1, p2))(*)(GameStatsManager*, UnlockType, int, bool);
	static auto func = wrapFunction(base::get() + 0x1e2c00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameStatsManager::tryFixPathBug() -> decltype(tryFixPathBug()) {
	using FunctionType = decltype(tryFixPathBug())(*)(GameStatsManager*);
	static auto func = wrapFunction(base::get() + 0x1d1810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameStatsManager::uncompleteLevel(GJGameLevel* p0) -> decltype(uncompleteLevel(p0)) {
	using FunctionType = decltype(uncompleteLevel(p0))(*)(GameStatsManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x1dbbc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::verifyPathAchievements() -> decltype(verifyPathAchievements()) {
	using FunctionType = decltype(verifyPathAchievements())(*)(GameStatsManager*);
	static auto func = wrapFunction(base::get() + 0x1d1f80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameStatsManager::verifyUserCoins() -> decltype(verifyUserCoins()) {
	using FunctionType = decltype(verifyUserCoins())(*)(GameStatsManager*);
	static auto func = wrapFunction(base::get() + 0x1dcc30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameToolbox::addBackButton(cocos2d::CCLayer* p0, cocos2d::CCMenuItem* p1) -> decltype(addBackButton(p0, p1)) {
	using FunctionType = decltype(addBackButton(p0, p1))(*)(cocos2d::CCLayer*, cocos2d::CCMenuItem*);
	static auto func = wrapFunction(base::get() + 0x65010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GameToolbox::addRThumbScrollButton(cocos2d::CCLayer* p0) -> decltype(addRThumbScrollButton(p0)) {
	using FunctionType = decltype(addRThumbScrollButton(p0))(*)(cocos2d::CCLayer*);
	static auto func = wrapFunction(base::get() + 0x650f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GameToolbox::alignItemsHorisontally(cocos2d::CCArray* p0, float p1, cocos2d::CCPoint p2, bool p3) -> decltype(alignItemsHorisontally(p0, p1, p2, p3)) {
	using FunctionType = decltype(alignItemsHorisontally(p0, p1, p2, p3))(*)(cocos2d::CCArray*, float, cocos2d::CCPoint, bool);
	static auto func = wrapFunction(base::get() + 0x64110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3);
}

auto GameToolbox::createToggleButton(gd::string label, cocos2d::SEL_MenuHandler selector, bool state, cocos2d::CCMenu* menu, cocos2d::CCPoint position, cocos2d::CCNode* parent, cocos2d::CCNode* labelParent, float buttonScale, float maxLabelScale, float maxLabelWidth, cocos2d::CCPoint labelOffset, char const* font, bool labelTop, int labelTag, cocos2d::CCArray* container) -> decltype(createToggleButton(label, selector, state, menu, position, parent, labelParent, buttonScale, maxLabelScale, maxLabelWidth, labelOffset, font, labelTop, labelTag, container)) {
	using FunctionType = decltype(createToggleButton(label, selector, state, menu, position, parent, labelParent, buttonScale, maxLabelScale, maxLabelWidth, labelOffset, font, labelTop, labelTag, container))(*)(gd::string, cocos2d::SEL_MenuHandler, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCNode*, cocos2d::CCNode*, float, float, float, cocos2d::CCPoint, char const*, bool, int, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x64670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(label, selector, state, menu, position, parent, labelParent, buttonScale, maxLabelScale, maxLabelWidth, labelOffset, font, labelTop, labelTag, container);
}

auto GameToolbox::getEasedValue(float p0, int p1, float p2) -> decltype(getEasedValue(p0, p1, p2)) {
	using FunctionType = decltype(getEasedValue(p0, p1, p2))(*)(float, int, float);
	static auto func = wrapFunction(base::get() + 0x68b40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto GameToolbox::getRelativeOffset(GameObject* p0, cocos2d::CCPoint p1) -> decltype(getRelativeOffset(p0, p1)) {
	using FunctionType = decltype(getRelativeOffset(p0, p1))(*)(GameObject*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x64970, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GameToolbox::getResponse(cocos2d::extension::CCHttpResponse* p0) -> decltype(getResponse(p0)) {
	using FunctionType = decltype(getResponse(p0))(*)(cocos2d::extension::CCHttpResponse*);
	static auto func = wrapFunction(base::get() + 0x64310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GameToolbox::getTimeString(int p0, bool p1) -> decltype(getTimeString(p0, p1)) {
	using FunctionType = decltype(getTimeString(p0, p1))(*)(int, bool);
	static auto func = wrapFunction(base::get() + 0x65e20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GameToolbox::intToShortString(int p0) -> decltype(intToShortString(p0)) {
	using FunctionType = decltype(intToShortString(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x69120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GameToolbox::intToString(int p0) -> decltype(intToString(p0)) {
	using FunctionType = decltype(intToString(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x69060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

cocos2d::CCParticleSystemQuad* GameToolbox::particleFromString(gd::string const& str, cocos2d::CCParticleSystemQuad* system, bool p2) {
        cocos2d::ParticleStruct ret;
        GameToolbox::particleStringToStruct(str, ret);
        return GameToolbox::particleFromStruct(ret, system, p2);
    }

auto GameToolbox::particleFromStruct(cocos2d::ParticleStruct const& p0, cocos2d::CCParticleSystemQuad* p1, bool p2) -> decltype(particleFromStruct(p0, p1, p2)) {
	using FunctionType = decltype(particleFromStruct(p0, p1, p2))(*)(cocos2d::ParticleStruct const&, cocos2d::CCParticleSystemQuad*, bool);
	static auto func = wrapFunction(base::get() + 0x68000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto GameToolbox::particleStringToStruct(gd::string const& p0, cocos2d::ParticleStruct& p1) -> decltype(particleStringToStruct(p0, p1)) {
	using FunctionType = decltype(particleStringToStruct(p0, p1))(*)(gd::string const&, cocos2d::ParticleStruct&);
	static auto func = wrapFunction(base::get() + 0x67540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GameToolbox::pointsToString(int p0) -> decltype(pointsToString(p0)) {
	using FunctionType = decltype(pointsToString(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x69760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GameToolbox::preVisitWithClippingRect(cocos2d::CCNode* p0, cocos2d::CCRect p1) -> decltype(preVisitWithClippingRect(p0, p1)) {
	using FunctionType = decltype(preVisitWithClippingRect(p0, p1))(*)(cocos2d::CCNode*, cocos2d::CCRect);
	static auto func = wrapFunction(base::get() + 0x645c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GameToolbox::saveParticleToString(cocos2d::CCParticleSystemQuad* p0) -> decltype(saveParticleToString(p0)) {
	using FunctionType = decltype(saveParticleToString(p0))(*)(cocos2d::CCParticleSystemQuad*);
	static auto func = wrapFunction(base::get() + 0x662d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GameToolbox::stringSetupToDict(gd::string const& p0, char const* p1) -> decltype(stringSetupToDict(p0, p1)) {
	using FunctionType = decltype(stringSetupToDict(p0, p1))(*)(gd::string const&, char const*);
	static auto func = wrapFunction(base::get() + 0x65c30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GameToolbox::stringSetupToMap(gd::string const& p0, char const* p1, gd::map<gd::string, gd::string>& p2) -> decltype(stringSetupToMap(p0, p1, p2)) {
	using FunctionType = decltype(stringSetupToMap(p0, p1, p2))(*)(gd::string const&, char const*, gd::map<gd::string, gd::string>&);
	static auto func = wrapFunction(base::get() + 0x65890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto GameToolbox::transformColor(cocos2d::ccColor3B const& p0, cocos2d::ccHSVValue p1) -> decltype(transformColor(p0, p1)) {
	using FunctionType = decltype(transformColor(p0, p1))(*)(cocos2d::ccColor3B const&, cocos2d::ccHSVValue);
	static auto func = wrapFunction(base::get() + 0x65290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

void LevelManagerDelegate::loadLevelsFinished(cocos2d::CCArray* p0, char const* p1) {}

void LevelManagerDelegate::loadLevelsFailed(char const* p0) {}

void LevelManagerDelegate::loadLevelsFinished(cocos2d::CCArray* p0, char const* p1, int p2) {}

void LevelManagerDelegate::loadLevelsFailed(char const* p0, int p1) {}

void LevelManagerDelegate::setupPageInfo(gd::string p0, char const* p1) {}

GauntletLayer::GauntletLayer() {}

GauntletLayer* GauntletLayer::create(GauntletType gauntletType) {
        auto ret = new GauntletLayer();
        if (ret->init(gauntletType)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto GauntletLayer::scene(GauntletType p0) -> decltype(scene(p0)) {
	using FunctionType = decltype(scene(p0))(*)(GauntletType);
	static auto func = wrapFunction(base::get() + 0x1f2920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GauntletLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GauntletLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(GauntletLayer*);
	static auto func = wrapFunction(base::get() + 0x1f4f50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GauntletLayer::loadLevelsFinished(cocos2d::CCArray* p0, char const* p1, int p2) -> decltype(loadLevelsFinished(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*, char const*, int>::func(&GauntletLayer::loadLevelsFinished), this);
	using FunctionType = decltype(loadLevelsFinished(p0, p1, p2))(*)(GauntletLayer*, cocos2d::CCArray*, char const*, int);
	static auto func = wrapFunction(base::get() + 0x1f3440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto GauntletLayer::loadLevelsFailed(char const* p0, int p1) -> decltype(loadLevelsFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<char const*, int>::func(&GauntletLayer::loadLevelsFailed), this);
	using FunctionType = decltype(loadLevelsFailed(p0, p1))(*)(GauntletLayer*, char const*, int);
	static auto func = wrapFunction(base::get() + 0x1f3650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GauntletLayer::init(GauntletType p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GauntletLayer*, GauntletType);
	static auto func = wrapFunction(base::get() + 0x1f2c50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GauntletLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	using FunctionType = decltype(onBack(sender))(*)(GauntletLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1f4f00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GauntletLayer::onLevel(cocos2d::CCObject* sender) -> decltype(onLevel(sender)) {
	using FunctionType = decltype(onLevel(sender))(*)(GauntletLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1f4880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GauntletLayer::setupGauntlet(cocos2d::CCArray* p0) -> decltype(setupGauntlet(p0)) {
	using FunctionType = decltype(setupGauntlet(p0))(*)(GauntletLayer*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x1f3850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GauntletLayer::unlockActiveItem() -> decltype(unlockActiveItem()) {
	using FunctionType = decltype(unlockActiveItem())(*)(GauntletLayer*);
	static auto func = wrapFunction(base::get() + 0x1f48f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

GauntletNode::GauntletNode() {}

GauntletNode* GauntletNode::create(GJMapPack* gauntlet) {
        auto ret = new GauntletNode();
        if (ret->init(gauntlet)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto GauntletNode::frameForType(GauntletType p0) -> decltype(frameForType(p0)) {
	using FunctionType = decltype(frameForType(p0))(*)(GauntletType);
	static auto func = wrapFunction(base::get() + 0x1f9030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GauntletNode::nameForType(GauntletType p0) -> decltype(nameForType(p0)) {
	using FunctionType = decltype(nameForType(p0))(*)(GauntletType);
	static auto func = wrapFunction(base::get() + 0x1fa250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GauntletNode::init(GJMapPack* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GauntletNode*, GJMapPack*);
	static auto func = wrapFunction(base::get() + 0x1f7970, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GauntletNode::onClaimReward() -> decltype(onClaimReward()) {
	using FunctionType = decltype(onClaimReward())(*)(GauntletNode*);
	static auto func = wrapFunction(base::get() + 0x1f8ff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

GauntletSelectLayer::GauntletSelectLayer() {}

GauntletSelectLayer* GauntletSelectLayer::create(int p0) {
        auto ret = new GauntletSelectLayer();
        if (ret->init(p0)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto GauntletSelectLayer::scene(int p0) -> decltype(scene(p0)) {
	using FunctionType = decltype(scene(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x1f5570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GauntletSelectLayer::onExit() -> decltype(onExit()) {
	throw std::runtime_error("GauntletSelectLayer::onExit not implemented");
}

auto GauntletSelectLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GauntletSelectLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(GauntletSelectLayer*);
	static auto func = wrapFunction(base::get() + 0x1f7180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GauntletSelectLayer::scrollLayerWillScrollToPage(BoomScrollLayer* p0, int p1) -> decltype(scrollLayerWillScrollToPage(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<BoomScrollLayer*, int>::func(&GauntletSelectLayer::scrollLayerWillScrollToPage), this);
	using FunctionType = decltype(scrollLayerWillScrollToPage(p0, p1))(*)(GauntletSelectLayer*, BoomScrollLayer*, int);
	static auto func = wrapFunction(base::get() + 0x1f7090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GauntletSelectLayer::scrollLayerScrolledToPage(BoomScrollLayer* p0, int p1) -> decltype(scrollLayerScrolledToPage(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<BoomScrollLayer*, int>::func(&GauntletSelectLayer::scrollLayerScrolledToPage), this);
	using FunctionType = decltype(scrollLayerScrolledToPage(p0, p1))(*)(GauntletSelectLayer*, BoomScrollLayer*, int);
	static auto func = wrapFunction(base::get() + 0x1f7090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GauntletSelectLayer::loadLevelsFinished(cocos2d::CCArray* p0, char const* p1, int p2) -> decltype(loadLevelsFinished(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*, char const*, int>::func(&GauntletSelectLayer::loadLevelsFinished), this);
	using FunctionType = decltype(loadLevelsFinished(p0, p1, p2))(*)(GauntletSelectLayer*, cocos2d::CCArray*, char const*, int);
	static auto func = wrapFunction(base::get() + 0x1f6470, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto GauntletSelectLayer::loadLevelsFailed(char const* p0, int p1) -> decltype(loadLevelsFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<char const*, int>::func(&GauntletSelectLayer::loadLevelsFailed), this);
	using FunctionType = decltype(loadLevelsFailed(p0, p1))(*)(GauntletSelectLayer*, char const*, int);
	static auto func = wrapFunction(base::get() + 0x1f6620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GauntletSelectLayer::goToPage(int p0, bool p1) -> decltype(goToPage(p0, p1)) {
	using FunctionType = decltype(goToPage(p0, p1))(*)(GauntletSelectLayer*, int, bool);
	static auto func = wrapFunction(base::get() + 0x1f6f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GauntletSelectLayer::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GauntletSelectLayer*, int);
	static auto func = wrapFunction(base::get() + 0x1f56a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GauntletSelectLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	using FunctionType = decltype(onBack(sender))(*)(GauntletSelectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1f70d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GauntletSelectLayer::onInfo(cocos2d::CCObject* sender) -> decltype(onInfo(sender)) {
	using FunctionType = decltype(onInfo(sender))(*)(GauntletSelectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1f6210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GauntletSelectLayer::onNext(cocos2d::CCObject* sender) -> decltype(onNext(sender)) {
	using FunctionType = decltype(onNext(sender))(*)(GauntletSelectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1f6ee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GauntletSelectLayer::onPlay(cocos2d::CCObject* sender) -> decltype(onPlay(sender)) {
	using FunctionType = decltype(onPlay(sender))(*)(GauntletSelectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1f7190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GauntletSelectLayer::onPrev(cocos2d::CCObject* sender) -> decltype(onPrev(sender)) {
	using FunctionType = decltype(onPrev(sender))(*)(GauntletSelectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1f6f00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GauntletSelectLayer::onRefresh(cocos2d::CCObject* sender) -> decltype(onRefresh(sender)) {
	using FunctionType = decltype(onRefresh(sender))(*)(GauntletSelectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1f6350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GauntletSelectLayer::setupGauntlets() -> decltype(setupGauntlets()) {
	using FunctionType = decltype(setupGauntlets())(*)(GauntletSelectLayer*);
	static auto func = wrapFunction(base::get() + 0x1f6790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

GauntletSprite::GauntletSprite() {}

GauntletSprite* GauntletSprite::create(GauntletType gauntletType, bool locked) {
        auto ret = new GauntletSprite();
        if (ret->init(gauntletType, locked)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto GauntletSprite::addLockedSprite() -> decltype(addLockedSprite()) {
	using FunctionType = decltype(addLockedSprite())(*)(GauntletSprite*);
	static auto func = wrapFunction(base::get() + 0x1f4fe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

bool GauntletSprite::init(GauntletType gauntletType, bool locked) {
        if (!CCNode::init()) return false;

        m_gauntletType = gauntletType;
        this->setContentSize({ 60.0f, 60.0f });
        this->toggleLockedSprite(locked);

        return true;
    }

auto GauntletSprite::toggleLockedSprite(bool p0) -> decltype(toggleLockedSprite(p0)) {
	using FunctionType = decltype(toggleLockedSprite(p0))(*)(GauntletSprite*, bool);
	static auto func = wrapFunction(base::get() + 0x1f5310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GhostTrailEffect::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x69fd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GhostTrailEffect::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GhostTrailEffect::init), this);
	using FunctionType = decltype(init())(*)(GhostTrailEffect*);
	static auto func = wrapFunction(base::get() + 0x6a0b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void GhostTrailEffect::draw() {}

auto GhostTrailEffect::trailSnapshot(float p0) -> decltype(trailSnapshot(p0)) {
	using FunctionType = decltype(trailSnapshot(p0))(*)(GhostTrailEffect*, float);
	static auto func = wrapFunction(base::get() + 0x6a110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

GJAccountManager* GJAccountManager::get() {
        return GJAccountManager::sharedState();
    }

auto GJAccountManager::sharedState() -> decltype(sharedState()) {
	using FunctionType = decltype(sharedState())(*)();
	static auto func = wrapFunction(base::get() + 0x1faf50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJAccountManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJAccountManager::init), this);
	using FunctionType = decltype(init())(*)(GJAccountManager*);
	static auto func = wrapFunction(base::get() + 0x1fb510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJAccountManager::backupAccount(gd::string p0) -> decltype(backupAccount(p0)) {
	using FunctionType = decltype(backupAccount(p0))(*)(GJAccountManager*, gd::string);
	static auto func = wrapFunction(base::get() + 0x1fc8f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJAccountManager::getAccountBackupURL() -> decltype(getAccountBackupURL()) {
	using FunctionType = decltype(getAccountBackupURL())(*)(GJAccountManager*);
	static auto func = wrapFunction(base::get() + 0x1fc2d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJAccountManager::getAccountSyncURL() -> decltype(getAccountSyncURL()) {
	using FunctionType = decltype(getAccountSyncURL())(*)(GJAccountManager*);
	static auto func = wrapFunction(base::get() + 0x1fd230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJAccountManager::getShaPassword(gd::string p0) -> decltype(getShaPassword(p0)) {
	using FunctionType = decltype(getShaPassword(p0))(*)(GJAccountManager*, gd::string);
	static auto func = wrapFunction(base::get() + 0x1feee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJAccountManager::handleIt(bool p0, gd::string p1, gd::string p2, GJHttpType p3) -> decltype(handleIt(p0, p1, p2, p3)) {
	using FunctionType = decltype(handleIt(p0, p1, p2, p3))(*)(GJAccountManager*, bool, gd::string, gd::string, GJHttpType);
	static auto func = wrapFunction(base::get() + 0x1fb2c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GJAccountManager::onBackupAccountCompleted(gd::string p0, gd::string p1) -> decltype(onBackupAccountCompleted(p0, p1)) {
	using FunctionType = decltype(onBackupAccountCompleted(p0, p1))(*)(GJAccountManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x1fce20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJAccountManager::onGetAccountBackupURLCompleted(gd::string p0, gd::string p1) -> decltype(onGetAccountBackupURLCompleted(p0, p1)) {
	using FunctionType = decltype(onGetAccountBackupURLCompleted(p0, p1))(*)(GJAccountManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x1fc620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJAccountManager::onLoginAccountCompleted(gd::string p0, gd::string p1) -> decltype(onLoginAccountCompleted(p0, p1)) {
	using FunctionType = decltype(onLoginAccountCompleted(p0, p1))(*)(GJAccountManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x1fbee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJAccountManager::onRegisterAccountCompleted(gd::string p0, gd::string p1) -> decltype(onRegisterAccountCompleted(p0, p1)) {
	using FunctionType = decltype(onRegisterAccountCompleted(p0, p1))(*)(GJAccountManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x1fb8f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJAccountManager::onSyncAccountCompleted(gd::string p0, gd::string p1) -> decltype(onSyncAccountCompleted(p0, p1)) {
	using FunctionType = decltype(onSyncAccountCompleted(p0, p1))(*)(GJAccountManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x1fdab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJAccountManager::onUpdateAccountSettingsCompleted(gd::string p0, gd::string p1) -> decltype(onUpdateAccountSettingsCompleted(p0, p1)) {
	using FunctionType = decltype(onUpdateAccountSettingsCompleted(p0, p1))(*)(GJAccountManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x1fed80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJAccountManager::ProcessHttpRequest(gd::string p0, gd::string p1, gd::string p2, GJHttpType p3) -> decltype(ProcessHttpRequest(p0, p1, p2, p3)) {
	using FunctionType = decltype(ProcessHttpRequest(p0, p1, p2, p3))(*)(GJAccountManager*, gd::string, gd::string, gd::string, GJHttpType);
	static auto func = wrapFunction(base::get() + 0x1fb070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GJAccountSettingsDelegate::updateSettingsFinished() -> decltype(updateSettingsFinished()) {
	throw std::runtime_error("GJAccountSettingsDelegate::updateSettingsFinished not implemented");
}

auto GJAccountSettingsDelegate::updateSettingsFailed() -> decltype(updateSettingsFailed()) {
	throw std::runtime_error("GJAccountSettingsDelegate::updateSettingsFailed not implemented");
}

GJAccountSettingsLayer* GJAccountSettingsLayer::create(int a1) {
        GJAccountSettingsLayer* pRet = new GJAccountSettingsLayer();
        if (pRet && pRet->init(a1)) {
            pRet->autorelease();
            return pRet;
        }

        CC_SAFE_DELETE(pRet);

        return nullptr;
    }

auto GJAccountSettingsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJAccountSettingsLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(GJAccountSettingsLayer*);
	static auto func = wrapFunction(base::get() + 0x28d1f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJAccountSettingsLayer::textInputShouldOffset(CCTextInputNode* p0, float p1) -> decltype(textInputShouldOffset(p0, p1)) {
	throw std::runtime_error("GJAccountSettingsLayer::textInputShouldOffset not implemented");
}

auto GJAccountSettingsLayer::textInputReturn(CCTextInputNode* p0) -> decltype(textInputReturn(p0)) {
	throw std::runtime_error("GJAccountSettingsLayer::textInputReturn not implemented");
}

auto GJAccountSettingsLayer::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GJAccountSettingsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x28a850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJActionManager::init() -> decltype(init()) {
	throw std::runtime_error("GJActionManager::init not implemented");
}

void TriggerEffectDelegate::toggleGroupTriggered(int p0, bool p1, gd::vector<int> const& p2, int p3, int p4) {}

void TriggerEffectDelegate::spawnGroup(int p0, bool p1, double p2, gd::vector<int> const& p3, int p4, int p5) {}

void TriggerEffectDelegate::spawnObject(GameObject* p0, double p1, gd::vector<int> const& p2) {}

GJBaseGameLayer::~GJBaseGameLayer() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x200540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) GJBaseGameLayer(geode::CutoffConstructor, sizeof(GJBaseGameLayer));
	CCDestructor::lock(this) = true;
}

GJBaseGameLayer* GJBaseGameLayer::get() {
        return GameManager::get()->m_gameLayer;
    }

auto GJBaseGameLayer::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GJBaseGameLayer::update), this);
	using FunctionType = decltype(update(p0))(*)(GJBaseGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0x232100, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJBaseGameLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJBaseGameLayer::init), this);
	using FunctionType = decltype(init())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x201cc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJBaseGameLayer::visit() -> decltype(visit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJBaseGameLayer::visit), this);
	using FunctionType = decltype(visit())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x240950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJBaseGameLayer::postUpdate(float p0) -> decltype(postUpdate(p0)) {
	throw std::runtime_error("GJBaseGameLayer::postUpdate not implemented");
}

auto GJBaseGameLayer::checkForEnd() -> decltype(checkForEnd()) {
	throw std::runtime_error("GJBaseGameLayer::checkForEnd not implemented");
}

auto GJBaseGameLayer::testTime() -> decltype(testTime()) {
	throw std::runtime_error("GJBaseGameLayer::testTime not implemented");
}

auto GJBaseGameLayer::updateVerifyDamage() -> decltype(updateVerifyDamage()) {
	throw std::runtime_error("GJBaseGameLayer::updateVerifyDamage not implemented");
}

auto GJBaseGameLayer::updateAttemptTime(float p0) -> decltype(updateAttemptTime(p0)) {
	throw std::runtime_error("GJBaseGameLayer::updateAttemptTime not implemented");
}

auto GJBaseGameLayer::updateVisibility(float p0) -> decltype(updateVisibility(p0)) {
	throw std::runtime_error("GJBaseGameLayer::updateVisibility not implemented");
}

auto GJBaseGameLayer::playerTookDamage(PlayerObject* p0) -> decltype(playerTookDamage(p0)) {
	throw std::runtime_error("GJBaseGameLayer::playerTookDamage not implemented");
}

auto GJBaseGameLayer::opacityForObject(GameObject* p0) -> decltype(opacityForObject(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GameObject*>::func(&GJBaseGameLayer::opacityForObject), this);
	using FunctionType = decltype(opacityForObject(p0))(*)(GJBaseGameLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x231ce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJBaseGameLayer::addToSpeedObjects(EffectGameObject* p0) -> decltype(addToSpeedObjects(p0)) {
	throw std::runtime_error("GJBaseGameLayer::addToSpeedObjects not implemented");
}

auto GJBaseGameLayer::objectsCollided(int p0, int p1) -> decltype(objectsCollided(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&GJBaseGameLayer::objectsCollided), this);
	using FunctionType = decltype(objectsCollided(p0, p1))(*)(GJBaseGameLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x213c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJBaseGameLayer::updateColor(cocos2d::ccColor3B& color, float fadeTime, int colorID, bool blending, float opacity, cocos2d::ccHSVValue& copyHSV, int colorIDToCopy, bool copyOpacity, EffectGameObject* callerObject, int unk1, int unk2) -> decltype(updateColor(color, fadeTime, colorID, blending, opacity, copyHSV, colorIDToCopy, copyOpacity, callerObject, unk1, unk2)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B&, float, int, bool, float, cocos2d::ccHSVValue&, int, bool, EffectGameObject*, int, int>::func(&GJBaseGameLayer::updateColor), this);
	using FunctionType = decltype(updateColor(color, fadeTime, colorID, blending, opacity, copyHSV, colorIDToCopy, copyOpacity, callerObject, unk1, unk2))(*)(GJBaseGameLayer*, cocos2d::ccColor3B&, float, int, bool, float, cocos2d::ccHSVValue&, int, bool, EffectGameObject*, int, int);
	static auto func = wrapFunction(base::get() + 0x21e5c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, color, fadeTime, colorID, blending, opacity, copyHSV, colorIDToCopy, copyOpacity, callerObject, unk1, unk2);
}

auto GJBaseGameLayer::toggleGroupTriggered(int p0, bool p1, gd::vector<int> const& p2, int p3, int p4) -> decltype(toggleGroupTriggered(p0, p1, p2, p3, p4)) {
	auto self = addresser::thunkAdjust(Resolve<int, bool, gd::vector<int> const&, int, int>::func(&GJBaseGameLayer::toggleGroupTriggered), this);
	using FunctionType = decltype(toggleGroupTriggered(p0, p1, p2, p3, p4))(*)(GJBaseGameLayer*, int, bool, gd::vector<int> const&, int, int);
	static auto func = wrapFunction(base::get() + 0x21e7a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3, p4);
}

auto GJBaseGameLayer::spawnGroup(int p0, bool p1, double p2, gd::vector<int> const& p3, int p4, int p5) -> decltype(spawnGroup(p0, p1, p2, p3, p4, p5)) {
	auto self = addresser::thunkAdjust(Resolve<int, bool, double, gd::vector<int> const&, int, int>::func(&GJBaseGameLayer::spawnGroup), this);
	using FunctionType = decltype(spawnGroup(p0, p1, p2, p3, p4, p5))(*)(GJBaseGameLayer*, int, bool, double, gd::vector<int> const&, int, int);
	static auto func = wrapFunction(base::get() + 0x2156a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3, p4, p5);
}

auto GJBaseGameLayer::spawnObject(GameObject* p0, double p1, gd::vector<int> const& p2) -> decltype(spawnObject(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<GameObject*, double, gd::vector<int> const&>::func(&GJBaseGameLayer::spawnObject), this);
	using FunctionType = decltype(spawnObject(p0, p1, p2))(*)(GJBaseGameLayer*, GameObject*, double, gd::vector<int> const&);
	static auto func = wrapFunction(base::get() + 0x215b50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto GJBaseGameLayer::activateEndTrigger(int p0, bool p1, bool p2) -> decltype(activateEndTrigger(p0, p1, p2)) {
	throw std::runtime_error("GJBaseGameLayer::activateEndTrigger not implemented");
}

auto GJBaseGameLayer::activatePlatformerEndTrigger(EndTriggerGameObject* p0, gd::vector<int> const& p1) -> decltype(activatePlatformerEndTrigger(p0, p1)) {
	throw std::runtime_error("GJBaseGameLayer::activatePlatformerEndTrigger not implemented");
}

void GJBaseGameLayer::toggleGlitter(bool p0) {}

auto GJBaseGameLayer::destroyPlayer(PlayerObject* p0, GameObject* p1) -> decltype(destroyPlayer(p0, p1)) {
	throw std::runtime_error("GJBaseGameLayer::destroyPlayer not implemented");
}

auto GJBaseGameLayer::updateDebugDraw() -> decltype(updateDebugDraw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJBaseGameLayer::updateDebugDraw), this);
	using FunctionType = decltype(updateDebugDraw())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x20b4d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJBaseGameLayer::addToSection(GameObject* p0) -> decltype(addToSection(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GameObject*>::func(&GJBaseGameLayer::addToSection), this);
	using FunctionType = decltype(addToSection(p0))(*)(GJBaseGameLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x221220, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJBaseGameLayer::addToGroup(GameObject* p0, int p1, bool p2) -> decltype(addToGroup(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<GameObject*, int, bool>::func(&GJBaseGameLayer::addToGroup), this);
	using FunctionType = decltype(addToGroup(p0, p1, p2))(*)(GJBaseGameLayer*, GameObject*, int, bool);
	static auto func = wrapFunction(base::get() + 0x21ec20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto GJBaseGameLayer::removeFromGroup(GameObject* p0, int p1) -> decltype(removeFromGroup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<GameObject*, int>::func(&GJBaseGameLayer::removeFromGroup), this);
	using FunctionType = decltype(removeFromGroup(p0, p1))(*)(GJBaseGameLayer*, GameObject*, int);
	static auto func = wrapFunction(base::get() + 0x21eda0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJBaseGameLayer::updateObjectSection(GameObject* p0) -> decltype(updateObjectSection(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GameObject*>::func(&GJBaseGameLayer::updateObjectSection), this);
	using FunctionType = decltype(updateObjectSection(p0))(*)(GJBaseGameLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x222c70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJBaseGameLayer::updateDisabledObjectsLastPos(cocos2d::CCArray* p0) -> decltype(updateDisabledObjectsLastPos(p0)) {
	throw std::runtime_error("GJBaseGameLayer::updateDisabledObjectsLastPos not implemented");
}

auto GJBaseGameLayer::toggleGroundVisibility(bool p0) -> decltype(toggleGroundVisibility(p0)) {
	throw std::runtime_error("GJBaseGameLayer::toggleGroundVisibility not implemented");
}

auto GJBaseGameLayer::toggleMGVisibility(bool p0) -> decltype(toggleMGVisibility(p0)) {
	throw std::runtime_error("GJBaseGameLayer::toggleMGVisibility not implemented");
}

auto GJBaseGameLayer::toggleHideAttempts(bool p0) -> decltype(toggleHideAttempts(p0)) {
	throw std::runtime_error("GJBaseGameLayer::toggleHideAttempts not implemented");
}

float GJBaseGameLayer::timeForPos(cocos2d::CCPoint p0, int p1, int p2, bool p3, int p4) { return 0.f; }

cocos2d::CCPoint GJBaseGameLayer::posForTime(float p0) { return { 0.f, 0.f }; }

void GJBaseGameLayer::resetSPTriggered() {}

auto GJBaseGameLayer::updateScreenRotation(float p0, bool p1, bool p2, float p3, int p4, float p5, int p6, int p7) -> decltype(updateScreenRotation(p0, p1, p2, p3, p4, p5, p6, p7)) {
	auto self = addresser::thunkAdjust(Resolve<float, bool, bool, float, int, float, int, int>::func(&GJBaseGameLayer::updateScreenRotation), this);
	using FunctionType = decltype(updateScreenRotation(p0, p1, p2, p3, p4, p5, p6, p7))(*)(GJBaseGameLayer*, float, bool, bool, float, int, float, int, int);
	static auto func = wrapFunction(base::get() + 0x230720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3, p4, p5, p6, p7);
}

auto GJBaseGameLayer::reverseDirection(EffectGameObject* p0) -> decltype(reverseDirection(p0)) {
	auto self = addresser::thunkAdjust(Resolve<EffectGameObject*>::func(&GJBaseGameLayer::reverseDirection), this);
	using FunctionType = decltype(reverseDirection(p0))(*)(GJBaseGameLayer*, EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x212c80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJBaseGameLayer::rotateGameplay(RotateGameplayGameObject* p0) -> decltype(rotateGameplay(p0)) {
	auto self = addresser::thunkAdjust(Resolve<RotateGameplayGameObject*>::func(&GJBaseGameLayer::rotateGameplay), this);
	using FunctionType = decltype(rotateGameplay(p0))(*)(GJBaseGameLayer*, RotateGameplayGameObject*);
	static auto func = wrapFunction(base::get() + 0x212ce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJBaseGameLayer::didRotateGameplay() -> decltype(didRotateGameplay()) {
	throw std::runtime_error("GJBaseGameLayer::didRotateGameplay not implemented");
}

auto GJBaseGameLayer::updateTimeWarp(float p0) -> decltype(updateTimeWarp(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GJBaseGameLayer::updateTimeWarp), this);
	using FunctionType = decltype(updateTimeWarp(p0))(*)(GJBaseGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0x230a00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJBaseGameLayer::updateTimeWarp(GameObject* p0, float p1) -> decltype(updateTimeWarp(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<GameObject*, float>::func(&GJBaseGameLayer::updateTimeWarp), this);
	using FunctionType = decltype(updateTimeWarp(p0, p1))(*)(GJBaseGameLayer*, GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x2309f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJBaseGameLayer::applyTimeWarp(float p0) -> decltype(applyTimeWarp(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GJBaseGameLayer::applyTimeWarp), this);
	using FunctionType = decltype(applyTimeWarp(p0))(*)(GJBaseGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0x230a50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJBaseGameLayer::playGravityEffect(bool p0) -> decltype(playGravityEffect(p0)) {
	throw std::runtime_error("GJBaseGameLayer::playGravityEffect not implemented");
}

auto GJBaseGameLayer::manualUpdateObjectColors(GameObject* p0) -> decltype(manualUpdateObjectColors(p0)) {
	throw std::runtime_error("GJBaseGameLayer::manualUpdateObjectColors not implemented");
}

auto GJBaseGameLayer::createCustomParticle(gd::string const& p0, cocos2d::ParticleStruct const& p1, int p2, bool p3) -> decltype(createCustomParticle(p0, p1, p2, p3)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string const&, cocos2d::ParticleStruct const&, int, bool>::func(&GJBaseGameLayer::createCustomParticle), this);
	using FunctionType = decltype(createCustomParticle(p0, p1, p2, p3))(*)(GJBaseGameLayer*, gd::string const&, cocos2d::ParticleStruct const&, int, bool);
	static auto func = wrapFunction(base::get() + 0x23a7f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3);
}

auto GJBaseGameLayer::claimCustomParticle(gd::string const& p0, cocos2d::ParticleStruct const& p1, int p2, int p3, int p4, bool p5) -> decltype(claimCustomParticle(p0, p1, p2, p3, p4, p5)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string const&, cocos2d::ParticleStruct const&, int, int, int, bool>::func(&GJBaseGameLayer::claimCustomParticle), this);
	using FunctionType = decltype(claimCustomParticle(p0, p1, p2, p3, p4, p5))(*)(GJBaseGameLayer*, gd::string const&, cocos2d::ParticleStruct const&, int, int, int, bool);
	static auto func = wrapFunction(base::get() + 0x23aaf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3, p4, p5);
}

auto GJBaseGameLayer::unclaimCustomParticle(gd::string const& p0, cocos2d::CCParticleSystemQuad* p1) -> decltype(unclaimCustomParticle(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string const&, cocos2d::CCParticleSystemQuad*>::func(&GJBaseGameLayer::unclaimCustomParticle), this);
	using FunctionType = decltype(unclaimCustomParticle(p0, p1))(*)(GJBaseGameLayer*, gd::string const&, cocos2d::CCParticleSystemQuad*);
	static auto func = wrapFunction(base::get() + 0x23acf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJBaseGameLayer::activatedAudioTrigger(SFXTriggerGameObject* p0) -> decltype(activatedAudioTrigger(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SFXTriggerGameObject*>::func(&GJBaseGameLayer::activatedAudioTrigger), this);
	using FunctionType = decltype(activatedAudioTrigger(p0))(*)(GJBaseGameLayer*, SFXTriggerGameObject*);
	static auto func = wrapFunction(base::get() + 0x23c8a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJBaseGameLayer::checkpointActivated(CheckpointGameObject* p0) -> decltype(checkpointActivated(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CheckpointGameObject*>::func(&GJBaseGameLayer::checkpointActivated), this);
	using FunctionType = decltype(checkpointActivated(p0))(*)(GJBaseGameLayer*, CheckpointGameObject*);
	static auto func = wrapFunction(base::get() + 0x240530, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJBaseGameLayer::flipArt(bool p0) -> decltype(flipArt(p0)) {
	throw std::runtime_error("GJBaseGameLayer::flipArt not implemented");
}

auto GJBaseGameLayer::addKeyframe(KeyframeGameObject* p0) -> decltype(addKeyframe(p0)) {
	auto self = addresser::thunkAdjust(Resolve<KeyframeGameObject*>::func(&GJBaseGameLayer::addKeyframe), this);
	using FunctionType = decltype(addKeyframe(p0))(*)(GJBaseGameLayer*, KeyframeGameObject*);
	static auto func = wrapFunction(base::get() + 0x22e420, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJBaseGameLayer::updateTimeLabel(int p0, int p1, bool p2) -> decltype(updateTimeLabel(p0, p1, p2)) {
	throw std::runtime_error("GJBaseGameLayer::updateTimeLabel not implemented");
}

auto GJBaseGameLayer::checkSnapshot() -> decltype(checkSnapshot()) {
	throw std::runtime_error("GJBaseGameLayer::checkSnapshot not implemented");
}

auto GJBaseGameLayer::toggleProgressbar() -> decltype(toggleProgressbar()) {
	throw std::runtime_error("GJBaseGameLayer::toggleProgressbar not implemented");
}

auto GJBaseGameLayer::toggleInfoLabel() -> decltype(toggleInfoLabel()) {
	throw std::runtime_error("GJBaseGameLayer::toggleInfoLabel not implemented");
}

auto GJBaseGameLayer::removeAllCheckpoints() -> decltype(removeAllCheckpoints()) {
	throw std::runtime_error("GJBaseGameLayer::removeAllCheckpoints not implemented");
}

auto GJBaseGameLayer::toggleMusicInPractice() -> decltype(toggleMusicInPractice()) {
	throw std::runtime_error("GJBaseGameLayer::toggleMusicInPractice not implemented");
}

auto GJBaseGameLayer::activateItemCompareTrigger(ItemTriggerGameObject* p0, gd::vector<int> const& p1) -> decltype(activateItemCompareTrigger(p0, p1)) {
	using FunctionType = decltype(activateItemCompareTrigger(p0, p1))(*)(GJBaseGameLayer*, ItemTriggerGameObject*, gd::vector<int> const&);
	static auto func = wrapFunction(base::get() + 0x22eed0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::activateItemEditTrigger(ItemTriggerGameObject* p0) -> decltype(activateItemEditTrigger(p0)) {
	using FunctionType = decltype(activateItemEditTrigger(p0))(*)(GJBaseGameLayer*, ItemTriggerGameObject*);
	static auto func = wrapFunction(base::get() + 0x22eaf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::activateSFXTrigger(SFXTriggerGameObject* p0) -> decltype(activateSFXTrigger(p0)) {
	using FunctionType = decltype(activateSFXTrigger(p0))(*)(GJBaseGameLayer*, SFXTriggerGameObject*);
	static auto func = wrapFunction(base::get() + 0x23b6c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::activateSongEditTrigger(SongTriggerGameObject* p0) -> decltype(activateSongEditTrigger(p0)) {
	using FunctionType = decltype(activateSongEditTrigger(p0))(*)(GJBaseGameLayer*, SongTriggerGameObject*);
	static auto func = wrapFunction(base::get() + 0x23b8c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::addToGroups(GameObject* p0, bool p1) -> decltype(addToGroups(p0, p1)) {
	using FunctionType = decltype(addToGroups(p0, p1))(*)(GJBaseGameLayer*, GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x21eb90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::animateInDualGroundNew(GameObject* p0, float p1, bool p2, float p3) -> decltype(animateInDualGroundNew(p0, p1, p2, p3)) {
	using FunctionType = decltype(animateInDualGroundNew(p0, p1, p2, p3))(*)(GJBaseGameLayer*, GameObject*, float, bool, float);
	static auto func = wrapFunction(base::get() + 0x20deb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GJBaseGameLayer::applyRemap(EffectGameObject* p0, gd::vector<int> const& p1, gd::unordered_map<int, int>& p2) -> decltype(applyRemap(p0, p1, p2)) {
	using FunctionType = decltype(applyRemap(p0, p1, p2))(*)(GJBaseGameLayer*, EffectGameObject*, gd::vector<int> const&, gd::unordered_map<int, int>&);
	static auto func = wrapFunction(base::get() + 0x215ce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GJBaseGameLayer::assignNewStickyGroups(cocos2d::CCArray* p0) -> decltype(assignNewStickyGroups(p0)) {
	using FunctionType = decltype(assignNewStickyGroups(p0))(*)(GJBaseGameLayer*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x21f990, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::bumpPlayer(PlayerObject* p0, EffectGameObject* p1) -> decltype(bumpPlayer(p0, p1)) {
	using FunctionType = decltype(bumpPlayer(p0, p1))(*)(GJBaseGameLayer*, PlayerObject*, EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x2124f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::canBeActivatedByPlayer(PlayerObject* p0, EffectGameObject* p1) -> decltype(canBeActivatedByPlayer(p0, p1)) {
	using FunctionType = decltype(canBeActivatedByPlayer(p0, p1))(*)(GJBaseGameLayer*, PlayerObject*, EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x2123e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::checkCameraLimitAfterTeleport(PlayerObject* p0, float p1) -> decltype(checkCameraLimitAfterTeleport(p0, p1)) {
	using FunctionType = decltype(checkCameraLimitAfterTeleport(p0, p1))(*)(GJBaseGameLayer*, PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x2340b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::checkCollisionBlocks(EffectGameObject* p0, gd::vector<EffectGameObject*>* p1, int p2) -> decltype(checkCollisionBlocks(p0, p1, p2)) {
	using FunctionType = decltype(checkCollisionBlocks(p0, p1, p2))(*)(GJBaseGameLayer*, EffectGameObject*, gd::vector<EffectGameObject*>*, int);
	static auto func = wrapFunction(base::get() + 0x2139e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GJBaseGameLayer::checkCollisions(PlayerObject* p0, float p1, bool p2) -> decltype(checkCollisions(p0, p1, p2)) {
	using FunctionType = decltype(checkCollisions(p0, p1, p2))(*)(GJBaseGameLayer*, PlayerObject*, float, bool);
	static auto func = wrapFunction(base::get() + 0x20e330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GJBaseGameLayer::checkRepellPlayer() -> decltype(checkRepellPlayer()) {
	using FunctionType = decltype(checkRepellPlayer())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x233de0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::checkSpawnObjects() -> decltype(checkSpawnObjects()) {
	using FunctionType = decltype(checkSpawnObjects())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x215410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::collisionCheckObjects(PlayerObject* p0, gd::vector<GameObject*>* p1, int p2, float p3) -> decltype(collisionCheckObjects(p0, p1, p2, p3)) {
	using FunctionType = decltype(collisionCheckObjects(p0, p1, p2, p3))(*)(GJBaseGameLayer*, PlayerObject*, gd::vector<GameObject*>*, int, float);
	static auto func = wrapFunction(base::get() + 0x20f480, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GJBaseGameLayer::convertToClosestDirection(float p0, float p1) -> decltype(convertToClosestDirection(p0, p1)) {
	using FunctionType = decltype(convertToClosestDirection(p0, p1))(*)(GJBaseGameLayer*, float, float);
	static auto func = wrapFunction(base::get() + 0x2295d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::createBackground(int p0) -> decltype(createBackground(p0)) {
	using FunctionType = decltype(createBackground(p0))(*)(GJBaseGameLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2064e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::createGroundLayer(int p0, int p1) -> decltype(createGroundLayer(p0, p1)) {
	using FunctionType = decltype(createGroundLayer(p0, p1))(*)(GJBaseGameLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x206920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::createMiddleground(int p0) -> decltype(createMiddleground(p0)) {
	using FunctionType = decltype(createMiddleground(p0))(*)(GJBaseGameLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2067a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::createPlayer() -> decltype(createPlayer()) {
	using FunctionType = decltype(createPlayer())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x205fd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::createPlayerCollisionBlock() -> decltype(createPlayerCollisionBlock()) {
	using FunctionType = decltype(createPlayerCollisionBlock())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x212e90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::createTextLayers() -> decltype(createTextLayers()) {
	using FunctionType = decltype(createTextLayers())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x209960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::destroyObject(GameObject* p0) -> decltype(destroyObject(p0)) {
	using FunctionType = decltype(destroyObject(p0))(*)(GJBaseGameLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x210bb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::exitStaticCamera(bool exitX, bool exitY, float time, int easingType, float easingRate, bool smoothVelocity, float smoothVelocityMod, bool exitInstant) -> decltype(exitStaticCamera(exitX, exitY, time, easingType, easingRate, smoothVelocity, smoothVelocityMod, exitInstant)) {
	using FunctionType = decltype(exitStaticCamera(exitX, exitY, time, easingType, easingRate, smoothVelocity, smoothVelocityMod, exitInstant))(*)(GJBaseGameLayer*, bool, bool, float, int, float, bool, float, bool);
	static auto func = wrapFunction(base::get() + 0x2390e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, exitX, exitY, time, easingType, easingRate, smoothVelocity, smoothVelocityMod, exitInstant);
}

auto GJBaseGameLayer::flipGravity(PlayerObject* p0, bool p1, bool p2) -> decltype(flipGravity(p0, p1, p2)) {
	using FunctionType = decltype(flipGravity(p0, p1, p2))(*)(GJBaseGameLayer*, PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x20d640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GJBaseGameLayer::gameEventTriggered(GJGameEvent p0, int p1, int p2) -> decltype(gameEventTriggered(p0, p1, p2)) {
	using FunctionType = decltype(gameEventTriggered(p0, p1, p2))(*)(GJBaseGameLayer*, GJGameEvent, int, int);
	static auto func = wrapFunction(base::get() + 0x22c8a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GJBaseGameLayer::generateSpawnRemap() -> decltype(generateSpawnRemap()) {
	using FunctionType = decltype(generateSpawnRemap())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x218c00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::getAreaObjectValue(EnterEffectInstance* p0, GameObject* p1, cocos2d::CCPoint& p2, bool& p3) -> decltype(getAreaObjectValue(p0, p1, p2, p3)) {
	using FunctionType = decltype(getAreaObjectValue(p0, p1, p2, p3))(*)(GJBaseGameLayer*, EnterEffectInstance*, GameObject*, cocos2d::CCPoint&, bool&);
	static auto func = wrapFunction(base::get() + 0x222d90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GJBaseGameLayer::getEasedAreaValue(GameObject* p0, EnterEffectInstance* p1, float p2, bool p3, int p4) -> decltype(getEasedAreaValue(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(getEasedAreaValue(p0, p1, p2, p3, p4))(*)(GJBaseGameLayer*, GameObject*, EnterEffectInstance*, float, bool, int);
	static auto func = wrapFunction(base::get() + 0x222f80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto GJBaseGameLayer::getGroundHeightForMode(int p0) -> decltype(getGroundHeightForMode(p0)) {
	using FunctionType = decltype(getGroundHeightForMode(p0))(*)(GJBaseGameLayer*, int);
	static auto func = wrapFunction(base::get() + 0x20c890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::getGroup(int p0) -> decltype(getGroup(p0)) {
	using FunctionType = decltype(getGroup(p0))(*)(GJBaseGameLayer*, int);
	static auto func = wrapFunction(base::get() + 0x21eed0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::getItemValue(int p0, int p1) -> decltype(getItemValue(p0, p1)) {
	using FunctionType = decltype(getItemValue(p0, p1))(*)(GJBaseGameLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x22ea60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::getMaxPortalY() -> decltype(getMaxPortalY()) {
	using FunctionType = decltype(getMaxPortalY())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x20e2b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::getMinDistance(cocos2d::CCPoint p0, cocos2d::CCArray* p1, float p2, int p3) -> decltype(getMinDistance(p0, p1, p2, p3)) {
	using FunctionType = decltype(getMinDistance(p0, p1, p2, p3))(*)(GJBaseGameLayer*, cocos2d::CCPoint, cocos2d::CCArray*, float, int);
	static auto func = wrapFunction(base::get() + 0x23c430, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GJBaseGameLayer::getMinPortalY() -> decltype(getMinPortalY()) {
	using FunctionType = decltype(getMinPortalY())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x20e1d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::getModifiedDelta(float p0) -> decltype(getModifiedDelta(p0)) {
	using FunctionType = decltype(getModifiedDelta(p0))(*)(GJBaseGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0x232060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::groupStickyObjects(cocos2d::CCArray* p0) -> decltype(groupStickyObjects(p0)) {
	using FunctionType = decltype(groupStickyObjects(p0))(*)(GJBaseGameLayer*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x21f7b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::handleButton(bool down, int button, bool isPlayer1) -> decltype(handleButton(down, button, isPlayer1)) {
	using FunctionType = decltype(handleButton(down, button, isPlayer1))(*)(GJBaseGameLayer*, bool, int, bool);
	static auto func = wrapFunction(base::get() + 0x22e190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, down, button, isPlayer1);
}

auto GJBaseGameLayer::hasUniqueCoin(EffectGameObject* p0) -> decltype(hasUniqueCoin(p0)) {
	using FunctionType = decltype(hasUniqueCoin(p0))(*)(GJBaseGameLayer*, EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x211220, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::increaseBatchNodeCapacity() -> decltype(increaseBatchNodeCapacity()) {
	using FunctionType = decltype(increaseBatchNodeCapacity())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x2078e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

bool GJBaseGameLayer::isFlipping() {
        return m_gameState.m_levelFlipping != 0.f && m_gameState.m_levelFlipping != 1.f;
    }

auto GJBaseGameLayer::lightningFlash(cocos2d::CCPoint from, cocos2d::CCPoint to, cocos2d::ccColor3B color, float lineWidth, float duration, int displacement, bool flash, float opacity) -> decltype(lightningFlash(from, to, color, lineWidth, duration, displacement, flash, opacity)) {
	using FunctionType = decltype(lightningFlash(from, to, color, lineWidth, duration, displacement, flash, opacity))(*)(GJBaseGameLayer*, cocos2d::CCPoint, cocos2d::CCPoint, cocos2d::ccColor3B, float, float, int, bool, float);
	static auto func = wrapFunction(base::get() + 0x240770, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, from, to, color, lineWidth, duration, displacement, flash, opacity);
}

auto GJBaseGameLayer::loadLevelSettings() -> decltype(loadLevelSettings()) {
	using FunctionType = decltype(loadLevelSettings())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x234770, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::loadStartPosObject() -> decltype(loadStartPosObject()) {
	using FunctionType = decltype(loadStartPosObject())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x230000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::loadUpToPosition(float p0, int p1, int p2) -> decltype(loadUpToPosition(p0, p1, p2)) {
	using FunctionType = decltype(loadUpToPosition(p0, p1, p2))(*)(GJBaseGameLayer*, float, int, int);
	static auto func = wrapFunction(base::get() + 0x2301a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GJBaseGameLayer::moveAreaObject(GameObject* p0, float p1, float p2) -> decltype(moveAreaObject(p0, p1, p2)) {
	using FunctionType = decltype(moveAreaObject(p0, p1, p2))(*)(GJBaseGameLayer*, GameObject*, float, float);
	static auto func = wrapFunction(base::get() + 0x2257d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GJBaseGameLayer::moveObjects(cocos2d::CCArray* p0, double p1, double p2, bool p3) -> decltype(moveObjects(p0, p1, p2, p3)) {
	using FunctionType = decltype(moveObjects(p0, p1, p2, p3))(*)(GJBaseGameLayer*, cocos2d::CCArray*, double, double, bool);
	static auto func = wrapFunction(base::get() + 0x228a70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GJBaseGameLayer::objectTypeToGameEvent(int p0) -> decltype(objectTypeToGameEvent(p0)) {
	using FunctionType = decltype(objectTypeToGameEvent(p0))(*)(GJBaseGameLayer*, int);
	static auto func = wrapFunction(base::get() + 0x22ce10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::pauseAudio() -> decltype(pauseAudio()) {
	using FunctionType = decltype(pauseAudio())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x231d60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::pickupItem(EffectGameObject* p0) -> decltype(pickupItem(p0)) {
	using FunctionType = decltype(pickupItem(p0))(*)(GJBaseGameLayer*, EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x210cd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::playerCircleCollision(PlayerObject* p0, GameObject* p1) -> decltype(playerCircleCollision(p0, p1)) {
	using FunctionType = decltype(playerCircleCollision(p0, p1))(*)(GJBaseGameLayer*, PlayerObject*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x20c930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::playerTouchedRing(PlayerObject* p0, RingObject* p1) -> decltype(playerTouchedRing(p0, p1)) {
	using FunctionType = decltype(playerTouchedRing(p0, p1))(*)(GJBaseGameLayer*, PlayerObject*, RingObject*);
	static auto func = wrapFunction(base::get() + 0x212960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::playerTouchedTrigger(PlayerObject* p0, EffectGameObject* p1) -> decltype(playerTouchedTrigger(p0, p1)) {
	using FunctionType = decltype(playerTouchedTrigger(p0, p1))(*)(GJBaseGameLayer*, PlayerObject*, EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x212a70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::playerWillSwitchMode(PlayerObject* p0, GameObject* p1) -> decltype(playerWillSwitchMode(p0, p1)) {
	using FunctionType = decltype(playerWillSwitchMode(p0, p1))(*)(GJBaseGameLayer*, PlayerObject*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x20da30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::playExitDualEffect(PlayerObject* p0) -> decltype(playExitDualEffect(p0)) {
	using FunctionType = decltype(playExitDualEffect(p0))(*)(GJBaseGameLayer*, PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x2119a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::positionForShaderTarget(int p0) -> decltype(positionForShaderTarget(p0)) {
	using FunctionType = decltype(positionForShaderTarget(p0))(*)(GJBaseGameLayer*, int);
	static auto func = wrapFunction(base::get() + 0x21e1a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::processActivatedAudioTriggers(float p0) -> decltype(processActivatedAudioTriggers(p0)) {
	using FunctionType = decltype(processActivatedAudioTriggers(p0))(*)(GJBaseGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0x23d3e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::processAdvancedFollowAction(AdvancedFollowInstance& p0, bool p1, float p2) -> decltype(processAdvancedFollowAction(p0, p1, p2)) {
	using FunctionType = decltype(processAdvancedFollowAction(p0, p1, p2))(*)(GJBaseGameLayer*, AdvancedFollowInstance&, bool, float);
	static auto func = wrapFunction(base::get() + 0x22a020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GJBaseGameLayer::processAdvancedFollowActions(float p0) -> decltype(processAdvancedFollowActions(p0)) {
	using FunctionType = decltype(processAdvancedFollowActions(p0))(*)(GJBaseGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0x229e00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::processAreaActions(float p0, bool p1) -> decltype(processAreaActions(p0, p1)) {
	using FunctionType = decltype(processAreaActions(p0, p1))(*)(GJBaseGameLayer*, float, bool);
	static auto func = wrapFunction(base::get() + 0x223ce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::processAreaEffects(gd::vector<EnterEffectInstance>* p0, GJAreaActionType p1, float p2, bool p3) -> decltype(processAreaEffects(p0, p1, p2, p3)) {
	using FunctionType = decltype(processAreaEffects(p0, p1, p2, p3))(*)(GJBaseGameLayer*, gd::vector<EnterEffectInstance>*, GJAreaActionType, float, bool);
	static auto func = wrapFunction(base::get() + 0x223100, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GJBaseGameLayer::processAreaMoveGroupAction(cocos2d::CCArray* p0, EnterEffectInstance* p1, cocos2d::CCPoint p2, int p3, int p4, int p5, int p6, int p7, bool p8, bool p9) -> decltype(processAreaMoveGroupAction(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9)) {
	using FunctionType = decltype(processAreaMoveGroupAction(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9))(*)(GJBaseGameLayer*, cocos2d::CCArray*, EnterEffectInstance*, cocos2d::CCPoint, int, int, int, int, int, bool, bool);
	static auto func = wrapFunction(base::get() + 0x2251f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
}

auto GJBaseGameLayer::processAreaRotateGroupAction(cocos2d::CCArray* p0, EnterEffectInstance* p1, cocos2d::CCPoint p2, int p3, int p4, int p5, int p6, int p7, bool p8, bool p9) -> decltype(processAreaRotateGroupAction(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9)) {
	using FunctionType = decltype(processAreaRotateGroupAction(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9))(*)(GJBaseGameLayer*, cocos2d::CCArray*, EnterEffectInstance*, cocos2d::CCPoint, int, int, int, int, int, bool, bool);
	static auto func = wrapFunction(base::get() + 0x224ab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
}

auto GJBaseGameLayer::processAreaTintGroupAction(cocos2d::CCArray* p0, EnterEffectInstance* p1, cocos2d::CCPoint p2, bool p3) -> decltype(processAreaTintGroupAction(p0, p1, p2, p3)) {
	using FunctionType = decltype(processAreaTintGroupAction(p0, p1, p2, p3))(*)(GJBaseGameLayer*, cocos2d::CCArray*, EnterEffectInstance*, cocos2d::CCPoint, bool);
	static auto func = wrapFunction(base::get() + 0x2258c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GJBaseGameLayer::processAreaTransformGroupAction(cocos2d::CCArray* p0, EnterEffectInstance* p1, cocos2d::CCPoint p2, int p3, int p4, int p5, int p6, int p7, bool p8, bool p9) -> decltype(processAreaTransformGroupAction(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9)) {
	using FunctionType = decltype(processAreaTransformGroupAction(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9))(*)(GJBaseGameLayer*, cocos2d::CCArray*, EnterEffectInstance*, cocos2d::CCPoint, int, int, int, int, int, bool, bool);
	static auto func = wrapFunction(base::get() + 0x223f40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
}

GameObject* GJBaseGameLayer::processCameraObject(GameObject* object, PlayerObject* player) {
        if (object) {
            player->m_lastPortalPos = object->getPosition();
            player->m_lastActivatedPortal = object;
        }
        auto ret = object;
        if (m_gameState.m_isDualMode && m_gameState.m_unkGameObjPtr2) ret = m_gameState.m_unkGameObjPtr2;
        if (object) m_gameState.m_unkGameObjPtr1 = object;
        return ret;
    }

auto GJBaseGameLayer::processCommands(float p0) -> decltype(processCommands(p0)) {
	using FunctionType = decltype(processCommands(p0))(*)(GJBaseGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0x234170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::processDynamicObjectActions(int p0, float p1) -> decltype(processDynamicObjectActions(p0, p1)) {
	using FunctionType = decltype(processDynamicObjectActions(p0, p1))(*)(GJBaseGameLayer*, int, float);
	static auto func = wrapFunction(base::get() + 0x228fa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::processFollowActions() -> decltype(processFollowActions()) {
	using FunctionType = decltype(processFollowActions())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x22b2a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::processMoveActions() -> decltype(processMoveActions()) {
	using FunctionType = decltype(processMoveActions())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x2282d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::processMoveActionsStep(float p0, bool p1) -> decltype(processMoveActionsStep(p0, p1)) {
	using FunctionType = decltype(processMoveActionsStep(p0, p1))(*)(GJBaseGameLayer*, float, bool);
	static auto func = wrapFunction(base::get() + 0x2262f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::processOptionsTrigger(GameOptionsTrigger* p0) -> decltype(processOptionsTrigger(p0)) {
	using FunctionType = decltype(processOptionsTrigger(p0))(*)(GJBaseGameLayer*, GameOptionsTrigger*);
	static auto func = wrapFunction(base::get() + 0x21e9a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::processPlayerFollowActions(float p0) -> decltype(processPlayerFollowActions(p0)) {
	using FunctionType = decltype(processPlayerFollowActions(p0))(*)(GJBaseGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0x228bf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::processQueuedAudioTriggers() -> decltype(processQueuedAudioTriggers()) {
	using FunctionType = decltype(processQueuedAudioTriggers())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x235550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::processQueuedButtons() -> decltype(processQueuedButtons()) {
	using FunctionType = decltype(processQueuedButtons())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x22c7f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::processRotationActions() -> decltype(processRotationActions()) {
	using FunctionType = decltype(processRotationActions())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x226510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::processSFXObjects() -> decltype(processSFXObjects()) {
	using FunctionType = decltype(processSFXObjects())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x23b480, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::processTransformActions(bool p0) -> decltype(processTransformActions(p0)) {
	using FunctionType = decltype(processTransformActions(p0))(*)(GJBaseGameLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x2273a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void GJBaseGameLayer::queueButton(int button, bool push, bool isPlayer2) {
        if (button <= 0 || button > 3) {
            return;
        }
        PlayerButtonCommand command = {};
        command.m_button = (PlayerButton) button;
        command.m_isPush = push;
        command.m_isPlayer2 = isPlayer2;
        m_queuedButtons.push_back(command);
    }

auto GJBaseGameLayer::refreshCounterLabels() -> decltype(refreshCounterLabels()) {
	using FunctionType = decltype(refreshCounterLabels())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x22fe50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::removeFromGroups(GameObject* p0) -> decltype(removeFromGroups(p0)) {
	using FunctionType = decltype(removeFromGroups(p0))(*)(GJBaseGameLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x21ed10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::removeObjectFromSection(GameObject* p0) -> decltype(removeObjectFromSection(p0)) {
	using FunctionType = decltype(removeObjectFromSection(p0))(*)(GJBaseGameLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x221a80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::resetActiveEnterEffects() -> decltype(resetActiveEnterEffects()) {
	using FunctionType = decltype(resetActiveEnterEffects())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x209060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::resetAreaObjectValues(GameObject* p0, bool p1) -> decltype(resetAreaObjectValues(p0, p1)) {
	using FunctionType = decltype(resetAreaObjectValues(p0, p1))(*)(GJBaseGameLayer*, GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x222950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::resetAudio() -> decltype(resetAudio()) {
	using FunctionType = decltype(resetAudio())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x231fc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::resetCamera() -> decltype(resetCamera()) {
	using FunctionType = decltype(resetCamera())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x239570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::resetGradientLayers() -> decltype(resetGradientLayers()) {
	using FunctionType = decltype(resetGradientLayers())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x21bbf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::resetLevelVariables() -> decltype(resetLevelVariables()) {
	using FunctionType = decltype(resetLevelVariables())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x234ab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::resetPlayer() -> decltype(resetPlayer()) {
	using FunctionType = decltype(resetPlayer())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x20cbf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::resetSpawnChannelIndex() -> decltype(resetSpawnChannelIndex()) {
	using FunctionType = decltype(resetSpawnChannelIndex())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x23f890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::resetStaticCamera(bool p0, bool p1) -> decltype(resetStaticCamera(p0, p1)) {
	using FunctionType = decltype(resetStaticCamera(p0, p1))(*)(GJBaseGameLayer*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x239850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

void GJBaseGameLayer::setStartPosObject(StartPosObject* startPos) {
        if (startPos != m_startPosObject) {
            if (startPos) {
                startPos->retain();
            }
            if (m_startPosObject) {
                m_startPosObject->release();
            }
            m_startPosObject = startPos;
        }
    }

auto GJBaseGameLayer::setupLayers() -> decltype(setupLayers()) {
	using FunctionType = decltype(setupLayers())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x203760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::setupLevelStart(LevelSettingsObject* p0) -> decltype(setupLevelStart(p0)) {
	using FunctionType = decltype(setupLevelStart(p0))(*)(GJBaseGameLayer*, LevelSettingsObject*);
	static auto func = wrapFunction(base::get() + 0x20cd60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::setupReplay(gd::string p0) -> decltype(setupReplay(p0)) {
	using FunctionType = decltype(setupReplay(p0))(*)(GJBaseGameLayer*, gd::string);
	static auto func = wrapFunction(base::get() + 0x234360, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::shakeCamera(float duration, float strength, float interval) -> decltype(shakeCamera(duration, strength, interval)) {
	using FunctionType = decltype(shakeCamera(duration, strength, interval))(*)(GJBaseGameLayer*, float, float, float);
	static auto func = wrapFunction(base::get() + 0x2356c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, duration, strength, interval);
}

auto GJBaseGameLayer::shouldExitHackedLevel() -> decltype(shouldExitHackedLevel()) {
	using FunctionType = decltype(shouldExitHackedLevel())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x205d10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::sortSectionVector() -> decltype(sortSectionVector()) {
	using FunctionType = decltype(sortSectionVector())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x221cc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::spawnParticle(char const* plist, int zOrder, cocos2d::tCCPositionType positionType, cocos2d::CCPoint position) -> decltype(spawnParticle(plist, zOrder, positionType, position)) {
	using FunctionType = decltype(spawnParticle(plist, zOrder, positionType, position))(*)(GJBaseGameLayer*, char const*, int, cocos2d::tCCPositionType, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x239d50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, plist, zOrder, positionType, position);
}

auto GJBaseGameLayer::speedForShaderTarget(int p0) -> decltype(speedForShaderTarget(p0)) {
	using FunctionType = decltype(speedForShaderTarget(p0))(*)(GJBaseGameLayer*, int);
	static auto func = wrapFunction(base::get() + 0x21e250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::staticObjectsInRect(cocos2d::CCRect p0, bool p1) -> decltype(staticObjectsInRect(p0, p1)) {
	using FunctionType = decltype(staticObjectsInRect(p0, p1))(*)(GJBaseGameLayer*, cocos2d::CCRect, bool);
	static auto func = wrapFunction(base::get() + 0x20bda0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

void GJBaseGameLayer::switchToFlyMode(PlayerObject* player, GameObject* object, bool unused, int type) {
        player->switchedToMode((GameObjectType)type);
        auto cameraObject = this->processCameraObject(object, player);
        auto noEffects = cameraObject && cameraObject->m_hasNoEffects;
        switch (type) {
            case 5:
                player->toggleFlyMode(true, noEffects);
                break;
            case 19:
                player->toggleBirdMode(true, noEffects);
                break;
            case 26:
                player->toggleDartMode(true, noEffects);
                break;
            case 41:
                player->toggleSwingMode(true, noEffects);
                break;
        }
        this->toggleGlitter(true);
    }

auto GJBaseGameLayer::syncBGTextures() -> decltype(syncBGTextures()) {
	using FunctionType = decltype(syncBGTextures())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x234a10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::teleportPlayer(TeleportPortalObject* p0, PlayerObject* p1) -> decltype(teleportPlayer(p0, p1)) {
	using FunctionType = decltype(teleportPlayer(p0, p1))(*)(GJBaseGameLayer*, TeleportPortalObject*, PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x20aa80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::toggleAudioVisualizer(bool p0) -> decltype(toggleAudioVisualizer(p0)) {
	using FunctionType = decltype(toggleAudioVisualizer(p0))(*)(GJBaseGameLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x242550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::toggleDualMode(GameObject* p0, bool p1, PlayerObject* p2, bool p3) -> decltype(toggleDualMode(p0, p1, p2, p3)) {
	using FunctionType = decltype(toggleDualMode(p0, p1, p2, p3))(*)(GJBaseGameLayer*, GameObject*, bool, PlayerObject*, bool);
	static auto func = wrapFunction(base::get() + 0x2113f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GJBaseGameLayer::toggleFlipped(bool p0, bool p1) -> decltype(toggleFlipped(p0, p1)) {
	using FunctionType = decltype(toggleFlipped(p0, p1))(*)(GJBaseGameLayer*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x240240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

void GJBaseGameLayer::toggleLockPlayer(bool disable, bool p2) {
        auto player = p2 ? m_player2 : m_player1;
        if (disable) player->disablePlayerControls();
        else player->enablePlayerControls();
    }

void GJBaseGameLayer::togglePlayerVisibility(bool visible, bool player1) {
        if (player1)
            this->m_player1->toggleVisibility(visible);
        else
            this->m_player2->toggleVisibility(visible);
    }

void GJBaseGameLayer::togglePlayerVisibility(bool visible) {
        this->togglePlayerVisibility(visible, true);
        this->togglePlayerVisibility(visible, false);
    }

auto GJBaseGameLayer::triggerGradientCommand(GradientTriggerObject* p0) -> decltype(triggerGradientCommand(p0)) {
	using FunctionType = decltype(triggerGradientCommand(p0))(*)(GJBaseGameLayer*, GradientTriggerObject*);
	static auto func = wrapFunction(base::get() + 0x21a3a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::tryGetMainObject(int p0) -> decltype(tryGetMainObject(p0)) {
	using FunctionType = decltype(tryGetMainObject(p0))(*)(GJBaseGameLayer*, int);
	static auto func = wrapFunction(base::get() + 0x21f170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::tryGetObject(int p0) -> decltype(tryGetObject(p0)) {
	using FunctionType = decltype(tryGetObject(p0))(*)(GJBaseGameLayer*, int);
	static auto func = wrapFunction(base::get() + 0x21f1e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::ungroupStickyObjects(cocos2d::CCArray* p0) -> decltype(ungroupStickyObjects(p0)) {
	using FunctionType = decltype(ungroupStickyObjects(p0))(*)(GJBaseGameLayer*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x21f8d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::updateAudioVisualizer() -> decltype(updateAudioVisualizer()) {
	using FunctionType = decltype(updateAudioVisualizer())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x2422f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::updateCamera(float p0) -> decltype(updateCamera(p0)) {
	using FunctionType = decltype(updateCamera(p0))(*)(GJBaseGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0x235760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void GJBaseGameLayer::updateCameraMode(EffectGameObject* obj, bool updateDual) {
        auto cameraFree = obj->m_cameraIsFreeMode;
        auto freeMode = m_gameState.m_unkBool8;
        m_gameState.m_unkBool8 = cameraFree;
        m_gameState.m_unkBool9 = obj->m_cameraDisableGridSnap;
        if (obj->m_cameraEditCameraSettings) {
            m_gameState.m_unkFloat3 = std::clamp(obj->m_cameraEasingValue, 1.f, 40.f);
            m_gameState.m_unkFloat2 = std::clamp(obj->m_cameraPaddingValue, 0.f, 1.f);
        }
        if (cameraFree != freeMode && updateDual) this->updateDualGround(m_player1, m_gameState.dualRelated, false, 0.f);
    }

auto GJBaseGameLayer::updateCameraOffsetX(float p0, float p1, int p2, float p3, int p4, int p5) -> decltype(updateCameraOffsetX(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(updateCameraOffsetX(p0, p1, p2, p3, p4, p5))(*)(GJBaseGameLayer*, float, float, int, float, int, int);
	static auto func = wrapFunction(base::get() + 0x230810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto GJBaseGameLayer::updateCameraOffsetY(float p0, float p1, int p2, float p3, int p4, int p5) -> decltype(updateCameraOffsetY(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(updateCameraOffsetY(p0, p1, p2, p3, p4, p5))(*)(GJBaseGameLayer*, float, float, int, float, int, int);
	static auto func = wrapFunction(base::get() + 0x2308b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto GJBaseGameLayer::updateCounters(int p0, int p1) -> decltype(updateCounters(p0, p1)) {
	using FunctionType = decltype(updateCounters(p0, p1))(*)(GJBaseGameLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x22e760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::updateDualGround(PlayerObject* p0, int p1, bool p2, float p3) -> decltype(updateDualGround(p0, p1, p2, p3)) {
	using FunctionType = decltype(updateDualGround(p0, p1, p2, p3))(*)(GJBaseGameLayer*, PlayerObject*, int, bool, float);
	static auto func = wrapFunction(base::get() + 0x20dcc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GJBaseGameLayer::updateGradientLayers() -> decltype(updateGradientLayers()) {
	using FunctionType = decltype(updateGradientLayers())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x21a830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::updateGuideArt() -> decltype(updateGuideArt()) {
	using FunctionType = decltype(updateGuideArt())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x240130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::updateLevelColors() -> decltype(updateLevelColors()) {
	using FunctionType = decltype(updateLevelColors())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x207150, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::updateMaxGameplayY() -> decltype(updateMaxGameplayY()) {
	using FunctionType = decltype(updateMaxGameplayY())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x234930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::updateMGOffsetY(float p0, float p1, int p2, float p3, int p4, int p5) -> decltype(updateMGOffsetY(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(updateMGOffsetY(p0, p1, p2, p3, p4, p5))(*)(GJBaseGameLayer*, float, float, int, float, int, int);
	static auto func = wrapFunction(base::get() + 0x230950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto GJBaseGameLayer::updateOBB2(cocos2d::CCRect p0) -> decltype(updateOBB2(p0)) {
	using FunctionType = decltype(updateOBB2(p0))(*)(GJBaseGameLayer*, cocos2d::CCRect);
	static auto func = wrapFunction(base::get() + 0x6da50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::updateProximityVolumeEffects() -> decltype(updateProximityVolumeEffects()) {
	using FunctionType = decltype(updateProximityVolumeEffects())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x23bd90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::updateShaderLayer(float p0) -> decltype(updateShaderLayer(p0)) {
	using FunctionType = decltype(updateShaderLayer(p0))(*)(GJBaseGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0x21cf00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::updateSpecialGroupData() -> decltype(updateSpecialGroupData()) {
	using FunctionType = decltype(updateSpecialGroupData())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x208c00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::updateSpecialLabels() -> decltype(updateSpecialLabels()) {
	using FunctionType = decltype(updateSpecialLabels())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x2338f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::updateStaticCameraPos(cocos2d::CCPoint pos, bool staticX, bool staticY, bool followOrSmoothEase, float time, int easingType, float easingRate) -> decltype(updateStaticCameraPos(pos, staticX, staticY, followOrSmoothEase, time, easingType, easingRate)) {
	using FunctionType = decltype(updateStaticCameraPos(pos, staticX, staticY, followOrSmoothEase, time, easingType, easingRate))(*)(GJBaseGameLayer*, cocos2d::CCPoint, bool, bool, bool, float, int, float);
	static auto func = wrapFunction(base::get() + 0x238ca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, pos, staticX, staticY, followOrSmoothEase, time, easingType, easingRate);
}

auto GJBaseGameLayer::updateStaticCameraPosToGroup(int p0, bool p1, bool p2, bool p3, float p4, float p5, int p6, float p7, bool p8, float p9) -> decltype(updateStaticCameraPosToGroup(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9)) {
	using FunctionType = decltype(updateStaticCameraPosToGroup(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9))(*)(GJBaseGameLayer*, int, bool, bool, bool, float, float, int, float, bool, float);
	static auto func = wrapFunction(base::get() + 0x2388b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
}

auto GJBaseGameLayer::updateTimerLabels() -> decltype(updateTimerLabels()) {
	using FunctionType = decltype(updateTimerLabels())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x22fae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::updateZoom(float p0, float p1, int p2, float p3, int p4, int p5) -> decltype(updateZoom(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(updateZoom(p0, p1, p2, p3, p4, p5))(*)(GJBaseGameLayer*, float, float, int, float, int, int);
	static auto func = wrapFunction(base::get() + 0x230590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto GJBaseGameLayer::volumeForProximityEffect(SFXTriggerInstance& p0) -> decltype(volumeForProximityEffect(p0)) {
	using FunctionType = decltype(volumeForProximityEffect(p0))(*)(GJBaseGameLayer*, SFXTriggerInstance&);
	static auto func = wrapFunction(base::get() + 0x23c060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBigSprite::init() -> decltype(init()) {
	throw std::runtime_error("GJBigSprite::init not implemented");
}

auto GJBigSpriteNode::init() -> decltype(init()) {
	throw std::runtime_error("GJBigSpriteNode::init not implemented");
}

auto GJChestSprite::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x3ba270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJChestSprite::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&GJChestSprite::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(GJChestSprite*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x3ba400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJChestSprite::setColor(cocos2d::ccColor3B const& p0) -> decltype(setColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B const&>::func(&GJChestSprite::setColor), this);
	using FunctionType = decltype(setColor(p0))(*)(GJChestSprite*, cocos2d::ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x3ba340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

bool GJChestSprite::init(int chestType) {
        if (!cocos2d::CCSprite::init()) return false;
        m_chestType = chestType;
        this->setContentSize({ 0, 0 });
        this->switchToState(ChestSpriteState::Closed, false);
        return true;
    }

auto GJChestSprite::switchToState(ChestSpriteState p0, bool p1) -> decltype(switchToState(p0, p1)) {
	using FunctionType = decltype(switchToState(p0, p1))(*)(GJChestSprite*, ChestSpriteState, bool);
	static auto func = wrapFunction(base::get() + 0x3ba470, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJColorSetupLayer::create(LevelSettingsObject* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(LevelSettingsObject*);
	static auto func = wrapFunction(base::get() + 0x24ef80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJColorSetupLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJColorSetupLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(GJColorSetupLayer*);
	static auto func = wrapFunction(base::get() + 0x24fda0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJColorSetupLayer::colorSelectClosed(cocos2d::CCNode* p0) -> decltype(colorSelectClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*>::func(&GJColorSetupLayer::colorSelectClosed), this);
	using FunctionType = decltype(colorSelectClosed(p0))(*)(GJColorSetupLayer*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x24fcd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJColorSetupLayer::init(LevelSettingsObject* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GJColorSetupLayer*, LevelSettingsObject*);
	static auto func = wrapFunction(base::get() + 0x24f0c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJColorSetupLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(GJColorSetupLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x24fd50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJColorSetupLayer::onColor(cocos2d::CCObject* sender) -> decltype(onColor(sender)) {
	using FunctionType = decltype(onColor(sender))(*)(GJColorSetupLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x24fc00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJColorSetupLayer::onPage(cocos2d::CCObject* sender) -> decltype(onPage(sender)) {
	using FunctionType = decltype(onPage(sender))(*)(GJColorSetupLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x24fbb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJColorSetupLayer::showPage(int p0) -> decltype(showPage(p0)) {
	using FunctionType = decltype(showPage(p0))(*)(GJColorSetupLayer*, int);
	static auto func = wrapFunction(base::get() + 0x24fce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJColorSetupLayer::updateSpriteColor(ColorChannelSprite* p0, cocos2d::CCLabelBMFont* p1, int p2) -> decltype(updateSpriteColor(p0, p1, p2)) {
	using FunctionType = decltype(updateSpriteColor(p0, p1, p2))(*)(GJColorSetupLayer*, ColorChannelSprite*, cocos2d::CCLabelBMFont*, int);
	static auto func = wrapFunction(base::get() + 0x24fa40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GJColorSetupLayer::updateSpriteColors() -> decltype(updateSpriteColors()) {
	using FunctionType = decltype(updateSpriteColors())(*)(GJColorSetupLayer*);
	static auto func = wrapFunction(base::get() + 0x24f920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJComment::init() -> decltype(init()) {
	throw std::runtime_error("GJComment::init not implemented");
}

auto GJCommentListLayer::create(BoomListView* listView, char const* title, cocos2d::ccColor4B color, float width, float height, bool blueBorder) -> decltype(create(listView, title, color, width, height, blueBorder)) {
	using FunctionType = decltype(create(listView, title, color, width, height, blueBorder))(*)(BoomListView*, char const*, cocos2d::ccColor4B, float, float, bool);
	static auto func = wrapFunction(base::get() + 0x28a320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(listView, title, color, width, height, blueBorder);
}

auto GJCommentListLayer::init(BoomListView* listView, char const* title, cocos2d::ccColor4B color, float width, float height, bool blueBorder) -> decltype(init(listView, title, color, width, height, blueBorder)) {
	using FunctionType = decltype(init(listView, title, color, width, height, blueBorder))(*)(GJCommentListLayer*, BoomListView*, char const*, cocos2d::ccColor4B, float, float, bool);
	static auto func = wrapFunction(base::get() + 0x28a440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, listView, title, color, width, height, blueBorder);
}

auto GJDifficultySprite::create(int p0, GJDifficultyName p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(int, GJDifficultyName);
	static auto func = wrapFunction(base::get() + 0x29d8d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GJDifficultySprite::getDifficultyFrame(int p0, GJDifficultyName p1) -> decltype(getDifficultyFrame(p0, p1)) {
	using FunctionType = decltype(getDifficultyFrame(p0, p1))(*)(int, GJDifficultyName);
	static auto func = wrapFunction(base::get() + 0x29d9b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GJDifficultySprite::updateDifficultyFrame(int p0, GJDifficultyName p1) -> decltype(updateDifficultyFrame(p0, p1)) {
	using FunctionType = decltype(updateDifficultyFrame(p0, p1))(*)(GJDifficultySprite*, int, GJDifficultyName);
	static auto func = wrapFunction(base::get() + 0x29da90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJDifficultySprite::updateFeatureState(GJFeatureState p0) -> decltype(updateFeatureState(p0)) {
	using FunctionType = decltype(updateFeatureState(p0))(*)(GJDifficultySprite*, GJFeatureState);
	static auto func = wrapFunction(base::get() + 0x29dbb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJEffectManager::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x2538f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJEffectManager::rewardedVideoFinished() -> decltype(rewardedVideoFinished()) {
	throw std::runtime_error("GJEffectManager::rewardedVideoFinished not implemented");
}

auto GJEffectManager::init() -> decltype(init()) {
	throw std::runtime_error("GJEffectManager::init not implemented");
}

auto GJEffectManager::activeColorForIndex(int p0) -> decltype(activeColorForIndex(p0)) {
	using FunctionType = decltype(activeColorForIndex(p0))(*)(GJEffectManager*, int);
	static auto func = wrapFunction(base::get() + 0x254930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJEffectManager::countForItem(int p0) -> decltype(countForItem(p0)) {
	using FunctionType = decltype(countForItem(p0))(*)(GJEffectManager*, int);
	static auto func = wrapFunction(base::get() + 0x25b060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJEffectManager::getColorAction(int p0) -> decltype(getColorAction(p0)) {
	using FunctionType = decltype(getColorAction(p0))(*)(GJEffectManager*, int);
	static auto func = wrapFunction(base::get() + 0x254870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJEffectManager::getColorSprite(int p0) -> decltype(getColorSprite(p0)) {
	using FunctionType = decltype(getColorSprite(p0))(*)(GJEffectManager*, int);
	static auto func = wrapFunction(base::get() + 0x254930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJEffectManager::loadFromState(EffectManagerState& p0) -> decltype(loadFromState(p0)) {
	using FunctionType = decltype(loadFromState(p0))(*)(GJEffectManager*, EffectManagerState&);
	static auto func = wrapFunction(base::get() + 0x25cb40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJEffectManager::playerButton(bool p0, bool p1) -> decltype(playerButton(p0, p1)) {
	using FunctionType = decltype(playerButton(p0, p1))(*)(GJEffectManager*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x25ae00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJEffectManager::postCollisionCheck() -> decltype(postCollisionCheck()) {
	using FunctionType = decltype(postCollisionCheck())(*)(GJEffectManager*);
	static auto func = wrapFunction(base::get() + 0x254f50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJEffectManager::postMoveActions() -> decltype(postMoveActions()) {
	using FunctionType = decltype(postMoveActions())(*)(GJEffectManager*);
	static auto func = wrapFunction(base::get() + 0x259470, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJEffectManager::prepareMoveActions(float p0, bool p1) -> decltype(prepareMoveActions(p0, p1)) {
	using FunctionType = decltype(prepareMoveActions(p0, p1))(*)(GJEffectManager*, float, bool);
	static auto func = wrapFunction(base::get() + 0x258060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJEffectManager::processColors() -> decltype(processColors()) {
	using FunctionType = decltype(processColors())(*)(GJEffectManager*);
	static auto func = wrapFunction(base::get() + 0x253fb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJEffectManager::reset() -> decltype(reset()) {
	using FunctionType = decltype(reset())(*)(GJEffectManager*);
	static auto func = wrapFunction(base::get() + 0x253d10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJEffectManager::resetEffects() -> decltype(resetEffects()) {
	using FunctionType = decltype(resetEffects())(*)(GJEffectManager*);
	static auto func = wrapFunction(base::get() + 0x254c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJEffectManager::saveToState(EffectManagerState& p0) -> decltype(saveToState(p0)) {
	using FunctionType = decltype(saveToState(p0))(*)(GJEffectManager*, EffectManagerState&);
	static auto func = wrapFunction(base::get() + 0x25c520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJEffectManager::setColorAction(ColorAction* p0, int p1) -> decltype(setColorAction(p0, p1)) {
	using FunctionType = decltype(setColorAction(p0, p1))(*)(GJEffectManager*, ColorAction*, int);
	static auto func = wrapFunction(base::get() + 0x254a90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJEffectManager::spawnGroup(int p0, float p1, bool p2, gd::vector<int> const& p3, int p4, int p5) -> decltype(spawnGroup(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(spawnGroup(p0, p1, p2, p3, p4, p5))(*)(GJEffectManager*, int, float, bool, gd::vector<int> const&, int, int);
	static auto func = wrapFunction(base::get() + 0x25a920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto GJEffectManager::storeTriggeredID(int p0, int p1) -> decltype(storeTriggeredID(p0, p1)) {
	using FunctionType = decltype(storeTriggeredID(p0, p1))(*)(GJEffectManager*, int, int);
	static auto func = wrapFunction(base::get() + 0x25ac60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJEffectManager::timeForItem(int p0) -> decltype(timeForItem(p0)) {
	using FunctionType = decltype(timeForItem(p0))(*)(GJEffectManager*, int);
	static auto func = wrapFunction(base::get() + 0x25bfd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJEffectManager::updateCountForItem(int p0, int p1) -> decltype(updateCountForItem(p0, p1)) {
	using FunctionType = decltype(updateCountForItem(p0, p1))(*)(GJEffectManager*, int, int);
	static auto func = wrapFunction(base::get() + 0x25b120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJEffectManager::updateEffects(float p0) -> decltype(updateEffects(p0)) {
	using FunctionType = decltype(updateEffects(p0))(*)(GJEffectManager*, float);
	static auto func = wrapFunction(base::get() + 0x254b10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJEffectManager::updatePulseEffects(float p0) -> decltype(updatePulseEffects(p0)) {
	using FunctionType = decltype(updatePulseEffects(p0))(*)(GJEffectManager*, float);
	static auto func = wrapFunction(base::get() + 0x259e30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJEffectManager::updateSpawnTriggers(float p0) -> decltype(updateSpawnTriggers(p0)) {
	using FunctionType = decltype(updateSpawnTriggers(p0))(*)(GJEffectManager*, float);
	static auto func = wrapFunction(base::get() + 0x25aa10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJEffectManager::updateTimers(float p0, float p1) -> decltype(updateTimers(p0, p1)) {
	using FunctionType = decltype(updateTimers(p0, p1))(*)(GJEffectManager*, float, float);
	static auto func = wrapFunction(base::get() + 0x25b9e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJGroundLayer::create(int p0, int p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(int, int);
	static auto func = wrapFunction(base::get() + 0x276870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

void GJGroundLayer::draw() {}

auto GJGroundLayer::showGround() -> decltype(showGround()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJGroundLayer::showGround), this);
	using FunctionType = decltype(showGround())(*)(GJGroundLayer*);
	static auto func = wrapFunction(base::get() + 0x2774c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJGroundLayer::fadeInGround(float p0) -> decltype(fadeInGround(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GJGroundLayer::fadeInGround), this);
	using FunctionType = decltype(fadeInGround(p0))(*)(GJGroundLayer*, float);
	static auto func = wrapFunction(base::get() + 0x2774d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJGroundLayer::fadeOutGround(float p0) -> decltype(fadeOutGround(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GJGroundLayer::fadeOutGround), this);
	using FunctionType = decltype(fadeOutGround(p0))(*)(GJGroundLayer*, float);
	static auto func = wrapFunction(base::get() + 0x2776c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJGroundLayer::createLine(int p0) -> decltype(createLine(p0)) {
	using FunctionType = decltype(createLine(p0))(*)(GJGroundLayer*, int);
	static auto func = wrapFunction(base::get() + 0x277120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJGroundLayer::init(int p0, int p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(GJGroundLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x2768f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJGroundLayer::loadGroundSprites(int p0, bool p1) -> decltype(loadGroundSprites(p0, p1)) {
	using FunctionType = decltype(loadGroundSprites(p0, p1))(*)(GJGroundLayer*, int, bool);
	static auto func = wrapFunction(base::get() + 0x276e60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJGroundLayer::scaleGround(float p0) -> decltype(scaleGround(p0)) {
	using FunctionType = decltype(scaleGround(p0))(*)(GJGroundLayer*, float);
	static auto func = wrapFunction(base::get() + 0x277310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJGroundLayer::updateShadows() -> decltype(updateShadows()) {
	using FunctionType = decltype(updateShadows())(*)(GJGroundLayer*);
	static auto func = wrapFunction(base::get() + 0x277550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJGroundLayer::updateShadowXPos(float p0, float p1) -> decltype(updateShadowXPos(p0, p1)) {
	using FunctionType = decltype(updateShadowXPos(p0, p1))(*)(GJGroundLayer*, float, float);
	static auto func = wrapFunction(base::get() + 0x2775f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJFlyGroundLayer::init() -> decltype(init()) {
	throw std::runtime_error("GJFlyGroundLayer::init not implemented");
}

auto GJFollowCommandLayer::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("GJFollowCommandLayer::determineStartValues not implemented");
}

auto GJFollowCommandLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("GJFollowCommandLayer::onClose not implemented");
}

auto GJFollowCommandLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&GJFollowCommandLayer::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(GJFollowCommandLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x26a850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJFollowCommandLayer::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(GJFollowCommandLayer*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x268e30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJFriendRequest::init() -> decltype(init()) {
	throw std::runtime_error("GJFriendRequest::init not implemented");
}

auto GJGameLevel::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x169b40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJGameLevel::create(cocos2d::CCDictionary* p0, bool p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(cocos2d::CCDictionary*, bool);
	static auto func = wrapFunction(base::get() + 0x1683e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GJGameLevel::lengthKeyToString(int key) -> decltype(lengthKeyToString(key)) {
	using FunctionType = decltype(lengthKeyToString(key))(*)(int);
	static auto func = wrapFunction(base::get() + 0x16a0d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(key);
}

auto GJGameLevel::encodeWithCoder(DS_Dictionary* p0) -> decltype(encodeWithCoder(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&GJGameLevel::encodeWithCoder), this);
	using FunctionType = decltype(encodeWithCoder(p0))(*)(GJGameLevel*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x16c090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJGameLevel::canEncode() -> decltype(canEncode()) {
	throw std::runtime_error("GJGameLevel::canEncode not implemented");
}

auto GJGameLevel::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJGameLevel::init), this);
	using FunctionType = decltype(init())(*)(GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x169ba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJGameLevel::copyLevelInfo(GJGameLevel* p0) -> decltype(copyLevelInfo(p0)) {
	using FunctionType = decltype(copyLevelInfo(p0))(*)(GJGameLevel*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x16aaa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJGameLevel::dataLoaded(DS_Dictionary* p0) -> decltype(dataLoaded(p0)) {
	using FunctionType = decltype(dataLoaded(p0))(*)(GJGameLevel*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x16b150, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJGameLevel::getAudioFileName() -> decltype(getAudioFileName()) {
	using FunctionType = decltype(getAudioFileName())(*)(GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x16a3f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJGameLevel::getAverageDifficulty() -> decltype(getAverageDifficulty()) {
	using FunctionType = decltype(getAverageDifficulty())(*)(GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x16a230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJGameLevel::getCoinKey(int coinNumber) -> decltype(getCoinKey(coinNumber)) {
	using FunctionType = decltype(getCoinKey(coinNumber))(*)(GJGameLevel*, int);
	static auto func = wrapFunction(base::get() + 0x16a2a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, coinNumber);
}

auto GJGameLevel::getUnpackedLevelDescription() -> decltype(getUnpackedLevelDescription()) {
	using FunctionType = decltype(getUnpackedLevelDescription())(*)(GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x16d150, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJGameLevel::handleStatsConflict(GJGameLevel* p0) -> decltype(handleStatsConflict(p0)) {
	using FunctionType = decltype(handleStatsConflict(p0))(*)(GJGameLevel*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x16cc80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJGameLevel::savePercentage(int percent, bool isPracticeMode, int clicks, int attempts, bool isChkValid) -> decltype(savePercentage(percent, isPracticeMode, clicks, attempts, isChkValid)) {
	using FunctionType = decltype(savePercentage(percent, isPracticeMode, clicks, attempts, isChkValid))(*)(GJGameLevel*, int, bool, int, int, bool);
	static auto func = wrapFunction(base::get() + 0x169db0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, percent, isPracticeMode, clicks, attempts, isChkValid);
}

auto GJGameLoadingLayer::transitionToLoadingLayer(GJGameLevel* level, bool editor) -> decltype(transitionToLoadingLayer(level, editor)) {
	using FunctionType = decltype(transitionToLoadingLayer(level, editor))(*)(GJGameLevel*, bool);
	static auto func = wrapFunction(base::get() + 0x242890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(level, editor);
}

auto GJGameLoadingLayer::onEnter() -> decltype(onEnter()) {
	throw std::runtime_error("GJGameLoadingLayer::onEnter not implemented");
}

auto GJGameLoadingLayer::onEnterTransitionDidFinish() -> decltype(onEnterTransitionDidFinish()) {
	throw std::runtime_error("GJGameLoadingLayer::onEnterTransitionDidFinish not implemented");
}

auto GJGameLoadingLayer::loadLevel() -> decltype(loadLevel()) {
	using FunctionType = decltype(loadLevel())(*)(GJGameLoadingLayer*);
	static auto func = wrapFunction(base::get() + 0x242a80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ListButtonBarDelegate::listButtonBarSwitchedPage(ListButtonBar* p0, int p1) -> decltype(listButtonBarSwitchedPage(p0, p1)) {
	throw std::runtime_error("ListButtonBarDelegate::listButtonBarSwitchedPage not implemented");
}

GJGarageLayer::GJGarageLayer() {
        m_usernameInput = nullptr;
        m_playerObject = nullptr;
        m_tabButtons = nullptr;
        m_pageButtons = nullptr;
        m_unknown = nullptr;
        m_supporter = nullptr;
        bool m_hasClosed = false;
        m_iconType = IconType::Cube;
        m_iconPages = {};
        m_cursor1 = nullptr;
        m_cursor2 = nullptr;
        m_currentIcon = nullptr;
        m_iconSelection = nullptr;
        m_leftArrow = nullptr;
        m_rightArrow = nullptr;
        m_navDotMenu = nullptr;
        m_iconID = 0;
        m_selectedIconType = IconType::Cube;
        m_videoPlaying = false;
    }

GJGarageLayer* GJGarageLayer::node() {
        auto ret = new GJGarageLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto GJGarageLayer::scene() -> decltype(scene()) {
	using FunctionType = decltype(scene())(*)();
	static auto func = wrapFunction(base::get() + 0x26b5b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJGarageLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJGarageLayer::init), this);
	using FunctionType = decltype(init())(*)(GJGarageLayer*);
	static auto func = wrapFunction(base::get() + 0x26b770, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJGarageLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJGarageLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(GJGarageLayer*);
	static auto func = wrapFunction(base::get() + 0x2718f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJGarageLayer::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&GJGarageLayer::textInputOpened), this);
	using FunctionType = decltype(textInputOpened(p0))(*)(GJGarageLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x26d390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJGarageLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&GJGarageLayer::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(GJGarageLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x26d580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJGarageLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&GJGarageLayer::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(GJGarageLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0xc3060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJGarageLayer::listButtonBarSwitchedPage(ListButtonBar* p0, int p1) -> decltype(listButtonBarSwitchedPage(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<ListButtonBar*, int>::func(&GJGarageLayer::listButtonBarSwitchedPage), this);
	using FunctionType = decltype(listButtonBarSwitchedPage(p0, p1))(*)(GJGarageLayer*, ListButtonBar*, int);
	static auto func = wrapFunction(base::get() + 0xc3110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJGarageLayer::showUnlockPopup(int p0, UnlockType p1) -> decltype(showUnlockPopup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, UnlockType>::func(&GJGarageLayer::showUnlockPopup), this);
	using FunctionType = decltype(showUnlockPopup(p0, p1))(*)(GJGarageLayer*, int, UnlockType);
	static auto func = wrapFunction(base::get() + 0x270320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJGarageLayer::updateRate() -> decltype(updateRate()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJGarageLayer::updateRate), this);
	using FunctionType = decltype(updateRate())(*)(GJGarageLayer*);
	static auto func = wrapFunction(base::get() + 0x270ff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJGarageLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&GJGarageLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(GJGarageLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x270bc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJGarageLayer::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DialogLayer*>::func(&GJGarageLayer::dialogClosed), this);
	using FunctionType = decltype(dialogClosed(p0))(*)(GJGarageLayer*, DialogLayer*);
	static auto func = wrapFunction(base::get() + 0x270e20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJGarageLayer::playerColorChanged() -> decltype(playerColorChanged()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJGarageLayer::playerColorChanged), this);
	using FunctionType = decltype(playerColorChanged())(*)(GJGarageLayer*);
	static auto func = wrapFunction(base::get() + 0x270170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJGarageLayer::rewardedVideoFinished() -> decltype(rewardedVideoFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJGarageLayer::rewardedVideoFinished), this);
	using FunctionType = decltype(rewardedVideoFinished())(*)(GJGarageLayer*);
	static auto func = wrapFunction(base::get() + 0x26d380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJGarageLayer::descriptionForUnlock(int p0, UnlockType p1) -> decltype(descriptionForUnlock(p0, p1)) {
	using FunctionType = decltype(descriptionForUnlock(p0, p1))(*)(GJGarageLayer*, int, UnlockType);
	static auto func = wrapFunction(base::get() + 0x270a30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJGarageLayer::getItems(IconType p0) -> decltype(getItems(p0)) {
	using FunctionType = decltype(getItems(p0))(*)(GJGarageLayer*, IconType);
	static auto func = wrapFunction(base::get() + 0x26ee50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJGarageLayer::onArrow(cocos2d::CCObject* sender) -> decltype(onArrow(sender)) {
	using FunctionType = decltype(onArrow(sender))(*)(GJGarageLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x26e590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJGarageLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	using FunctionType = decltype(onBack(sender))(*)(GJGarageLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x271750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJGarageLayer::onInfo(cocos2d::CCObject* sender) -> decltype(onInfo(sender)) {
	using FunctionType = decltype(onInfo(sender))(*)(GJGarageLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x26d190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJGarageLayer::onNavigate(cocos2d::CCObject* sender) -> decltype(onNavigate(sender)) {
	using FunctionType = decltype(onNavigate(sender))(*)(GJGarageLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x26e690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJGarageLayer::onPaint(cocos2d::CCObject* sender) -> decltype(onPaint(sender)) {
	using FunctionType = decltype(onPaint(sender))(*)(GJGarageLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x271570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJGarageLayer::onSelect(cocos2d::CCObject* sender) -> decltype(onSelect(sender)) {
	using FunctionType = decltype(onSelect(sender))(*)(GJGarageLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x26f890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJGarageLayer::onSelectTab(cocos2d::CCObject* sender) -> decltype(onSelectTab(sender)) {
	using FunctionType = decltype(onSelectTab(sender))(*)(GJGarageLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x26e6c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJGarageLayer::onShards(cocos2d::CCObject* sender) -> decltype(onShards(sender)) {
	using FunctionType = decltype(onShards(sender))(*)(GJGarageLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x271420, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJGarageLayer::onToggleItem(cocos2d::CCObject* sender) -> decltype(onToggleItem(sender)) {
	using FunctionType = decltype(onToggleItem(sender))(*)(GJGarageLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x26ff30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJGarageLayer::playRainbowEffect() -> decltype(playRainbowEffect()) {
	using FunctionType = decltype(playRainbowEffect())(*)(GJGarageLayer*);
	static auto func = wrapFunction(base::get() + 0x271230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJGarageLayer::selectTab(IconType p0) -> decltype(selectTab(p0)) {
	using FunctionType = decltype(selectTab(p0))(*)(GJGarageLayer*, IconType);
	static auto func = wrapFunction(base::get() + 0x26e6f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJGarageLayer::setupIconSelect() -> decltype(setupIconSelect()) {
	using FunctionType = decltype(setupIconSelect())(*)(GJGarageLayer*);
	static auto func = wrapFunction(base::get() + 0x26d930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJGarageLayer::setupPage(int p0, IconType p1) -> decltype(setupPage(p0, p1)) {
	using FunctionType = decltype(setupPage(p0, p1))(*)(GJGarageLayer*, int, IconType);
	static auto func = wrapFunction(base::get() + 0x26e7b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJGarageLayer::setupSpecialPage() -> decltype(setupSpecialPage()) {
	using FunctionType = decltype(setupSpecialPage())(*)(GJGarageLayer*);
	static auto func = wrapFunction(base::get() + 0x26f1e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJGarageLayer::updatePlayerColors() -> decltype(updatePlayerColors()) {
	using FunctionType = decltype(updatePlayerColors())(*)(GJGarageLayer*);
	static auto func = wrapFunction(base::get() + 0x2701a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJGradientLayer::init() -> decltype(init()) {
	throw std::runtime_error("GJGradientLayer::init not implemented");
}

GJItemIcon::GJItemIcon() {}

GJItemIcon* GJItemIcon::create(UnlockType p0, int p1, cocos2d::ccColor3B p2, cocos2d::ccColor3B p3, bool p4, bool p5, bool p6, cocos2d::ccColor3B p7) {
        auto ret = new GJItemIcon();
        if (ret->init(p0, p1, p2, p3, p4, p5, p6, p7)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
         }

auto GJItemIcon::createBrowserItem(UnlockType unlockType, int itemID) -> decltype(createBrowserItem(unlockType, itemID)) {
	using FunctionType = decltype(createBrowserItem(unlockType, itemID))(*)(UnlockType, int);
	static auto func = wrapFunction(base::get() + 0x273070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(unlockType, itemID);
}

auto GJItemIcon::createStoreItem(UnlockType p0, int p1, bool p2, cocos2d::ccColor3B p3) -> decltype(createStoreItem(p0, p1, p2, p3)) {
	using FunctionType = decltype(createStoreItem(p0, p1, p2, p3))(*)(UnlockType, int, bool, cocos2d::ccColor3B);
	static auto func = wrapFunction(base::get() + 0x272f40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3);
}

auto GJItemIcon::scaleForType(UnlockType p0) -> decltype(scaleForType(p0)) {
	using FunctionType = decltype(scaleForType(p0))(*)(UnlockType);
	static auto func = wrapFunction(base::get() + 0x273d90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJItemIcon::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&GJItemIcon::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(GJItemIcon*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x2738a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJItemIcon::changeToLockedState(float p0) -> decltype(changeToLockedState(p0)) {
	using FunctionType = decltype(changeToLockedState(p0))(*)(GJItemIcon*, float);
	static auto func = wrapFunction(base::get() + 0x273cb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJItemIcon::darkenStoreItem(cocos2d::ccColor3B p0) -> decltype(darkenStoreItem(p0)) {
	using FunctionType = decltype(darkenStoreItem(p0))(*)(GJItemIcon*, cocos2d::ccColor3B);
	static auto func = wrapFunction(base::get() + 0x2739c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJItemIcon::darkenStoreItem(ShopType p0) -> decltype(darkenStoreItem(p0)) {
	using FunctionType = decltype(darkenStoreItem(p0))(*)(GJItemIcon*, ShopType);
	static auto func = wrapFunction(base::get() + 0x273940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJItemIcon::init(UnlockType p0, int p1, cocos2d::ccColor3B p2, cocos2d::ccColor3B p3, bool p4, bool p5, bool p6, cocos2d::ccColor3B p7) -> decltype(init(p0, p1, p2, p3, p4, p5, p6, p7)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5, p6, p7))(*)(GJItemIcon*, UnlockType, int, cocos2d::ccColor3B, cocos2d::ccColor3B, bool, bool, bool, cocos2d::ccColor3B);
	static auto func = wrapFunction(base::get() + 0x273190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7);
}

auto GJItemIcon::toggleEnabledState(bool p0) -> decltype(toggleEnabledState(p0)) {
	using FunctionType = decltype(toggleEnabledState(p0))(*)(GJItemIcon*, bool);
	static auto func = wrapFunction(base::get() + 0x273bf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJLevelList::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x173760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJLevelList::create(cocos2d::CCDictionary* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(cocos2d::CCDictionary*);
	static auto func = wrapFunction(base::get() + 0x172e70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJLevelList::encodeWithCoder(DS_Dictionary* p0) -> decltype(encodeWithCoder(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&GJLevelList::encodeWithCoder), this);
	using FunctionType = decltype(encodeWithCoder(p0))(*)(GJLevelList*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x174ff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJLevelList::canEncode() -> decltype(canEncode()) {
	throw std::runtime_error("GJLevelList::canEncode not implemented");
}

auto GJLevelList::init() -> decltype(init()) {
	throw std::runtime_error("GJLevelList::init not implemented");
}

auto GJLevelList::addLevelToList(GJGameLevel* level) -> decltype(addLevelToList(level)) {
	using FunctionType = decltype(addLevelToList(level))(*)(GJLevelList*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x173ee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, level);
}

auto GJLevelList::dataLoaded(DS_Dictionary* p0) -> decltype(dataLoaded(p0)) {
	using FunctionType = decltype(dataLoaded(p0))(*)(GJLevelList*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x174cd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJLevelList::getListLevelsArray(cocos2d::CCArray* p0) -> decltype(getListLevelsArray(p0)) {
	using FunctionType = decltype(getListLevelsArray(p0))(*)(GJLevelList*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x174160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJLevelList::getUnpackedDescription() -> decltype(getUnpackedDescription()) {
	using FunctionType = decltype(getUnpackedDescription())(*)(GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x173b80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJLevelList::hasMatchingLevels(GJLevelList* p0) -> decltype(hasMatchingLevels(p0)) {
	using FunctionType = decltype(hasMatchingLevels(p0))(*)(GJLevelList*, GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x173970, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJLevelList::parseListLevels(gd::string p0) -> decltype(parseListLevels(p0)) {
	using FunctionType = decltype(parseListLevels(p0))(*)(GJLevelList*, gd::string);
	static auto func = wrapFunction(base::get() + 0x173c40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJLevelList::reorderLevel(int levelID, int newPosition) -> decltype(reorderLevel(levelID, newPosition)) {
	using FunctionType = decltype(reorderLevel(levelID, newPosition))(*)(GJLevelList*, int, int);
	static auto func = wrapFunction(base::get() + 0x174070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, levelID, newPosition);
}

auto GJLevelList::showListInfo() -> decltype(showListInfo()) {
	using FunctionType = decltype(showListInfo())(*)(GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x174900, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJLevelScoreCell::init() -> decltype(init()) {
	throw std::runtime_error("GJLevelScoreCell::init not implemented");
}

auto GJLevelScoreCell::draw() -> decltype(draw()) {
	throw std::runtime_error("GJLevelScoreCell::draw not implemented");
}

auto GJLevelScoreCell::loadFromScore(GJUserScore* p0) -> decltype(loadFromScore(p0)) {
	using FunctionType = decltype(loadFromScore(p0))(*)(GJLevelScoreCell*, GJUserScore*);
	static auto func = wrapFunction(base::get() + 0xb93d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJListLayer::create(BoomListView* p0, char const* p1, cocos2d::ccColor4B p2, float p3, float p4, int p5) -> decltype(create(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5))(*)(BoomListView*, char const*, cocos2d::ccColor4B, float, float, int);
	static auto func = wrapFunction(base::get() + 0x277e70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5);
}

auto GJListLayer::init(BoomListView* p0, char const* p1, cocos2d::ccColor4B p2, float p3, float p4, int p5) -> decltype(init(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5))(*)(GJListLayer*, BoomListView*, char const*, cocos2d::ccColor4B, float, float, int);
	static auto func = wrapFunction(base::get() + 0x277fa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto GJLocalLevelScoreCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJLocalLevelScoreCell::init), this);
	using FunctionType = decltype(init())(*)(GJLocalLevelScoreCell*);
	static auto func = wrapFunction(base::get() + 0x3c7f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJLocalLevelScoreCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJLocalLevelScoreCell::draw), this);
	using FunctionType = decltype(draw())(*)(GJLocalLevelScoreCell*);
	static auto func = wrapFunction(base::get() + 0xad710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJLocalLevelScoreCell::loadFromScore(GJLocalScore* p0) -> decltype(loadFromScore(p0)) {
	using FunctionType = decltype(loadFromScore(p0))(*)(GJLocalLevelScoreCell*, GJLocalScore*);
	static auto func = wrapFunction(base::get() + 0xb8fd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

GJMapPack::GJMapPack() {
        m_levels = nullptr;
        m_packID = 0;
        m_difficulty = GJDifficulty::Auto;
        m_stars = 0;
        m_coins = 0;
        m_packName = "";
        m_levelStrings = "";
        m_MId = 0;
        m_isGauntlet = false;
    }

auto GJMapPack::create(cocos2d::CCDictionary* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(cocos2d::CCDictionary*);
	static auto func = wrapFunction(base::get() + 0x16d210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

GJMapPack* GJMapPack::create() {
        auto ret = new GJMapPack();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto GJMapPack::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJMapPack::init), this);
	using FunctionType = decltype(init())(*)(GJMapPack*);
	static auto func = wrapFunction(base::get() + 0x16dd70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJMapPack::completedMaps() -> decltype(completedMaps()) {
	using FunctionType = decltype(completedMaps())(*)(GJMapPack*);
	static auto func = wrapFunction(base::get() + 0x16e080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

bool GJMapPack::hasCompletedMapPack() {
        auto total = this->totalMaps();
        if (total > 0) return this->completedMaps() >= total;
        else return 0;
    }

auto GJMapPack::parsePackColors(gd::string p0, gd::string p1) -> decltype(parsePackColors(p0, p1)) {
	using FunctionType = decltype(parsePackColors(p0, p1))(*)(GJMapPack*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x16ddd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

int GJMapPack::totalMaps() {
        if (this->m_levels) {
            return this->m_levels->count();
        }

        return 0;
    }

auto GJMessageCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJMessageCell::init), this);
	using FunctionType = decltype(init())(*)(GJMessageCell*);
	static auto func = wrapFunction(base::get() + 0xbb620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJMessageCell::draw() -> decltype(draw()) {
	throw std::runtime_error("GJMessageCell::draw not implemented");
}

auto GJMessageCell::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&GJMessageCell::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(GJMessageCell*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0xbd440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJMessageCell::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&GJMessageCell::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(p0, p1))(*)(GJMessageCell*, int, int);
	static auto func = wrapFunction(base::get() + 0xbd5e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJMessageCell::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&GJMessageCell::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(p0, p1))(*)(GJMessageCell*, int, int);
	static auto func = wrapFunction(base::get() + 0xbd760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJMessageCell::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	throw std::runtime_error("GJMessageCell::onClosePopup not implemented");
}

auto GJMessageCell::loadFromMessage(GJUserMessage* p0) -> decltype(loadFromMessage(p0)) {
	using FunctionType = decltype(loadFromMessage(p0))(*)(GJMessageCell*, GJUserMessage*);
	static auto func = wrapFunction(base::get() + 0xbc7e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJMessagePopup::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("GJMessagePopup::keyBackClicked not implemented");
}

auto GJMessagePopup::downloadMessageFinished(GJUserMessage* p0) -> decltype(downloadMessageFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJUserMessage*>::func(&GJMessagePopup::downloadMessageFinished), this);
	using FunctionType = decltype(downloadMessageFinished(p0))(*)(GJMessagePopup*, GJUserMessage*);
	static auto func = wrapFunction(base::get() + 0x2914b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJMessagePopup::downloadMessageFailed(int p0) -> decltype(downloadMessageFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&GJMessagePopup::downloadMessageFailed), this);
	using FunctionType = decltype(downloadMessageFailed(p0))(*)(GJMessagePopup*, int);
	static auto func = wrapFunction(base::get() + 0x291500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJMessagePopup::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&GJMessagePopup::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(p0, p1))(*)(GJMessagePopup*, int, int);
	static auto func = wrapFunction(base::get() + 0x291540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJMessagePopup::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&GJMessagePopup::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(p0, p1))(*)(GJMessagePopup*, int, int);
	static auto func = wrapFunction(base::get() + 0x2916d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJMessagePopup::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&GJMessagePopup::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(GJMessagePopup*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x2917a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJMessagePopup::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&GJMessagePopup::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(GJMessagePopup*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x291820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJMessagePopup::loadFromGJMessage(GJUserMessage* p0) -> decltype(loadFromGJMessage(p0)) {
	using FunctionType = decltype(loadFromGJMessage(p0))(*)(GJMessagePopup*, GJUserMessage*);
	static auto func = wrapFunction(base::get() + 0x290760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void GJMGLayer::draw() {}

auto GJMGLayer::showGround() -> decltype(showGround()) {
	throw std::runtime_error("GJMGLayer::showGround not implemented");
}

auto GJMoreGamesLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x278610, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJMoreGamesLayer::customSetup() -> decltype(customSetup()) {
	throw std::runtime_error("GJMoreGamesLayer::customSetup not implemented");
}

auto GJMPDelegate::joinLobbyFinished(int p0) -> decltype(joinLobbyFinished(p0)) {
	throw std::runtime_error("GJMPDelegate::joinLobbyFinished not implemented");
}

auto GJMPDelegate::joinLobbyFailed(int p0, GJMPErrorCode p1) -> decltype(joinLobbyFailed(p0, p1)) {
	throw std::runtime_error("GJMPDelegate::joinLobbyFailed not implemented");
}

auto GJMPDelegate::didUploadMPComment(int p0) -> decltype(didUploadMPComment(p0)) {
	throw std::runtime_error("GJMPDelegate::didUploadMPComment not implemented");
}

auto GJMPDelegate::updateComments() -> decltype(updateComments()) {
	throw std::runtime_error("GJMPDelegate::updateComments not implemented");
}

auto GJMultiplayerManager::sharedState() -> decltype(sharedState()) {
	using FunctionType = decltype(sharedState())(*)();
	static auto func = wrapFunction(base::get() + 0x27acc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJMultiplayerManager::init() -> decltype(init()) {
	throw std::runtime_error("GJMultiplayerManager::init not implemented");
}

auto GJObjectDecoder::init() -> decltype(init()) {
	throw std::runtime_error("GJObjectDecoder::init not implemented");
}

auto GJObjectDecoder::getDecodedObject(int p0, DS_Dictionary* p1) -> decltype(getDecodedObject(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, DS_Dictionary*>::func(&GJObjectDecoder::getDecodedObject), this);
	using FunctionType = decltype(getDecodedObject(p0, p1))(*)(GJObjectDecoder*, int, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x27c730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void GJOnlineRewardDelegate::onlineRewardStatusFinished(gd::string p0) {}

void GJOnlineRewardDelegate::onlineRewardStatusFailed() {}

auto GJPurchaseDelegate::didPurchaseItem(GJStoreItem* p0) -> decltype(didPurchaseItem(p0)) {
	throw std::runtime_error("GJPurchaseDelegate::didPurchaseItem not implemented");
}

auto GJPathPage::create(int p0, GJPathsLayer* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(int, GJPathsLayer*);
	static auto func = wrapFunction(base::get() + 0x27db80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GJPathPage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("GJPathPage::registerWithTouchDispatcher not implemented");
}

auto GJPathPage::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJPathPage::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(GJPathPage*);
	static auto func = wrapFunction(base::get() + 0x281710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJPathPage::show() -> decltype(show()) {
	throw std::runtime_error("GJPathPage::show not implemented");
}

auto GJPathPage::didPurchaseItem(GJStoreItem* p0) -> decltype(didPurchaseItem(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJStoreItem*>::func(&GJPathPage::didPurchaseItem), this);
	using FunctionType = decltype(didPurchaseItem(p0))(*)(GJPathPage*, GJStoreItem*);
	static auto func = wrapFunction(base::get() + 0x27fb40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJPathPage::onActivatePath(cocos2d::CCObject* sender) -> decltype(onActivatePath(sender)) {
	using FunctionType = decltype(onActivatePath(sender))(*)(GJPathPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x27f8e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJPathPage::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	using FunctionType = decltype(onBack(sender))(*)(GJPathPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x281670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJPathPage::onIconInfo(cocos2d::CCObject* sender) -> decltype(onIconInfo(sender)) {
	using FunctionType = decltype(onIconInfo(sender))(*)(GJPathPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x27f950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJPathPage::playUnlockAnimation() -> decltype(playUnlockAnimation()) {
	using FunctionType = decltype(playUnlockAnimation())(*)(GJPathPage*);
	static auto func = wrapFunction(base::get() + 0x280400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJPathPage::unlockAnimationStep2() -> decltype(unlockAnimationStep2()) {
	using FunctionType = decltype(unlockAnimationStep2())(*)(GJPathPage*);
	static auto func = wrapFunction(base::get() + 0x280a50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJPathPage::unlockAnimationStep3() -> decltype(unlockAnimationStep3()) {
	using FunctionType = decltype(unlockAnimationStep3())(*)(GJPathPage*);
	static auto func = wrapFunction(base::get() + 0x280cd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void GJPathRewardPopup::keyBackClicked() {}

auto GJPathRewardPopup::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GJPathRewardPopup*, int);
	static auto func = wrapFunction(base::get() + 0x2825f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJPathsLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x27d1d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJPathsLayer::nameForPath(int p0) -> decltype(nameForPath(p0)) {
	using FunctionType = decltype(nameForPath(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x27cf60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJPathsLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJPathsLayer::init), this);
	using FunctionType = decltype(init())(*)(GJPathsLayer*);
	static auto func = wrapFunction(base::get() + 0x27d2d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJPathsLayer::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJPathsLayer::onExit), this);
	using FunctionType = decltype(onExit())(*)(GJPathsLayer*);
	static auto func = wrapFunction(base::get() + 0x27dac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJPathsLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("GJPathsLayer::registerWithTouchDispatcher not implemented");
}

auto GJPathsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJPathsLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(GJPathsLayer*);
	static auto func = wrapFunction(base::get() + 0x27db20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJPathsLayer::show() -> decltype(show()) {
	throw std::runtime_error("GJPathsLayer::show not implemented");
}

auto GJPathsLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(GJPathsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x27dac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJPathSprite::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x281720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJPathSprite::addShardSprite() -> decltype(addShardSprite()) {
	using FunctionType = decltype(addShardSprite())(*)(GJPathSprite*);
	static auto func = wrapFunction(base::get() + 0x281d90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJPathSprite::changeToLockedArt() -> decltype(changeToLockedArt()) {
	using FunctionType = decltype(changeToLockedArt())(*)(GJPathSprite*);
	static auto func = wrapFunction(base::get() + 0x281ad0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJPFollowCommandLayer::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("GJPFollowCommandLayer::determineStartValues not implemented");
}

auto GJPFollowCommandLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("GJPFollowCommandLayer::onClose not implemented");
}

auto GJPFollowCommandLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&GJPFollowCommandLayer::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(GJPFollowCommandLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x284d20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJPromoPopup::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJPromoPopup::onExit), this);
	using FunctionType = decltype(onExit())(*)(GJPromoPopup*);
	static auto func = wrapFunction(base::get() + 0x29d890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJPromoPopup::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("GJPromoPopup::registerWithTouchDispatcher not implemented");
}

auto GJPromoPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("GJPromoPopup::keyBackClicked not implemented");
}

auto GJPromoPopup::show() -> decltype(show()) {
	throw std::runtime_error("GJPromoPopup::show not implemented");
}

auto GJPromoPopup::init(gd::string p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GJPromoPopup*, gd::string);
	static auto func = wrapFunction(base::get() + 0x29d590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJRequestCell::init() -> decltype(init()) {
	throw std::runtime_error("GJRequestCell::init not implemented");
}

auto GJRequestCell::draw() -> decltype(draw()) {
	throw std::runtime_error("GJRequestCell::draw not implemented");
}

auto GJRequestCell::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&GJRequestCell::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(GJRequestCell*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0xbc1f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJRequestCell::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&GJRequestCell::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(p0, p1))(*)(GJRequestCell*, int, int);
	static auto func = wrapFunction(base::get() + 0xbc3a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJRequestCell::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&GJRequestCell::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(p0, p1))(*)(GJRequestCell*, int, int);
	static auto func = wrapFunction(base::get() + 0xbc580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJRequestCell::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	throw std::runtime_error("GJRequestCell::onClosePopup not implemented");
}

auto GJRequestCell::loadFromScore(GJUserScore* p0) -> decltype(loadFromScore(p0)) {
	using FunctionType = decltype(loadFromScore(p0))(*)(GJRequestCell*, GJUserScore*);
	static auto func = wrapFunction(base::get() + 0xbb640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJRequestCell::markAsRead() -> decltype(markAsRead()) {
	using FunctionType = decltype(markAsRead())(*)(GJRequestCell*);
	static auto func = wrapFunction(base::get() + 0xbbf50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJRequestCell::onDeleteRequest(cocos2d::CCObject* sender) -> decltype(onDeleteRequest(sender)) {
	using FunctionType = decltype(onDeleteRequest(sender))(*)(GJRequestCell*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xbc030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJRequestCell::onViewFriendRequest(cocos2d::CCObject* sender) -> decltype(onViewFriendRequest(sender)) {
	using FunctionType = decltype(onViewFriendRequest(sender))(*)(GJRequestCell*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xbbea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJRewardDelegate::rewardsStatusFinished(int p0) -> decltype(rewardsStatusFinished(p0)) {
	throw std::runtime_error("GJRewardDelegate::rewardsStatusFinished not implemented");
}

auto GJRewardDelegate::rewardsStatusFailed() -> decltype(rewardsStatusFailed()) {
	throw std::runtime_error("GJRewardDelegate::rewardsStatusFailed not implemented");
}

auto GJRewardItem::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x1f0980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJRewardItem::create(int chestID, int timeRemaining, gd::string p2) -> decltype(create(chestID, timeRemaining, p2)) {
	using FunctionType = decltype(create(chestID, timeRemaining, p2))(*)(int, int, gd::string);
	static auto func = wrapFunction(base::get() + 0x1f0cc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(chestID, timeRemaining, p2);
}

auto GJRewardItem::createSpecial(GJRewardType p0, int p1, int p2, SpecialRewardItem p3, int p4, SpecialRewardItem p5, int p6, int p7, int p8) -> decltype(createSpecial(p0, p1, p2, p3, p4, p5, p6, p7, p8)) {
	using FunctionType = decltype(createSpecial(p0, p1, p2, p3, p4, p5, p6, p7, p8))(*)(GJRewardType, int, int, SpecialRewardItem, int, SpecialRewardItem, int, int, int);
	static auto func = wrapFunction(base::get() + 0x1f0ad0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5, p6, p7, p8);
}

GJRewardItem* GJRewardItem::createWithCoder(DS_Dictionary* dict) {
        auto ret = create();
        ret->dataLoaded(dict);
        return ret;
    }

auto GJRewardItem::createWithObject(GJRewardType p0, GJRewardObject* p1) -> decltype(createWithObject(p0, p1)) {
	using FunctionType = decltype(createWithObject(p0, p1))(*)(GJRewardType, GJRewardObject*);
	static auto func = wrapFunction(base::get() + 0x1f09c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GJRewardItem::createWithObjects(GJRewardType p0, cocos2d::CCArray* p1) -> decltype(createWithObjects(p0, p1)) {
	using FunctionType = decltype(createWithObjects(p0, p1))(*)(GJRewardType, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x1f0a50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

SpecialRewardItem GJRewardItem::getNextShardType(SpecialRewardItem type) {
        switch (type) {
            case SpecialRewardItem::FireShard: return SpecialRewardItem::IceShard;
            case SpecialRewardItem::IceShard: return SpecialRewardItem::PoisonShard;
            case SpecialRewardItem::PoisonShard: return SpecialRewardItem::ShadowShard;
            case SpecialRewardItem::ShadowShard: return SpecialRewardItem::LavaShard;
            case SpecialRewardItem::LavaShard: return SpecialRewardItem::EarthShard;
            case SpecialRewardItem::EarthShard: return SpecialRewardItem::BloodShard;
            case SpecialRewardItem::BloodShard: return SpecialRewardItem::MetalShard;
            case SpecialRewardItem::MetalShard: return SpecialRewardItem::LightShard;
            case SpecialRewardItem::LightShard: return SpecialRewardItem::SoulShard;
            case SpecialRewardItem::SoulShard: return SpecialRewardItem::FireShard;
            default: return (SpecialRewardItem)0;
        }
    }

SpecialRewardItem GJRewardItem::getRandomNonMaxShardType() {
        auto type = getRandomShardType();
        for (int i = 10; i > 0; i--) {
            if (GameStatsManager::sharedState()->getStat(rewardItemToStat(type).c_str()) < 100) return type;
            type = getNextShardType(type);
        }
        return (SpecialRewardItem)0;
    }

SpecialRewardItem GJRewardItem::getRandomShardType() {
        int randomValue = floorf((rand() / (float)RAND_MAX) * 10.f) + 1.f;
        switch (randomValue) {
            case 2: return SpecialRewardItem::IceShard;
            case 3: return SpecialRewardItem::PoisonShard;
            case 4: return SpecialRewardItem::ShadowShard;
            case 5: return SpecialRewardItem::LavaShard;
            case 6: return SpecialRewardItem::EarthShard;
            case 7: return SpecialRewardItem::BloodShard;
            case 8: return SpecialRewardItem::MetalShard;
            case 9: return SpecialRewardItem::LightShard;
            case 10: return SpecialRewardItem::SoulShard;
            default: return SpecialRewardItem::FireShard;
        }
    }

bool GJRewardItem::isShardType(SpecialRewardItem type) {
        return type == SpecialRewardItem::FireShard || type == SpecialRewardItem::IceShard || type == SpecialRewardItem::PoisonShard
            || type == SpecialRewardItem::ShadowShard || type == SpecialRewardItem::LavaShard || type == SpecialRewardItem::EarthShard
            || type == SpecialRewardItem::BloodShard || type == SpecialRewardItem::MetalShard || type == SpecialRewardItem::LightShard
            || type == SpecialRewardItem::SoulShard;
    }

auto GJRewardItem::rewardItemToStat(SpecialRewardItem p0) -> decltype(rewardItemToStat(p0)) {
	using FunctionType = decltype(rewardItemToStat(p0))(*)(SpecialRewardItem);
	static auto func = wrapFunction(base::get() + 0x1f0ff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJRewardItem::encodeWithCoder(DS_Dictionary* p0) -> decltype(encodeWithCoder(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&GJRewardItem::encodeWithCoder), this);
	using FunctionType = decltype(encodeWithCoder(p0))(*)(GJRewardItem*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x1f1250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

bool GJRewardItem::canEncode() {
        return true;
    }

void GJRewardItem::dataLoaded(DS_Dictionary* dict) {
        m_chestID = dict->getIntegerForKey("1");
        m_rewardType = (GJRewardType)dict->getIntegerForKey("2");
        auto rewardObjects = dict->getArrayForKey("3", false);
        CC_SAFE_RETAIN(rewardObjects);
        CC_SAFE_RELEASE(m_rewardObjects);
        m_rewardObjects = rewardObjects;
    }

int GJRewardItem::getRewardCount(SpecialRewardItem type) {
        if (!m_rewardObjects) return 0;

        int count = 0;
        for (int i = 0; i < m_rewardObjects->count(); i++) {
            auto obj = static_cast<GJRewardObject*>(m_rewardObjects->objectAtIndex(i));
            if (obj->m_specialRewardItem == type) count += obj->m_total;
        }

        return count;
    }

GJRewardObject* GJRewardItem::getRewardObjectForType(SpecialRewardItem type) {
        if (!m_rewardObjects) {
            auto rewardObjects = cocos2d::CCArray::create();
            CC_SAFE_RETAIN(rewardObjects);
            CC_SAFE_RELEASE(m_rewardObjects);
            m_rewardObjects = rewardObjects;
        }

        for (int i = 0; i < m_rewardObjects->count(); i++) {
            auto obj = static_cast<GJRewardObject*>(m_rewardObjects->objectAtIndex(i));
            if (obj->m_specialRewardItem == type) return obj;
        }

        auto obj = GJRewardObject::create(type, 0, 0);
        m_rewardObjects->addObject(obj);
        return obj;
    }

auto GJRewardItem::init(int chestID, int timeRemaining, gd::string p2) -> decltype(init(chestID, timeRemaining, p2)) {
	using FunctionType = decltype(init(chestID, timeRemaining, p2))(*)(GJRewardItem*, int, int, gd::string);
	static auto func = wrapFunction(base::get() + 0x1f0d90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, chestID, timeRemaining, p2);
}

auto GJRewardObject::create(SpecialRewardItem p0, int p1, int p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(SpecialRewardItem, int, int);
	static auto func = wrapFunction(base::get() + 0x1f0880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

GJRewardObject* GJRewardObject::create() {
        auto ret = create(SpecialRewardItem::FireShard, 0, 0); // the first param is meant to be 0
        return ret;
    }

auto GJRewardObject::createItemUnlock(UnlockType p0, int p1) -> decltype(createItemUnlock(p0, p1)) {
	using FunctionType = decltype(createItemUnlock(p0, p1))(*)(UnlockType, int);
	static auto func = wrapFunction(base::get() + 0x1f0810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

GJRewardObject* GJRewardObject::createWithCoder(DS_Dictionary* dict) {
        auto ret = create();
        ret->dataLoaded(dict);
        return ret;
    }

auto GJRewardObject::encodeWithCoder(DS_Dictionary* p0) -> decltype(encodeWithCoder(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&GJRewardObject::encodeWithCoder), this);
	using FunctionType = decltype(encodeWithCoder(p0))(*)(GJRewardObject*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x1f08f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

bool GJRewardObject::canEncode() {
        return true;
    }

void GJRewardObject::dataLoaded(DS_Dictionary* dict) {
        m_specialRewardItem = (SpecialRewardItem)dict->getIntegerForKey("1");
        m_itemID = dict->getIntegerForKey("2");
        m_total = dict->getIntegerForKey("3");
        m_unlockType = (UnlockType)dict->getIntegerForKey("4");
    }

bool GJRewardObject::init(SpecialRewardItem specialRewardItem, int total, int itemID) {
        this->m_specialRewardItem = specialRewardItem;
        this->m_total = total;
        this->m_itemID = itemID;
        return true;
    }

bool GJRewardObject::isSpecialType() {
        auto type = m_specialRewardItem;
        return type == SpecialRewardItem::FireShard || type == SpecialRewardItem::IceShard || type == SpecialRewardItem::PoisonShard
            || type == SpecialRewardItem::ShadowShard || type == SpecialRewardItem::LavaShard || type == SpecialRewardItem::BonusKey
            || type == SpecialRewardItem::EarthShard || type == SpecialRewardItem::BloodShard || type == SpecialRewardItem::MetalShard
            || type == SpecialRewardItem::LightShard || type == SpecialRewardItem::SoulShard;
    }

auto GJRobotSprite::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x29efd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJRobotSprite::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&GJRobotSprite::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(GJRobotSprite*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x29fcc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJRobotSprite::hideSecondary() -> decltype(hideSecondary()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJRobotSprite::hideSecondary), this);
	using FunctionType = decltype(hideSecondary())(*)(GJRobotSprite*);
	static auto func = wrapFunction(base::get() + 0x2a03b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJRobotSprite::init(int p0, gd::string p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(GJRobotSprite*, int, gd::string);
	static auto func = wrapFunction(base::get() + 0x29f080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJRobotSprite::updateColors() -> decltype(updateColors()) {
	using FunctionType = decltype(updateColors())(*)(GJRobotSprite*);
	static auto func = wrapFunction(base::get() + 0x29f810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJRobotSprite::updateFrame(int p0) -> decltype(updateFrame(p0)) {
	using FunctionType = decltype(updateFrame(p0))(*)(GJRobotSprite*, int);
	static auto func = wrapFunction(base::get() + 0x29fdc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJRotateCommandLayer::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("GJRotateCommandLayer::determineStartValues not implemented");
}

auto GJRotateCommandLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("GJRotateCommandLayer::onClose not implemented");
}

auto GJRotateCommandLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("GJRotateCommandLayer::textChanged not implemented");
}

auto GJRotateCommandLayer::valuePopupClosed(ConfigureValuePopup* p0, float p1) -> decltype(valuePopupClosed(p0, p1)) {
	throw std::runtime_error("GJRotateCommandLayer::valuePopupClosed not implemented");
}

GJRotationControl::GJRotationControl() {
        m_cursorDifference = cocos2d::CCPointMake(0.0f, 0.0f);
        m_controlPosition = cocos2d::CCPointMake(0.0f, 0.0f);
        m_controlSprite = nullptr;
        m_startingRotation = 0.0f;
        m_currentRotation = 0.0f;
        m_touchID = -1;
        m_delegate = nullptr;
    }

GJRotationControl* GJRotationControl::create() {
        auto ret = new GJRotationControl();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto GJRotationControl::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJRotationControl::init), this);
	using FunctionType = decltype(init())(*)(GJRotationControl*);
	static auto func = wrapFunction(base::get() + 0x1277e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJRotationControl::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJRotationControl::draw), this);
	using FunctionType = decltype(draw())(*)(GJRotationControl*);
	static auto func = wrapFunction(base::get() + 0x127c40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJRotationControl::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJRotationControl::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(GJRotationControl*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x127980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJRotationControl::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJRotationControl::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(GJRotationControl*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x127a80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJRotationControl::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJRotationControl::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(GJRotationControl*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x127c20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJRotationControl::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	throw std::runtime_error("GJRotationControl::ccTouchCancelled not implemented");
}

auto GJRotationControl::finishTouch() -> decltype(finishTouch()) {
	using FunctionType = decltype(finishTouch())(*)(GJRotationControl*);
	static auto func = wrapFunction(base::get() + 0x127900, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

GJScaleControl::GJScaleControl() {
        m_sliderX = nullptr;
        m_sliderY = nullptr;
        m_sliderXY = nullptr;
        m_touchID = -1;
        m_valueX = 0.0f;
        m_valueY = 0.0f;
        m_unkSize4 = 0;
        m_changedValueX = 0.0f;
        m_changedValueY = 0.0f;
        m_scale1Lock = false;
        m_scaleButtonType = 0;
        m_delegate = nullptr;
        m_upperBound = 2.0f;
        m_lowerBound = 0.5f;
        m_senderTag = 0;
        m_scaleLockButton = nullptr;
        m_scaleLocked = false;
    }

GJScaleControl* GJScaleControl::create() {
        auto ret = new GJScaleControl();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto GJScaleControl::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJScaleControl::init), this);
	using FunctionType = decltype(init())(*)(GJScaleControl*);
	static auto func = wrapFunction(base::get() + 0x127cc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJScaleControl::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJScaleControl::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(GJScaleControl*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x1287b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJScaleControl::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJScaleControl::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(GJScaleControl*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x1289c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJScaleControl::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJScaleControl::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(GJScaleControl*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x128de0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJScaleControl::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	throw std::runtime_error("GJScaleControl::ccTouchCancelled not implemented");
}

auto GJScaleControl::loadValues(GameObject* p0, cocos2d::CCArray* p1, gd::unordered_map<int, GameObjectEditorState>& p2) -> decltype(loadValues(p0, p1, p2)) {
	using FunctionType = decltype(loadValues(p0, p1, p2))(*)(GJScaleControl*, GameObject*, cocos2d::CCArray*, gd::unordered_map<int, GameObjectEditorState>&);
	static auto func = wrapFunction(base::get() + 0x128190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GJScaleControl::onToggleLockScale(cocos2d::CCObject* sender) -> decltype(onToggleLockScale(sender)) {
	using FunctionType = decltype(onToggleLockScale(sender))(*)(GJScaleControl*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x128100, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

float GJScaleControl::scaleFromValue(float value) {
        return (m_upperBound - m_lowerBound) * value + m_lowerBound;
    }

auto GJScaleControl::sliderChanged(cocos2d::CCObject* sender) -> decltype(sliderChanged(sender)) {
	using FunctionType = decltype(sliderChanged(sender))(*)(GJScaleControl*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1287a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJScaleControl::updateLabelX(float value) -> decltype(updateLabelX(value)) {
	using FunctionType = decltype(updateLabelX(value))(*)(GJScaleControl*, float);
	static auto func = wrapFunction(base::get() + 0x128f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, value);
}

auto GJScaleControl::updateLabelXY(float value) -> decltype(updateLabelXY(value)) {
	using FunctionType = decltype(updateLabelXY(value))(*)(GJScaleControl*, float);
	static auto func = wrapFunction(base::get() + 0x129020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, value);
}

auto GJScaleControl::updateLabelY(float value) -> decltype(updateLabelY(value)) {
	using FunctionType = decltype(updateLabelY(value))(*)(GJScaleControl*, float);
	static auto func = wrapFunction(base::get() + 0x128fa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, value);
}

float GJScaleControl::valueFromScale(float scale) {
        auto value = (scale - m_lowerBound) / (m_upperBound - m_lowerBound);
        return value < 0 ? 0 : (value > 1 ? 1 : value);
    }

auto GJScoreCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJScoreCell::init), this);
	using FunctionType = decltype(init())(*)(GJScoreCell*);
	static auto func = wrapFunction(base::get() + 0xb3f00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJScoreCell::draw() -> decltype(draw()) {
	throw std::runtime_error("GJScoreCell::draw not implemented");
}

auto GJScoreCell::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&GJScoreCell::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(GJScoreCell*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0xb8ee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJScoreCell::loadFromScore(GJUserScore* p0) -> decltype(loadFromScore(p0)) {
	using FunctionType = decltype(loadFromScore(p0))(*)(GJScoreCell*, GJUserScore*);
	static auto func = wrapFunction(base::get() + 0xb7c80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJScoreCell::onViewProfile(cocos2d::CCObject* sender) -> decltype(onViewProfile(sender)) {
	using FunctionType = decltype(onViewProfile(sender))(*)(GJScoreCell*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xb8d60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJSearchObject::create(SearchType searchType, gd::string searchQuery, gd::string difficulty, gd::string length, int page, bool star, bool uncompleted, bool featured, int songID, bool original, bool twoPlayer, bool customSong, bool songFilter, bool noStar, bool coins, bool epic, bool legendary, bool mythic, bool onlyCompleted, int demonFilter, int folder, int searchMode) -> decltype(create(searchType, searchQuery, difficulty, length, page, star, uncompleted, featured, songID, original, twoPlayer, customSong, songFilter, noStar, coins, epic, legendary, mythic, onlyCompleted, demonFilter, folder, searchMode)) {
	using FunctionType = decltype(create(searchType, searchQuery, difficulty, length, page, star, uncompleted, featured, songID, original, twoPlayer, customSong, songFilter, noStar, coins, epic, legendary, mythic, onlyCompleted, demonFilter, folder, searchMode))(*)(SearchType, gd::string, gd::string, gd::string, int, bool, bool, bool, int, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, int, int, int);
	static auto func = wrapFunction(base::get() + 0x171900, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(searchType, searchQuery, difficulty, length, page, star, uncompleted, featured, songID, original, twoPlayer, customSong, songFilter, noStar, coins, epic, legendary, mythic, onlyCompleted, demonFilter, folder, searchMode);
}

auto GJSearchObject::create(SearchType searchType, gd::string searchQuery) -> decltype(create(searchType, searchQuery)) {
	using FunctionType = decltype(create(searchType, searchQuery))(*)(SearchType, gd::string);
	static auto func = wrapFunction(base::get() + 0x1717d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(searchType, searchQuery);
}

auto GJSearchObject::create(SearchType searchType) -> decltype(create(searchType)) {
	using FunctionType = decltype(create(searchType))(*)(SearchType);
	static auto func = wrapFunction(base::get() + 0x1716f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(searchType);
}

auto GJSearchObject::createFromKey(char const* key) -> decltype(createFromKey(key)) {
	using FunctionType = decltype(createFromKey(key))(*)(char const*);
	static auto func = wrapFunction(base::get() + 0x170ff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(key);
}

auto GJSearchObject::getKey() -> decltype(getKey()) {
	using FunctionType = decltype(getKey())(*)(GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0x171c40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJSearchObject::getPageObject(int page) -> decltype(getPageObject(page)) {
	using FunctionType = decltype(getPageObject(page))(*)(GJSearchObject*, int);
	static auto func = wrapFunction(base::get() + 0x171d90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, page);
}

auto GJSearchObject::getSearchKey(SearchType searchType, gd::string searchQuery, gd::string difficulty, gd::string length, int page, bool star, bool uncompleted, bool featured, int songID, bool original, bool twoPlayer, bool customSong, bool songFilter, bool noStar, bool coins, bool epic, bool legendary, bool mythic, bool onlyCompleted, int demonFilter, int folder, int searchMode) -> decltype(getSearchKey(searchType, searchQuery, difficulty, length, page, star, uncompleted, featured, songID, original, twoPlayer, customSong, songFilter, noStar, coins, epic, legendary, mythic, onlyCompleted, demonFilter, folder, searchMode)) {
	using FunctionType = decltype(getSearchKey(searchType, searchQuery, difficulty, length, page, star, uncompleted, featured, songID, original, twoPlayer, customSong, songFilter, noStar, coins, epic, legendary, mythic, onlyCompleted, demonFilter, folder, searchMode))(*)(GJSearchObject*, SearchType, gd::string, gd::string, gd::string, int, bool, bool, bool, int, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, int, int, int);
	static auto func = wrapFunction(base::get() + 0x171f00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, searchType, searchQuery, difficulty, length, page, star, uncompleted, featured, songID, original, twoPlayer, customSong, songFilter, noStar, coins, epic, legendary, mythic, onlyCompleted, demonFilter, folder, searchMode);
}

auto GJSearchObject::isLevelSearchObject() -> decltype(isLevelSearchObject()) {
	using FunctionType = decltype(isLevelSearchObject())(*)(GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0x1721e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

GJShopLayer::GJShopLayer() {
        m_closing = false;
        m_currencyLabel = nullptr;
        m_shopItems = nullptr;
        m_type = ShopType::Normal;
        m_sheetName = "";
        m_unkNode1 = nullptr;
        m_unkNode2 = nullptr;
        m_videoPlaying = false;
        m_unkBool = false;
        m_shopKeeper = nullptr;
        m_zolgurothDialogIndex = 0;
        m_affordDialogIndex = 0;
    }

GJShopLayer* GJShopLayer::create(ShopType type) {
        auto ret = new GJShopLayer();
        if (ret->init(type)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto GJShopLayer::scene(ShopType p0) -> decltype(scene(p0)) {
	using FunctionType = decltype(scene(p0))(*)(ShopType);
	static auto func = wrapFunction(base::get() + 0x2a1ef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJShopLayer::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJShopLayer::onExit), this);
	using FunctionType = decltype(onExit())(*)(GJShopLayer*);
	static auto func = wrapFunction(base::get() + 0x2a4160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJShopLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJShopLayer::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(GJShopLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x2a7290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void GJShopLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

void GJShopLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

auto GJShopLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	throw std::runtime_error("GJShopLayer::ccTouchCancelled not implemented");
}

auto GJShopLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("GJShopLayer::registerWithTouchDispatcher not implemented");
}

auto GJShopLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJShopLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(GJShopLayer*);
	static auto func = wrapFunction(base::get() + 0x2a58d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJShopLayer::didPurchaseItem(GJStoreItem* p0) -> decltype(didPurchaseItem(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJStoreItem*>::func(&GJShopLayer::didPurchaseItem), this);
	using FunctionType = decltype(didPurchaseItem(p0))(*)(GJShopLayer*, GJStoreItem*);
	static auto func = wrapFunction(base::get() + 0x2a4ed0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJShopLayer::rewardedVideoFinished() -> decltype(rewardedVideoFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJShopLayer::rewardedVideoFinished), this);
	using FunctionType = decltype(rewardedVideoFinished())(*)(GJShopLayer*);
	static auto func = wrapFunction(base::get() + 0x2a4520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJShopLayer::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DialogLayer*>::func(&GJShopLayer::dialogClosed), this);
	using FunctionType = decltype(dialogClosed(p0))(*)(GJShopLayer*, DialogLayer*);
	static auto func = wrapFunction(base::get() + 0x2a6f60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJShopLayer::init(ShopType p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GJShopLayer*, ShopType);
	static auto func = wrapFunction(base::get() + 0x2a2070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJShopLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	using FunctionType = decltype(onBack(sender))(*)(GJShopLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2a56b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJShopLayer::onCommunityCredits(cocos2d::CCObject* sender) -> decltype(onCommunityCredits(sender)) {
	using FunctionType = decltype(onCommunityCredits(sender))(*)(GJShopLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2a43e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJShopLayer::showReactMessage() -> decltype(showReactMessage()) {
	using FunctionType = decltype(showReactMessage())(*)(GJShopLayer*);
	static auto func = wrapFunction(base::get() + 0x2a58e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJSmartBlockPreviewSprite::init() -> decltype(init()) {
	throw std::runtime_error("GJSmartBlockPreviewSprite::init not implemented");
}

auto GJSmartBlockPreviewSprite::visit() -> decltype(visit()) {
	throw std::runtime_error("GJSmartBlockPreviewSprite::visit not implemented");
}

auto GJSmartPrefab::encodeWithCoder(DS_Dictionary* p0) -> decltype(encodeWithCoder(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&GJSmartPrefab::encodeWithCoder), this);
	using FunctionType = decltype(encodeWithCoder(p0))(*)(GJSmartPrefab*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x2ae2b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJSmartPrefab::canEncode() -> decltype(canEncode()) {
	throw std::runtime_error("GJSmartPrefab::canEncode not implemented");
}

auto GJSmartTemplate::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x2a92e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJSmartTemplate::encodeWithCoder(DS_Dictionary* p0) -> decltype(encodeWithCoder(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&GJSmartTemplate::encodeWithCoder), this);
	using FunctionType = decltype(encodeWithCoder(p0))(*)(GJSmartTemplate*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x2ae150, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJSmartTemplate::canEncode() -> decltype(canEncode()) {
	throw std::runtime_error("GJSmartTemplate::canEncode not implemented");
}

auto GJSmartTemplate::dataLoaded(DS_Dictionary* p0) -> decltype(dataLoaded(p0)) {
	using FunctionType = decltype(dataLoaded(p0))(*)(GJSmartTemplate*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x2ade80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJSongBrowser::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x2afab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJSongBrowser::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJSongBrowser::init), this);
	using FunctionType = decltype(init())(*)(GJSongBrowser*);
	static auto func = wrapFunction(base::get() + 0x2afc30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJSongBrowser::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJSongBrowser::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(GJSongBrowser*);
	static auto func = wrapFunction(base::get() + 0x2afd30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJSongBrowser::exitLayer(cocos2d::CCObject* p0) -> decltype(exitLayer(p0)) {
	throw std::runtime_error("GJSongBrowser::exitLayer not implemented");
}

auto GJSongBrowser::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&GJSongBrowser::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(GJSongBrowser*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x2b0470, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJSongBrowser::cellPerformedAction(TableViewCell* p0, int p1, CellAction p2, cocos2d::CCNode* p3) -> decltype(cellPerformedAction(p0, p1, p2, p3)) {
	throw std::runtime_error("GJSongBrowser::cellPerformedAction not implemented");
}

auto GJSongBrowser::getSelectedCellIdx() -> decltype(getSelectedCellIdx()) {
	throw std::runtime_error("GJSongBrowser::getSelectedCellIdx not implemented");
}

auto GJSongBrowser::loadPage(int p0) -> decltype(loadPage(p0)) {
	using FunctionType = decltype(loadPage(p0))(*)(GJSongBrowser*, int);
	static auto func = wrapFunction(base::get() + 0x2b00b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJSongBrowser::onNextPage(cocos2d::CCObject* sender) -> decltype(onNextPage(sender)) {
	using FunctionType = decltype(onNextPage(sender))(*)(GJSongBrowser*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b0340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJSongBrowser::onPrevPage(cocos2d::CCObject* sender) -> decltype(onPrevPage(sender)) {
	using FunctionType = decltype(onPrevPage(sender))(*)(GJSongBrowser*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b0350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJSpecialColorSelect::create(int p0, GJSpecialColorSelectDelegate* p1, ColorSelectType p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(int, GJSpecialColorSelectDelegate*, ColorSelectType);
	static auto func = wrapFunction(base::get() + 0x2b0670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto GJSpecialColorSelect::textForColorIdx(int p0) -> decltype(textForColorIdx(p0)) {
	using FunctionType = decltype(textForColorIdx(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x2b13c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJSpecialColorSelect::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJSpecialColorSelect::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(GJSpecialColorSelect*);
	static auto func = wrapFunction(base::get() + 0x2b1370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJSpecialColorSelect::init(int p0, GJSpecialColorSelectDelegate* p1, ColorSelectType p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(GJSpecialColorSelect*, int, GJSpecialColorSelectDelegate*, ColorSelectType);
	static auto func = wrapFunction(base::get() + 0x2b0780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GJSpecialColorSelect::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(GJSpecialColorSelect*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b1320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJSpecialColorSelect::onSelectColor(cocos2d::CCObject* sender) -> decltype(onSelectColor(sender)) {
	using FunctionType = decltype(onSelectColor(sender))(*)(GJSpecialColorSelect*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b1240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJSpiderSprite::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x2a0420, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

GJStoreItem::GJStoreItem() {
        m_index = 0;
        m_typeID = 0;
        m_unlockType = 0;
        m_price = 0;
        m_shopType = ShopType::Normal;
    }

GJStoreItem* GJStoreItem::create(int index, int typeID, int unlockType, int price, ShopType shopType) {
        auto ret = new GJStoreItem();
        if (ret->init(index, typeID, unlockType, price, shopType)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

gd::string GJStoreItem::getCurrencyKey() {
        return m_shopType == ShopType::Diamond ? "29" : "14";
    }

bool GJStoreItem::init(int index, int typeID, int unlockType, int price, ShopType shopType) {
        if (!CCNode::init()) return false;
        m_index = index;
        m_typeID = typeID;
        m_unlockType = unlockType;
        m_price = price;
        m_shopType = shopType;
        return true;
    }

auto GJTransformControl::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJTransformControl::init), this);
	using FunctionType = decltype(init())(*)(GJTransformControl*);
	static auto func = wrapFunction(base::get() + 0x1290a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJTransformControl::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJTransformControl::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(GJTransformControl*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x12a730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJTransformControl::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJTransformControl::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(GJTransformControl*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x12a900, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJTransformControl::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJTransformControl::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(GJTransformControl*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x12ae60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJTransformControl::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJTransformControl::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(GJTransformControl*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x71210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJTransformControl::refreshControl() -> decltype(refreshControl()) {
	using FunctionType = decltype(refreshControl())(*)(GJTransformControl*);
	static auto func = wrapFunction(base::get() + 0x1295f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJTransformControl::scaleButtons(float p0) -> decltype(scaleButtons(p0)) {
	using FunctionType = decltype(scaleButtons(p0))(*)(GJTransformControl*, float);
	static auto func = wrapFunction(base::get() + 0x129810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

cocos2d::CCSprite* GJTransformControl::spriteByTag(int tag) {
        return static_cast<cocos2d::CCSprite*>(m_warpSprites->objectAtIndex(tag - 1));
    }

auto GJTransformControl::updateButtons(bool p0, bool p1) -> decltype(updateButtons(p0, p1)) {
	using FunctionType = decltype(updateButtons(p0, p1))(*)(GJTransformControl*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x1298d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJUINode::draw() -> decltype(draw()) {
	throw std::runtime_error("GJUINode::draw not implemented");
}

auto GJUserCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJUserCell::init), this);
	using FunctionType = decltype(init())(*)(GJUserCell*);
	static auto func = wrapFunction(base::get() + 0xb9f50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJUserCell::draw() -> decltype(draw()) {
	throw std::runtime_error("GJUserCell::draw not implemented");
}

auto GJUserCell::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&GJUserCell::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(GJUserCell*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0xbae70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJUserCell::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&GJUserCell::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(p0, p1))(*)(GJUserCell*, int, int);
	static auto func = wrapFunction(base::get() + 0xbb230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJUserCell::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&GJUserCell::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(p0, p1))(*)(GJUserCell*, int, int);
	static auto func = wrapFunction(base::get() + 0xbb3e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJUserCell::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&GJUserCell::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(GJUserCell*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0xbb4b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJUserCell::loadFromScore(GJUserScore* p0) -> decltype(loadFromScore(p0)) {
	using FunctionType = decltype(loadFromScore(p0))(*)(GJUserCell*, GJUserScore*);
	static auto func = wrapFunction(base::get() + 0xb9f70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJUserMessage::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x170ec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJUserMessage::create(cocos2d::CCDictionary* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(cocos2d::CCDictionary*);
	static auto func = wrapFunction(base::get() + 0x170380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJUserMessage::init() -> decltype(init()) {
	throw std::runtime_error("GJUserMessage::init not implemented");
}

GJUserScore::GJUserScore() : GJUserScore(geode::CutoffConstructor, sizeof(GJUserScore)) {
	// here we construct it as normal as we can, then destruct it
	// using the generated functions. this ensures no memory gets leaked
	// no crashes :pray:
	CCDestructor::lock(this) = true;
	GJUserScore::~GJUserScore();
	using FunctionType = void(*)(GJUserScore*);
	static auto func = wrapFunction(base::get() + 0x1401d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
}

auto GJUserScore::create(cocos2d::CCDictionary* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(cocos2d::CCDictionary*);
	static auto func = wrapFunction(base::get() + 0x16e1a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

GJUserScore* GJUserScore::create() {
        auto ret = new GJUserScore();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }

        delete ret;
        return nullptr;
    }

auto GJUserScore::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJUserScore::init), this);
	using FunctionType = decltype(init())(*)(GJUserScore*);
	static auto func = wrapFunction(base::get() + 0x16fb40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJUserScore::isCurrentUser() -> decltype(isCurrentUser()) {
	using FunctionType = decltype(isCurrentUser())(*)(GJUserScore*);
	static auto func = wrapFunction(base::get() + 0x16fb90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto UploadMessageDelegate::uploadMessageFinished(int p0) -> decltype(uploadMessageFinished(p0)) {
	throw std::runtime_error("UploadMessageDelegate::uploadMessageFinished not implemented");
}

auto UploadMessageDelegate::uploadMessageFailed(int p0) -> decltype(uploadMessageFailed(p0)) {
	throw std::runtime_error("UploadMessageDelegate::uploadMessageFailed not implemented");
}

auto GJWriteMessagePopup::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("GJWriteMessagePopup::registerWithTouchDispatcher not implemented");
}

auto GJWriteMessagePopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJWriteMessagePopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(GJWriteMessagePopup*);
	static auto func = wrapFunction(base::get() + 0x2930d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void GJWriteMessagePopup::textInputOpened(CCTextInputNode* p0) {}

auto GJWriteMessagePopup::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	throw std::runtime_error("GJWriteMessagePopup::textInputClosed not implemented");
}

auto GJWriteMessagePopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&GJWriteMessagePopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(GJWriteMessagePopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x2930e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJWriteMessagePopup::uploadMessageFinished(int p0) -> decltype(uploadMessageFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&GJWriteMessagePopup::uploadMessageFinished), this);
	using FunctionType = decltype(uploadMessageFinished(p0))(*)(GJWriteMessagePopup*, int);
	static auto func = wrapFunction(base::get() + 0x2936c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJWriteMessagePopup::uploadMessageFailed(int p0) -> decltype(uploadMessageFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&GJWriteMessagePopup::uploadMessageFailed), this);
	using FunctionType = decltype(uploadMessageFailed(p0))(*)(GJWriteMessagePopup*, int);
	static auto func = wrapFunction(base::get() + 0x293740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJWriteMessagePopup::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&GJWriteMessagePopup::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(GJWriteMessagePopup*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x2937f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJWriteMessagePopup::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&GJWriteMessagePopup::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(GJWriteMessagePopup*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x293890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJWriteMessagePopup::textInputShouldOffset(CCTextInputNode* p0, float p1) -> decltype(textInputShouldOffset(p0, p1)) {
	throw std::runtime_error("GJWriteMessagePopup::textInputShouldOffset not implemented");
}

auto GJWriteMessagePopup::textInputReturn(CCTextInputNode* p0) -> decltype(textInputReturn(p0)) {
	throw std::runtime_error("GJWriteMessagePopup::textInputReturn not implemented");
}

void GooglePlayDelegate::googlePlaySignedIn() {}

auto GooglePlayManager::init() -> decltype(init()) {
	throw std::runtime_error("GooglePlayManager::init not implemented");
}

auto GradientTriggerObject::init() -> decltype(init()) {
	throw std::runtime_error("GradientTriggerObject::init not implemented");
}

auto GradientTriggerObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("GradientTriggerObject::customObjectSetup not implemented");
}

auto GradientTriggerObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("GradientTriggerObject::getSaveString not implemented");
}

GraphicsReloadLayer::GraphicsReloadLayer() {
        m_resolution = cocos2d::CCSize {};
    }

GraphicsReloadLayer* GraphicsReloadLayer::create(cocos2d::TextureQuality quality, cocos2d::CCSize resolution, bool windowed, bool borderless, bool fix, bool changedResolution) {
        auto ret = new GraphicsReloadLayer();
        if (ret->init(quality, resolution, windowed, borderless, fix, changedResolution)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

cocos2d::CCScene* GraphicsReloadLayer::scene(cocos2d::TextureQuality quality, cocos2d::CCSize resolution, bool windowed, bool borderless, bool fix, bool changedResolution) {
        auto scene = cocos2d::CCScene::create();
        auto layer = GraphicsReloadLayer::create(quality, resolution, windowed, borderless, fix, changedResolution);
        scene->addChild(layer);
        return scene;
    }

bool GraphicsReloadLayer::init(cocos2d::TextureQuality quality, cocos2d::CCSize resolution, bool windowed, bool borderless, bool fix, bool changedResolution) {
        if (!CCLayer::init()) return false;
        m_quality = quality;
        m_resolution = resolution;
        m_changedResolution = changedResolution;
        m_windowed = windowed;
        m_borderless = borderless;
        m_fix = fix;
        this->runAction(cocos2d::CCSequence::create(
            cocos2d::CCDelayTime::create(.1f),
            cocos2d::CCCallFunc::create(this, callfunc_selector(GraphicsReloadLayer::performReload)),
            nullptr
        ));
        return true;
    }

auto GraphicsReloadLayer::performReload() -> decltype(performReload()) {
	using FunctionType = decltype(performReload())(*)(GraphicsReloadLayer*);
	static auto func = wrapFunction(base::get() + 0x366490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GravityEffectSprite::init() -> decltype(init()) {
	throw std::runtime_error("GravityEffectSprite::init not implemented");
}

auto GravityEffectSprite::draw() -> decltype(draw()) {
	throw std::runtime_error("GravityEffectSprite::draw not implemented");
}

auto HardStreak::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x2b1680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto HardStreak::init() -> decltype(init()) {
	throw std::runtime_error("HardStreak::init not implemented");
}

auto HardStreak::addPoint(cocos2d::CCPoint p0) -> decltype(addPoint(p0)) {
	using FunctionType = decltype(addPoint(p0))(*)(HardStreak*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x2b2130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

HardStreak* HardStreak::createDuplicate() {
        auto ret = HardStreak::create();
        ret->setBlendFunc(this->getBlendFunc());
        ret->m_currentPoint = m_currentPoint;
        ret->m_isSolid = m_isSolid;
        ret->m_waveSize = m_waveSize;
        ret->m_isSolid = m_isSolid;
        ret->m_isFlipped = m_isFlipped;
        ret->m_pulseSize = m_pulseSize;
        ret->setOpacity(this->getOpacity());
        ret->setColor(this->getColor());

        CCObject* obj;
        CCARRAY_FOREACH(m_pointArray, obj){
            auto nodePoint = static_cast<PointNode*>(obj);
            ret->addPoint(nodePoint->m_point);
        }

        return ret;
    }

void HardStreak::reset() {
        this->clear();
        m_pointArray->removeAllObjects();
    }

auto HardStreak::stopStroke() -> decltype(stopStroke()) {
	using FunctionType = decltype(stopStroke())(*)(HardStreak*);
	static auto func = wrapFunction(base::get() + 0x2b17f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto HardStreak::updateStroke(float p0) -> decltype(updateStroke(p0)) {
	using FunctionType = decltype(updateStroke(p0))(*)(HardStreak*, float);
	static auto func = wrapFunction(base::get() + 0x2b1830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

HSVLiveOverlay::HSVLiveOverlay() {
        m_object = nullptr;
        m_objects = nullptr;
        m_controls = nullptr;
        m_unkArray = nullptr;
        m_delegate = nullptr;
        m_activeTab = -1;
        m_widget = nullptr;
        m_unkBool1 = false;
        m_unkBool2 = false;
        m_unkBool3 = false;
    }

HSVLiveOverlay* HSVLiveOverlay::create(GameObject* object, cocos2d::CCArray* objects) {
        auto ret = new HSVLiveOverlay();
        if (ret->init(object, objects)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto HSVLiveOverlay::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&HSVLiveOverlay::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(HSVLiveOverlay*);
	static auto func = wrapFunction(base::get() + 0x2b2bb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto HSVLiveOverlay::show() -> decltype(show()) {
	throw std::runtime_error("HSVLiveOverlay::show not implemented");
}

auto HSVLiveOverlay::hsvChanged(ConfigureHSVWidget* p0) -> decltype(hsvChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<ConfigureHSVWidget*>::func(&HSVLiveOverlay::hsvChanged), this);
	using FunctionType = decltype(hsvChanged(p0))(*)(HSVLiveOverlay*, ConfigureHSVWidget*);
	static auto func = wrapFunction(base::get() + 0x2b2c00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto HSVLiveOverlay::createHSVWidget(int p0) -> decltype(createHSVWidget(p0)) {
	using FunctionType = decltype(createHSVWidget(p0))(*)(HSVLiveOverlay*, int);
	static auto func = wrapFunction(base::get() + 0x2b2a10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto HSVLiveOverlay::determineStartValues() -> decltype(determineStartValues()) {
	using FunctionType = decltype(determineStartValues())(*)(HSVLiveOverlay*);
	static auto func = wrapFunction(base::get() + 0x2b2790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto HSVLiveOverlay::init(GameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(HSVLiveOverlay*, GameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x2b22f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto HSVLiveOverlay::onSelectTab(cocos2d::CCObject* sender) -> decltype(onSelectTab(sender)) {
	using FunctionType = decltype(onSelectTab(sender))(*)(HSVLiveOverlay*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b29e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto HSVWidgetPopup::create(cocos2d::ccHSVValue p0, HSVWidgetDelegate* p1, gd::string p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(cocos2d::ccHSVValue, HSVWidgetDelegate*, gd::string);
	static auto func = wrapFunction(base::get() + 0x96410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto HSVWidgetPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&HSVWidgetPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(HSVWidgetPopup*);
	static auto func = wrapFunction(base::get() + 0x96940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto HSVWidgetPopup::init(cocos2d::ccHSVValue p0, HSVWidgetDelegate* p1, gd::string p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(HSVWidgetPopup*, cocos2d::ccHSVValue, HSVWidgetDelegate*, gd::string);
	static auto func = wrapFunction(base::get() + 0x96530, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto HSVWidgetPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(HSVWidgetPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x96860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto InfoAlertButton::create(gd::string title, gd::string desc, float spriteScale) -> decltype(create(title, desc, spriteScale)) {
	using FunctionType = decltype(create(title, desc, spriteScale))(*)(gd::string, gd::string, float);
	static auto func = wrapFunction(base::get() + 0x2b2d80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(title, desc, spriteScale);
}

auto InfoAlertButton::activate() -> decltype(activate()) {
	throw std::runtime_error("InfoAlertButton::activate not implemented");
}

void LevelCommentDelegate::loadCommentsFinished(cocos2d::CCArray* p0, char const* p1) {}

void LevelCommentDelegate::loadCommentsFailed(char const* p0) {}

void LevelCommentDelegate::updateUserScoreFinished() {}

void LevelCommentDelegate::setupPageInfo(gd::string p0, char const* p1) {}

auto InfoLayer::create(GJGameLevel* p0, GJUserScore* p1, GJLevelList* p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(GJGameLevel*, GJUserScore*, GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x2b3200, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto InfoLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("InfoLayer::registerWithTouchDispatcher not implemented");
}

auto InfoLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&InfoLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(InfoLayer*);
	static auto func = wrapFunction(base::get() + 0x2b6b40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto InfoLayer::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&InfoLayer::show), this);
	using FunctionType = decltype(show())(*)(InfoLayer*);
	static auto func = wrapFunction(base::get() + 0x2b7fd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto InfoLayer::loadCommentsFinished(cocos2d::CCArray* p0, char const* p1) -> decltype(loadCommentsFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*, char const*>::func(&InfoLayer::loadCommentsFinished), this);
	using FunctionType = decltype(loadCommentsFinished(p0, p1))(*)(InfoLayer*, cocos2d::CCArray*, char const*);
	static auto func = wrapFunction(base::get() + 0x2b7480, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto InfoLayer::loadCommentsFailed(char const* p0) -> decltype(loadCommentsFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&InfoLayer::loadCommentsFailed), this);
	using FunctionType = decltype(loadCommentsFailed(p0))(*)(InfoLayer*, char const*);
	static auto func = wrapFunction(base::get() + 0x2b74f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto InfoLayer::setupPageInfo(gd::string p0, char const* p1) -> decltype(setupPageInfo(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string, char const*>::func(&InfoLayer::setupPageInfo), this);
	using FunctionType = decltype(setupPageInfo(p0, p1))(*)(InfoLayer*, gd::string, char const*);
	static auto func = wrapFunction(base::get() + 0x2b7540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto InfoLayer::commentUploadFinished(int p0) -> decltype(commentUploadFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&InfoLayer::commentUploadFinished), this);
	using FunctionType = decltype(commentUploadFinished(p0))(*)(InfoLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2b7880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto InfoLayer::commentUploadFailed(int p0, CommentError p1) -> decltype(commentUploadFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, CommentError>::func(&InfoLayer::commentUploadFailed), this);
	using FunctionType = decltype(commentUploadFailed(p0, p1))(*)(InfoLayer*, int, CommentError);
	static auto func = wrapFunction(base::get() + 0x2b7950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto InfoLayer::updateUserScoreFinished() -> decltype(updateUserScoreFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&InfoLayer::updateUserScoreFinished), this);
	using FunctionType = decltype(updateUserScoreFinished())(*)(InfoLayer*);
	static auto func = wrapFunction(base::get() + 0x2b7730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto InfoLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&InfoLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(InfoLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x2b5ce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto InfoLayer::confirmReport(cocos2d::CCObject* p0) -> decltype(confirmReport(p0)) {
	using FunctionType = decltype(confirmReport(p0))(*)(InfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b5780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

int InfoLayer::getID() {
        if(m_score) return m_score->m_userID;
        if(m_levelList) return - m_levelList->m_listID;
        if(m_level) return m_level->m_levelID;
        return 0;
    }

auto InfoLayer::getSpriteButton(char const* p0, cocos2d::SEL_MenuHandler p1, cocos2d::CCMenu* p2, float p3, cocos2d::CCPoint p4) -> decltype(getSpriteButton(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(getSpriteButton(p0, p1, p2, p3, p4))(*)(InfoLayer*, char const*, cocos2d::SEL_MenuHandler, cocos2d::CCMenu*, float, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x2b52e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto InfoLayer::init(GJGameLevel* p0, GJUserScore* p1, GJLevelList* p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(InfoLayer*, GJGameLevel*, GJUserScore*, GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x2b33a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto InfoLayer::loadPage(int p0, bool p1) -> decltype(loadPage(p0, p1)) {
	using FunctionType = decltype(loadPage(p0, p1))(*)(InfoLayer*, int, bool);
	static auto func = wrapFunction(base::get() + 0x2b6c80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto InfoLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(InfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b6ac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto InfoLayer::onComment(cocos2d::CCObject* sender) -> decltype(onComment(sender)) {
	using FunctionType = decltype(onComment(sender))(*)(InfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b5f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto InfoLayer::onLevelInfo(cocos2d::CCObject* sender) -> decltype(onLevelInfo(sender)) {
	using FunctionType = decltype(onLevelInfo(sender))(*)(InfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b64e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto InfoLayer::onMore(cocos2d::CCObject* sender) -> decltype(onMore(sender)) {
	using FunctionType = decltype(onMore(sender))(*)(InfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b5e00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto InfoLayer::onNextPage(cocos2d::CCObject* sender) -> decltype(onNextPage(sender)) {
	using FunctionType = decltype(onNextPage(sender))(*)(InfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b7860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto InfoLayer::onOriginal(cocos2d::CCObject* sender) -> decltype(onOriginal(sender)) {
	using FunctionType = decltype(onOriginal(sender))(*)(InfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b5e60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto InfoLayer::onPrevPage(cocos2d::CCObject* sender) -> decltype(onPrevPage(sender)) {
	using FunctionType = decltype(onPrevPage(sender))(*)(InfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b7870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto InfoLayer::reloadWindow() -> decltype(reloadWindow()) {
	using FunctionType = decltype(reloadWindow())(*)(InfoLayer*);
	static auto func = wrapFunction(base::get() + 0x2b7bf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto InfoLayer::setupCommentsBrowser(cocos2d::CCArray* p0) -> decltype(setupCommentsBrowser(p0)) {
	using FunctionType = decltype(setupCommentsBrowser(p0))(*)(InfoLayer*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x2b71f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto InfoLayer::setupLevelInfo() -> decltype(setupLevelInfo()) {
	using FunctionType = decltype(setupLevelInfo())(*)(InfoLayer*);
	static auto func = wrapFunction(base::get() + 0x2b5420, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto InfoLayer::toggleCommentMode(cocos2d::CCObject* sender) -> decltype(toggleCommentMode(sender)) {
	using FunctionType = decltype(toggleCommentMode(sender))(*)(InfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b7e10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto InfoLayer::toggleExtendedMode(cocos2d::CCObject* sender) -> decltype(toggleExtendedMode(sender)) {
	using FunctionType = decltype(toggleExtendedMode(sender))(*)(InfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b7aa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto InfoLayer::toggleSmallCommentMode(cocos2d::CCObject* sender) -> decltype(toggleSmallCommentMode(sender)) {
	using FunctionType = decltype(toggleSmallCommentMode(sender))(*)(InfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b7b00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto InfoLayer::updateCommentModeButtons() -> decltype(updateCommentModeButtons()) {
	using FunctionType = decltype(updateCommentModeButtons())(*)(InfoLayer*);
	static auto func = wrapFunction(base::get() + 0x2b7ed0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ItemInfoPopup::create(int p0, UnlockType p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(int, UnlockType);
	static auto func = wrapFunction(base::get() + 0x273e30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto ItemInfoPopup::nameForUnlockType(int p0, UnlockType p1) -> decltype(nameForUnlockType(p0, p1)) {
	using FunctionType = decltype(nameForUnlockType(p0, p1))(*)(int, UnlockType);
	static auto func = wrapFunction(base::get() + 0x275ef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto ItemInfoPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("ItemInfoPopup::keyBackClicked not implemented");
}

auto ItemInfoPopup::init(int p0, UnlockType p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(ItemInfoPopup*, int, UnlockType);
	static auto func = wrapFunction(base::get() + 0x273f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto ItemInfoPopup::onCredit(cocos2d::CCObject* sender) -> decltype(onCredit(sender)) {
	using FunctionType = decltype(onCredit(sender))(*)(ItemInfoPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x275ec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ItemTriggerGameObject::customSetup() -> decltype(customSetup()) {
	throw std::runtime_error("ItemTriggerGameObject::customSetup not implemented");
}

auto ItemTriggerGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*, int, gd::vector<int> const*>::func(&ItemTriggerGameObject::triggerObject), this);
	using FunctionType = decltype(triggerObject(p0, p1, p2))(*)(ItemTriggerGameObject*, GJBaseGameLayer*, int, gd::vector<int> const*);
	static auto func = wrapFunction(base::get() + 0x4a71a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto ItemTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("ItemTriggerGameObject::customObjectSetup not implemented");
}

auto ItemTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&ItemTriggerGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(ItemTriggerGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x4a7300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto KeybindingsLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x2b81d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto KeybindingsLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&KeybindingsLayer::init), this);
	using FunctionType = decltype(init())(*)(KeybindingsLayer*);
	static auto func = wrapFunction(base::get() + 0x2b82c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto KeybindingsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("KeybindingsLayer::keyBackClicked not implemented");
}

auto KeybindingsLayer::addKeyPair(char const* p0, char const* p1) -> decltype(addKeyPair(p0, p1)) {
	using FunctionType = decltype(addKeyPair(p0, p1))(*)(KeybindingsLayer*, char const*, char const*);
	static auto func = wrapFunction(base::get() + 0x2b8bd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto KeybindingsLayer::countForPage(int p0) -> decltype(countForPage(p0)) {
	using FunctionType = decltype(countForPage(p0))(*)(KeybindingsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2b8f80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto KeybindingsLayer::goToPage(int p0) -> decltype(goToPage(p0)) {
	using FunctionType = decltype(goToPage(p0))(*)(KeybindingsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2b9220, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto KeybindingsLayer::layerForPage(int p0) -> decltype(layerForPage(p0)) {
	using FunctionType = decltype(layerForPage(p0))(*)(KeybindingsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2b9050, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto KeybindingsLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(KeybindingsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x84620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto KeybindingsLayer::onNextPage(cocos2d::CCObject* sender) -> decltype(onNextPage(sender)) {
	using FunctionType = decltype(onNextPage(sender))(*)(KeybindingsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b9200, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto KeybindingsLayer::onPrevPage(cocos2d::CCObject* sender) -> decltype(onPrevPage(sender)) {
	using FunctionType = decltype(onPrevPage(sender))(*)(KeybindingsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b9210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto KeybindingsManager::init() -> decltype(init()) {
	throw std::runtime_error("KeybindingsManager::init not implemented");
}

auto KeyframeAnimTriggerObject::init() -> decltype(init()) {
	throw std::runtime_error("KeyframeAnimTriggerObject::init not implemented");
}

auto KeyframeAnimTriggerObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("KeyframeAnimTriggerObject::customObjectSetup not implemented");
}

auto KeyframeAnimTriggerObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("KeyframeAnimTriggerObject::getSaveString not implemented");
}

auto KeyframeGameObject::init() -> decltype(init()) {
	throw std::runtime_error("KeyframeGameObject::init not implemented");
}

auto KeyframeGameObject::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&KeyframeGameObject::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(KeyframeGameObject*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x49cba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto KeyframeGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("KeyframeGameObject::customObjectSetup not implemented");
}

auto KeyframeGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("KeyframeGameObject::getSaveString not implemented");
}

auto LabelGameObject::init() -> decltype(init()) {
	throw std::runtime_error("LabelGameObject::init not implemented");
}

auto LabelGameObject::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&LabelGameObject::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(LabelGameObject*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x49ac60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LabelGameObject::setupCustomSprites(gd::string p0) -> decltype(setupCustomSprites(p0)) {
	throw std::runtime_error("LabelGameObject::setupCustomSprites not implemented");
}

auto LabelGameObject::addMainSpriteToParent(bool p0) -> decltype(addMainSpriteToParent(p0)) {
	throw std::runtime_error("LabelGameObject::addMainSpriteToParent not implemented");
}

auto LabelGameObject::resetObject() -> decltype(resetObject()) {
	throw std::runtime_error("LabelGameObject::resetObject not implemented");
}

auto LabelGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("LabelGameObject::customObjectSetup not implemented");
}

auto LabelGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("LabelGameObject::getSaveString not implemented");
}

auto LabelGameObject::setObjectColor(cocos2d::ccColor3B const& p0) -> decltype(setObjectColor(p0)) {
	throw std::runtime_error("LabelGameObject::setObjectColor not implemented");
}

auto LabelGameObject::updateTextKerning(int p0) -> decltype(updateTextKerning(p0)) {
	throw std::runtime_error("LabelGameObject::updateTextKerning not implemented");
}

auto LabelGameObject::getTextKerning() -> decltype(getTextKerning()) {
	throw std::runtime_error("LabelGameObject::getTextKerning not implemented");
}

auto LabelGameObject::updateLabel(float p0) -> decltype(updateLabel(p0)) {
	using FunctionType = decltype(updateLabel(p0))(*)(LabelGameObject*, float);
	static auto func = wrapFunction(base::get() + 0x49af00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LabelGameObject::updatePreviewLabel() -> decltype(updatePreviewLabel()) {
	using FunctionType = decltype(updatePreviewLabel())(*)(LabelGameObject*);
	static auto func = wrapFunction(base::get() + 0x49ad40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void LeaderboardManagerDelegate::updateUserScoreFinished() {}

void LeaderboardManagerDelegate::updateUserScoreFailed() {}

void LeaderboardManagerDelegate::loadLeaderboardFinished(cocos2d::CCArray* p0, char const* p1) {}

void LeaderboardManagerDelegate::loadLeaderboardFailed(char const* p0) {}

LeaderboardsLayer* LeaderboardsLayer::create(LeaderboardState state) {
        auto ret = new LeaderboardsLayer();
        if (ret->init(state)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

cocos2d::CCScene* LeaderboardsLayer::scene(LeaderboardState state) {
        auto scene = cocos2d::CCScene::create();
        auto layer = LeaderboardsLayer::create(state);
        scene->addChild(layer);
        return scene;
    }

auto LeaderboardsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LeaderboardsLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(LeaderboardsLayer*);
	static auto func = wrapFunction(base::get() + 0x2bbf50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LeaderboardsLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&LeaderboardsLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(LeaderboardsLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x2bbea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LeaderboardsLayer::updateUserScoreFinished() -> decltype(updateUserScoreFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LeaderboardsLayer::updateUserScoreFinished), this);
	using FunctionType = decltype(updateUserScoreFinished())(*)(LeaderboardsLayer*);
	static auto func = wrapFunction(base::get() + 0x2bb1f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LeaderboardsLayer::updateUserScoreFailed() -> decltype(updateUserScoreFailed()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LeaderboardsLayer::updateUserScoreFailed), this);
	using FunctionType = decltype(updateUserScoreFailed())(*)(LeaderboardsLayer*);
	static auto func = wrapFunction(base::get() + 0x2bb210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LeaderboardsLayer::loadLeaderboardFinished(cocos2d::CCArray* p0, char const* p1) -> decltype(loadLeaderboardFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*, char const*>::func(&LeaderboardsLayer::loadLeaderboardFinished), this);
	using FunctionType = decltype(loadLeaderboardFinished(p0, p1))(*)(LeaderboardsLayer*, cocos2d::CCArray*, char const*);
	static auto func = wrapFunction(base::get() + 0x2bb220, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LeaderboardsLayer::loadLeaderboardFailed(char const* p0) -> decltype(loadLeaderboardFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&LeaderboardsLayer::loadLeaderboardFailed), this);
	using FunctionType = decltype(loadLeaderboardFailed(p0))(*)(LeaderboardsLayer*, char const*);
	static auto func = wrapFunction(base::get() + 0x2bb2b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LeaderboardsLayer::init(LeaderboardState p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(LeaderboardsLayer*, LeaderboardState);
	static auto func = wrapFunction(base::get() + 0x2b9cd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LeaderboardsLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	using FunctionType = decltype(onBack(sender))(*)(LeaderboardsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2bbed0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LeaderboardsLayer::refreshTabs() -> decltype(refreshTabs()) {
	using FunctionType = decltype(refreshTabs())(*)(LeaderboardsLayer*);
	static auto func = wrapFunction(base::get() + 0x2bac80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LeaderboardsLayer::selectLeaderboard(LeaderboardState p0) -> decltype(selectLeaderboard(p0)) {
	using FunctionType = decltype(selectLeaderboard(p0))(*)(LeaderboardsLayer*, LeaderboardState);
	static auto func = wrapFunction(base::get() + 0x2badb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LeaderboardsLayer::setupLevelBrowser(cocos2d::CCArray* p0) -> decltype(setupLevelBrowser(p0)) {
	using FunctionType = decltype(setupLevelBrowser(p0))(*)(LeaderboardsLayer*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x2bab20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LeaderboardsLayer::toggleTabButtons() -> decltype(toggleTabButtons()) {
	using FunctionType = decltype(toggleTabButtons())(*)(LeaderboardsLayer*);
	static auto func = wrapFunction(base::get() + 0x2bb000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelAreaInnerLayer::scene(bool p0) -> decltype(scene(p0)) {
	using FunctionType = decltype(scene(p0))(*)(bool);
	static auto func = wrapFunction(base::get() + 0x2be1d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelAreaInnerLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelAreaInnerLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(LevelAreaInnerLayer*);
	static auto func = wrapFunction(base::get() + 0x2c0550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelAreaInnerLayer::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DialogLayer*>::func(&LevelAreaInnerLayer::dialogClosed), this);
	using FunctionType = decltype(dialogClosed(p0))(*)(LevelAreaInnerLayer*, DialogLayer*);
	static auto func = wrapFunction(base::get() + 0x2bf9a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelAreaInnerLayer::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelAreaInnerLayer::onExit), this);
	using FunctionType = decltype(onExit())(*)(LevelAreaInnerLayer*);
	static auto func = wrapFunction(base::get() + 0x2c0500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelAreaInnerLayer::init(bool p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(LevelAreaInnerLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x2be2e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelAreaInnerLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	using FunctionType = decltype(onBack(sender))(*)(LevelAreaInnerLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2c04a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelAreaInnerLayer::onDoor(cocos2d::CCObject* sender) -> decltype(onDoor(sender)) {
	using FunctionType = decltype(onDoor(sender))(*)(LevelAreaInnerLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2bffd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelAreaLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelAreaLayer::init), this);
	using FunctionType = decltype(init())(*)(LevelAreaLayer*);
	static auto func = wrapFunction(base::get() + 0x2bc1d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelAreaLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelAreaLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(LevelAreaLayer*);
	static auto func = wrapFunction(base::get() + 0x2be1c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelAreaLayer::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DialogLayer*>::func(&LevelAreaLayer::dialogClosed), this);
	using FunctionType = decltype(dialogClosed(p0))(*)(LevelAreaLayer*, DialogLayer*);
	static auto func = wrapFunction(base::get() + 0x2bd3b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelAreaLayer::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelAreaLayer::onExit), this);
	using FunctionType = decltype(onExit())(*)(LevelAreaLayer*);
	static auto func = wrapFunction(base::get() + 0x2be170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void SetTextPopupDelegate::setTextPopupClosed(SetTextPopup* p0, gd::string p1) {}

auto ShareCommentDelegate::shareCommentClosed(gd::string p0, ShareCommentLayer* p1) -> decltype(shareCommentClosed(p0, p1)) {
	throw std::runtime_error("ShareCommentDelegate::shareCommentClosed not implemented");
}

LevelBrowserLayer::LevelBrowserLayer() {}

LevelBrowserLayer::~LevelBrowserLayer() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(LevelBrowserLayer*);
	static auto func = wrapFunction(base::get() + 0x2c07c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) LevelBrowserLayer(geode::CutoffConstructor, sizeof(LevelBrowserLayer));
	CCDestructor::lock(this) = true;
}

auto LevelBrowserLayer::create(GJSearchObject* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0x2c09f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelBrowserLayer::scene(GJSearchObject* search) -> decltype(scene(search)) {
	using FunctionType = decltype(scene(search))(*)(GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0x2c09a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(search);
}

auto LevelBrowserLayer::onEnter() -> decltype(onEnter()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelBrowserLayer::onEnter), this);
	using FunctionType = decltype(onEnter())(*)(LevelBrowserLayer*);
	static auto func = wrapFunction(base::get() + 0x2c78b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelBrowserLayer::onEnterTransitionDidFinish() -> decltype(onEnterTransitionDidFinish()) {
	throw std::runtime_error("LevelBrowserLayer::onEnterTransitionDidFinish not implemented");
}

auto LevelBrowserLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	throw std::runtime_error("LevelBrowserLayer::ccTouchBegan not implemented");
}

void LevelBrowserLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

void LevelBrowserLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

void LevelBrowserLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

auto LevelBrowserLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelBrowserLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(LevelBrowserLayer*);
	static auto func = wrapFunction(base::get() + 0x2c79f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelBrowserLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelBrowserLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(LevelBrowserLayer*);
	static auto func = wrapFunction(base::get() + 0x2c4d30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelBrowserLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&LevelBrowserLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(LevelBrowserLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x2c4d50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelBrowserLayer::loadLevelsFinished(cocos2d::CCArray* p0, char const* p1, int p2) -> decltype(loadLevelsFinished(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*, char const*, int>::func(&LevelBrowserLayer::loadLevelsFinished), this);
	using FunctionType = decltype(loadLevelsFinished(p0, p1, p2))(*)(LevelBrowserLayer*, cocos2d::CCArray*, char const*, int);
	static auto func = wrapFunction(base::get() + 0x2c4240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto LevelBrowserLayer::loadLevelsFailed(char const* p0, int p1) -> decltype(loadLevelsFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<char const*, int>::func(&LevelBrowserLayer::loadLevelsFailed), this);
	using FunctionType = decltype(loadLevelsFailed(p0, p1))(*)(LevelBrowserLayer*, char const*, int);
	static auto func = wrapFunction(base::get() + 0x2c4370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelBrowserLayer::setupPageInfo(gd::string p0, char const* p1) -> decltype(setupPageInfo(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string, char const*>::func(&LevelBrowserLayer::setupPageInfo), this);
	using FunctionType = decltype(setupPageInfo(p0, p1))(*)(LevelBrowserLayer*, gd::string, char const*);
	static auto func = wrapFunction(base::get() + 0x2c43c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelBrowserLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&LevelBrowserLayer::onBack), this);
	using FunctionType = decltype(onBack(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2c4ca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto LevelBrowserLayer::shareCommentClosed(gd::string p0, ShareCommentLayer* p1) -> decltype(shareCommentClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string, ShareCommentLayer*>::func(&LevelBrowserLayer::shareCommentClosed), this);
	using FunctionType = decltype(shareCommentClosed(p0, p1))(*)(LevelBrowserLayer*, gd::string, ShareCommentLayer*);
	static auto func = wrapFunction(base::get() + 0x2c5d50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelBrowserLayer::setTextPopupClosed(SetTextPopup* p0, gd::string p1) -> decltype(setTextPopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<SetTextPopup*, gd::string>::func(&LevelBrowserLayer::setTextPopupClosed), this);
	using FunctionType = decltype(setTextPopupClosed(p0, p1))(*)(LevelBrowserLayer*, SetTextPopup*, gd::string);
	static auto func = wrapFunction(base::get() + 0x2c6ac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelBrowserLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&LevelBrowserLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(LevelBrowserLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x2c72f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelBrowserLayer::setIDPopupClosed(SetIDPopup* p0, int p1) -> decltype(setIDPopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<SetIDPopup*, int>::func(&LevelBrowserLayer::setIDPopupClosed), this);
	using FunctionType = decltype(setIDPopupClosed(p0, p1))(*)(LevelBrowserLayer*, SetIDPopup*, int);
	static auto func = wrapFunction(base::get() + 0x2c4870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelBrowserLayer::updateResultArray(cocos2d::CCArray* p0) -> decltype(updateResultArray(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*>::func(&LevelBrowserLayer::updateResultArray), this);
	using FunctionType = decltype(updateResultArray(p0))(*)(LevelBrowserLayer*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x2c0770, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelBrowserLayer::cellPerformedAction(TableViewCell* p0, int p1, CellAction p2, cocos2d::CCNode* p3) -> decltype(cellPerformedAction(p0, p1, p2, p3)) {
	auto self = addresser::thunkAdjust(Resolve<TableViewCell*, int, CellAction, cocos2d::CCNode*>::func(&LevelBrowserLayer::cellPerformedAction), this);
	using FunctionType = decltype(cellPerformedAction(p0, p1, p2, p3))(*)(LevelBrowserLayer*, TableViewCell*, int, CellAction, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x2c7950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3);
}

auto LevelBrowserLayer::getItemsMatchingSearch(cocos2d::CCArray* p0, gd::string p1, GJSearchObject* p2) -> decltype(getItemsMatchingSearch(p0, p1, p2)) {
	using FunctionType = decltype(getItemsMatchingSearch(p0, p1, p2))(*)(LevelBrowserLayer*, cocos2d::CCArray*, gd::string, GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0x2c6b80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto LevelBrowserLayer::getSearchTitle() -> decltype(getSearchTitle()) {
	using FunctionType = decltype(getSearchTitle())(*)(LevelBrowserLayer*);
	static auto func = wrapFunction(base::get() + 0x2c39e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelBrowserLayer::init(GJSearchObject* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(LevelBrowserLayer*, GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0x2c0a60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelBrowserLayer::isCorrect(char const* p0) -> decltype(isCorrect(p0)) {
	using FunctionType = decltype(isCorrect(p0))(*)(LevelBrowserLayer*, char const*);
	static auto func = wrapFunction(base::get() + 0x2c2370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelBrowserLayer::loadPage(GJSearchObject* p0) -> decltype(loadPage(p0)) {
	using FunctionType = decltype(loadPage(p0))(*)(LevelBrowserLayer*, GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0x2c2540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelBrowserLayer::onClearSearch(cocos2d::CCObject* sender) -> decltype(onClearSearch(sender)) {
	using FunctionType = decltype(onClearSearch(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2c67a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onDeleteAll(cocos2d::CCObject* sender) -> decltype(onDeleteAll(sender)) {
	using FunctionType = decltype(onDeleteAll(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2c61f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onDeleteSelected(cocos2d::CCObject* sender) -> decltype(onDeleteSelected(sender)) {
	using FunctionType = decltype(onDeleteSelected(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2c6f10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onFavorites(cocos2d::CCObject* sender) -> decltype(onFavorites(sender)) {
	using FunctionType = decltype(onFavorites(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2c6030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onGoToFolder(cocos2d::CCObject* sender) -> decltype(onGoToFolder(sender)) {
	using FunctionType = decltype(onGoToFolder(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2c47c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onGoToLastPage(cocos2d::CCObject* sender) -> decltype(onGoToLastPage(sender)) {
	using FunctionType = decltype(onGoToLastPage(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2c4640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onGoToPage(cocos2d::CCObject* sender) -> decltype(onGoToPage(sender)) {
	using FunctionType = decltype(onGoToPage(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2c46b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onInfo(cocos2d::CCObject* sender) -> decltype(onInfo(sender)) {
	using FunctionType = decltype(onInfo(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2c4df0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onLocalMode(cocos2d::CCObject* sender) -> decltype(onLocalMode(sender)) {
	using FunctionType = decltype(onLocalMode(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2c5c70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onMyOnlineLevels(cocos2d::CCObject* sender) -> decltype(onMyOnlineLevels(sender)) {
	using FunctionType = decltype(onMyOnlineLevels(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2c5e60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onNew(cocos2d::CCObject* sender) -> decltype(onNew(sender)) {
	using FunctionType = decltype(onNew(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2c57c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onNextPage(cocos2d::CCObject* sender) -> decltype(onNextPage(sender)) {
	using FunctionType = decltype(onNextPage(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2c4ba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onPrevPage(cocos2d::CCObject* sender) -> decltype(onPrevPage(sender)) {
	using FunctionType = decltype(onPrevPage(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2c4c20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onRefresh(cocos2d::CCObject* sender) -> decltype(onRefresh(sender)) {
	using FunctionType = decltype(onRefresh(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2c6660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onSaved(cocos2d::CCObject* sender) -> decltype(onSaved(sender)) {
	using FunctionType = decltype(onSaved(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2c6110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onSavedMode(cocos2d::CCObject* sender) -> decltype(onSavedMode(sender)) {
	using FunctionType = decltype(onSavedMode(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2c5b90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onSearch(cocos2d::CCObject* sender) -> decltype(onSearch(sender)) {
	using FunctionType = decltype(onSearch(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2c6840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onToggleAllObjects(cocos2d::CCObject* sender) -> decltype(onToggleAllObjects(sender)) {
	using FunctionType = decltype(onToggleAllObjects(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2c7250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

void LevelBrowserLayer::reloadAllObjects() {
        static_cast<CustomListView*>(m_list->m_listView)->reloadAll();
    }

auto LevelBrowserLayer::setupLevelBrowser(cocos2d::CCArray* p0) -> decltype(setupLevelBrowser(p0)) {
	using FunctionType = decltype(setupLevelBrowser(p0))(*)(LevelBrowserLayer*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x2c36d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelBrowserLayer::show() -> decltype(show()) {
	using FunctionType = decltype(show())(*)(LevelBrowserLayer*);
	static auto func = wrapFunction(base::get() + 0x2c7a60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelBrowserLayer::updatePageLabel() -> decltype(updatePageLabel()) {
	using FunctionType = decltype(updatePageLabel())(*)(LevelBrowserLayer*);
	static auto func = wrapFunction(base::get() + 0x2c4a70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

LevelCell::LevelCell(char const* p0, float p1, float p2) : LevelCell(geode::CutoffConstructor, sizeof(LevelCell)) {
	// here we construct it as normal as we can, then destruct it
	// using the generated functions. this ensures no memory gets leaked
	// no crashes :pray:
	CCDestructor::lock(this) = true;
	LevelCell::~LevelCell();
	using FunctionType = void(*)(LevelCell*, char const*, float, float);
	static auto func = wrapFunction(base::get() + 0xad870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto LevelCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelCell::init), this);
	using FunctionType = decltype(init())(*)(LevelCell*);
	static auto func = wrapFunction(base::get() + 0xad920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelCell::draw), this);
	using FunctionType = decltype(draw())(*)(LevelCell*);
	static auto func = wrapFunction(base::get() + 0xb12e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelCell::loadCustomLevelCell() -> decltype(loadCustomLevelCell()) {
	using FunctionType = decltype(loadCustomLevelCell())(*)(LevelCell*);
	static auto func = wrapFunction(base::get() + 0xadb20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelCell::loadFromLevel(GJGameLevel* p0) -> decltype(loadFromLevel(p0)) {
	using FunctionType = decltype(loadFromLevel(p0))(*)(LevelCell*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0xad940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelCell::loadLocalLevelCell() -> decltype(loadLocalLevelCell()) {
	using FunctionType = decltype(loadLocalLevelCell())(*)(LevelCell*);
	static auto func = wrapFunction(base::get() + 0xb05f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelCell::onClick(cocos2d::CCObject* sender) -> decltype(onClick(sender)) {
	using FunctionType = decltype(onClick(sender))(*)(LevelCell*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xb1080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelCell::onViewProfile(cocos2d::CCObject* sender) -> decltype(onViewProfile(sender)) {
	using FunctionType = decltype(onViewProfile(sender))(*)(LevelCell*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xb12a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelCell::updateCellMode(int p0) -> decltype(updateCellMode(p0)) {
	using FunctionType = decltype(updateCellMode(p0))(*)(LevelCell*, int);
	static auto func = wrapFunction(base::get() + 0xb0df0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void LevelDeleteDelegate::levelDeleteFinished(int p0) {}

void LevelDeleteDelegate::levelDeleteFailed(int p0) {}

void LevelSettingsDelegate::levelSettingsUpdated() {}

LevelEditorLayer::LevelEditorLayer() : LevelEditorLayer(geode::CutoffConstructor, sizeof(LevelEditorLayer)) {
	// here we construct it as normal as we can, then destruct it
	// using the generated functions. this ensures no memory gets leaked
	// no crashes :pray:
	CCDestructor::lock(this) = true;
	LevelEditorLayer::~LevelEditorLayer();
	using FunctionType = void(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x2c86d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::create(GJGameLevel* p0, bool p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(GJGameLevel*, bool);
	static auto func = wrapFunction(base::get() + 0x2c9650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

LevelEditorLayer* LevelEditorLayer::get() {
        return GameManager::sharedState()->m_levelEditorLayer;
    }

cocos2d::CCScene* LevelEditorLayer::scene(GJGameLevel* level, bool p1) {
        auto scene = cocos2d::CCScene::create();
        auto layer = LevelEditorLayer::create(level, p1);
        scene->addChild(layer);
        return scene;
    }

auto LevelEditorLayer::updateObjectLabel(GameObject* p0) -> decltype(updateObjectLabel(p0)) {
	using FunctionType = decltype(updateObjectLabel(p0))(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x2cef40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelEditorLayer::draw() -> decltype(draw()) {
	throw std::runtime_error("LevelEditorLayer::draw not implemented");
}

auto LevelEditorLayer::postUpdate(float p0) -> decltype(postUpdate(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&LevelEditorLayer::postUpdate), this);
	using FunctionType = decltype(postUpdate(p0))(*)(LevelEditorLayer*, float);
	static auto func = wrapFunction(base::get() + 0x2d88d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelEditorLayer::updateVisibility(float p0) -> decltype(updateVisibility(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&LevelEditorLayer::updateVisibility), this);
	using FunctionType = decltype(updateVisibility(p0))(*)(LevelEditorLayer*, float);
	static auto func = wrapFunction(base::get() + 0x2d0700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelEditorLayer::playerTookDamage(PlayerObject* p0) -> decltype(playerTookDamage(p0)) {
	auto self = addresser::thunkAdjust(Resolve<PlayerObject*>::func(&LevelEditorLayer::playerTookDamage), this);
	using FunctionType = decltype(playerTookDamage(p0))(*)(LevelEditorLayer*, PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x2d88c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelEditorLayer::updateColor(cocos2d::ccColor3B& color, float fadeTime, int colorID, bool blending, float opacity, cocos2d::ccHSVValue& copyHSV, int colorIDToCopy, bool copyOpacity, EffectGameObject* callerObject, int unk1, int unk2) -> decltype(updateColor(color, fadeTime, colorID, blending, opacity, copyHSV, colorIDToCopy, copyOpacity, callerObject, unk1, unk2)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B&, float, int, bool, float, cocos2d::ccHSVValue&, int, bool, EffectGameObject*, int, int>::func(&LevelEditorLayer::updateColor), this);
	using FunctionType = decltype(updateColor(color, fadeTime, colorID, blending, opacity, copyHSV, colorIDToCopy, copyOpacity, callerObject, unk1, unk2))(*)(LevelEditorLayer*, cocos2d::ccColor3B&, float, int, bool, float, cocos2d::ccHSVValue&, int, bool, EffectGameObject*, int, int);
	static auto func = wrapFunction(base::get() + 0x2d5080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, color, fadeTime, colorID, blending, opacity, copyHSV, colorIDToCopy, copyOpacity, callerObject, unk1, unk2);
}

auto LevelEditorLayer::updateDebugDraw() -> decltype(updateDebugDraw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelEditorLayer::updateDebugDraw), this);
	using FunctionType = decltype(updateDebugDraw())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x2d9510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelEditorLayer::addToGroup(GameObject* p0, int p1, bool p2) -> decltype(addToGroup(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<GameObject*, int, bool>::func(&LevelEditorLayer::addToGroup), this);
	using FunctionType = decltype(addToGroup(p0, p1, p2))(*)(LevelEditorLayer*, GameObject*, int, bool);
	static auto func = wrapFunction(base::get() + 0x2d6070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto LevelEditorLayer::removeFromGroup(GameObject* p0, int p1) -> decltype(removeFromGroup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<GameObject*, int>::func(&LevelEditorLayer::removeFromGroup), this);
	using FunctionType = decltype(removeFromGroup(p0, p1))(*)(LevelEditorLayer*, GameObject*, int);
	static auto func = wrapFunction(base::get() + 0x2d61c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelEditorLayer::updateObjectSection(GameObject* p0) -> decltype(updateObjectSection(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GameObject*>::func(&LevelEditorLayer::updateObjectSection), this);
	using FunctionType = decltype(updateObjectSection(p0))(*)(LevelEditorLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x2d6f90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelEditorLayer::updateDisabledObjectsLastPos(cocos2d::CCArray* p0) -> decltype(updateDisabledObjectsLastPos(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*>::func(&LevelEditorLayer::updateDisabledObjectsLastPos), this);
	using FunctionType = decltype(updateDisabledObjectsLastPos(p0))(*)(LevelEditorLayer*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x2d7240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelEditorLayer::timeForPos(cocos2d::CCPoint p0, int p1, int p2, bool p3, int p4) -> decltype(timeForPos(p0, p1, p2, p3, p4)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint, int, int, bool, int>::func(&LevelEditorLayer::timeForPos), this);
	using FunctionType = decltype(timeForPos(p0, p1, p2, p3, p4))(*)(LevelEditorLayer*, cocos2d::CCPoint, int, int, bool, int);
	static auto func = wrapFunction(base::get() + 0x2d5f10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3, p4);
}

auto LevelEditorLayer::posForTime(float p0) -> decltype(posForTime(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&LevelEditorLayer::posForTime), this);
	using FunctionType = decltype(posForTime(p0))(*)(LevelEditorLayer*, float);
	static auto func = wrapFunction(base::get() + 0x2d5f80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelEditorLayer::resetSPTriggered() -> decltype(resetSPTriggered()) {
	throw std::runtime_error("LevelEditorLayer::resetSPTriggered not implemented");
}

auto LevelEditorLayer::didRotateGameplay() -> decltype(didRotateGameplay()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelEditorLayer::didRotateGameplay), this);
	using FunctionType = decltype(didRotateGameplay())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x2d6f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelEditorLayer::manualUpdateObjectColors(GameObject* p0) -> decltype(manualUpdateObjectColors(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GameObject*>::func(&LevelEditorLayer::manualUpdateObjectColors), this);
	using FunctionType = decltype(manualUpdateObjectColors(p0))(*)(LevelEditorLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x2d1700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelEditorLayer::claimCustomParticle(gd::string const& p0, cocos2d::ParticleStruct const& p1, int p2, int p3, int p4, bool p5) -> decltype(claimCustomParticle(p0, p1, p2, p3, p4, p5)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string const&, cocos2d::ParticleStruct const&, int, int, int, bool>::func(&LevelEditorLayer::claimCustomParticle), this);
	using FunctionType = decltype(claimCustomParticle(p0, p1, p2, p3, p4, p5))(*)(LevelEditorLayer*, gd::string const&, cocos2d::ParticleStruct const&, int, int, int, bool);
	static auto func = wrapFunction(base::get() + 0x2d9060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3, p4, p5);
}

auto LevelEditorLayer::unclaimCustomParticle(gd::string const& p0, cocos2d::CCParticleSystemQuad* p1) -> decltype(unclaimCustomParticle(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string const&, cocos2d::CCParticleSystemQuad*>::func(&LevelEditorLayer::unclaimCustomParticle), this);
	using FunctionType = decltype(unclaimCustomParticle(p0, p1))(*)(LevelEditorLayer*, gd::string const&, cocos2d::CCParticleSystemQuad*);
	static auto func = wrapFunction(base::get() + 0x2d9120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelEditorLayer::activatedAudioTrigger(SFXTriggerGameObject* p0) -> decltype(activatedAudioTrigger(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SFXTriggerGameObject*>::func(&LevelEditorLayer::activatedAudioTrigger), this);
	using FunctionType = decltype(activatedAudioTrigger(p0))(*)(LevelEditorLayer*, SFXTriggerGameObject*);
	static auto func = wrapFunction(base::get() + 0x2d87c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelEditorLayer::checkpointActivated(CheckpointGameObject* p0) -> decltype(checkpointActivated(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CheckpointGameObject*>::func(&LevelEditorLayer::checkpointActivated), this);
	using FunctionType = decltype(checkpointActivated(p0))(*)(LevelEditorLayer*, CheckpointGameObject*);
	static auto func = wrapFunction(base::get() + 0x2d87f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelEditorLayer::addKeyframe(KeyframeGameObject* p0) -> decltype(addKeyframe(p0)) {
	auto self = addresser::thunkAdjust(Resolve<KeyframeGameObject*>::func(&LevelEditorLayer::addKeyframe), this);
	using FunctionType = decltype(addKeyframe(p0))(*)(LevelEditorLayer*, KeyframeGameObject*);
	static auto func = wrapFunction(base::get() + 0x2d9160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelEditorLayer::levelSettingsUpdated() -> decltype(levelSettingsUpdated()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelEditorLayer::levelSettingsUpdated), this);
	using FunctionType = decltype(levelSettingsUpdated())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x2cb030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelEditorLayer::addSpecial(GameObject* p0) -> decltype(addSpecial(p0)) {
	using FunctionType = decltype(addSpecial(p0))(*)(LevelEditorLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x2cf4a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelEditorLayer::createObject(int p0, cocos2d::CCPoint p1, bool p2) -> decltype(createObject(p0, p1, p2)) {
	using FunctionType = decltype(createObject(p0, p1, p2))(*)(LevelEditorLayer*, int, cocos2d::CCPoint, bool);
	static auto func = wrapFunction(base::get() + 0x2cbf90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto LevelEditorLayer::createObjectsFromString(gd::string const& p0, bool p1, bool p2) -> decltype(createObjectsFromString(p0, p1, p2)) {
	using FunctionType = decltype(createObjectsFromString(p0, p1, p2))(*)(LevelEditorLayer*, gd::string const&, bool, bool);
	static auto func = wrapFunction(base::get() + 0x2cb920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto LevelEditorLayer::getLevelString() -> decltype(getLevelString()) {
	using FunctionType = decltype(getLevelString())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x2ce530, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::getNextFreeAreaEffectID(cocos2d::CCArray* p0) -> decltype(getNextFreeAreaEffectID(p0)) {
	using FunctionType = decltype(getNextFreeAreaEffectID(p0))(*)(LevelEditorLayer*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x2d26d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelEditorLayer::getNextFreeGradientID(cocos2d::CCArray* p0) -> decltype(getNextFreeGradientID(p0)) {
	using FunctionType = decltype(getNextFreeGradientID(p0))(*)(LevelEditorLayer*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x2d27b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelEditorLayer::getNextFreeGroupID(cocos2d::CCArray* p0) -> decltype(getNextFreeGroupID(p0)) {
	using FunctionType = decltype(getNextFreeGroupID(p0))(*)(LevelEditorLayer*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x2d2030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelEditorLayer::getNextFreeItemID(cocos2d::CCArray* p0) -> decltype(getNextFreeItemID(p0)) {
	using FunctionType = decltype(getNextFreeItemID(p0))(*)(LevelEditorLayer*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x2d22b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelEditorLayer::getObjectRect(GameObject* p0, bool p1, bool p2) -> decltype(getObjectRect(p0, p1, p2)) {
	using FunctionType = decltype(getObjectRect(p0, p1, p2))(*)(LevelEditorLayer*, GameObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x2cd0f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto LevelEditorLayer::handleAction(bool p0, cocos2d::CCArray* p1) -> decltype(handleAction(p0, p1)) {
	using FunctionType = decltype(handleAction(p0, p1))(*)(LevelEditorLayer*, bool, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x2cde30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto LevelEditorLayer::init(GJGameLevel* p0, bool p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(LevelEditorLayer*, GJGameLevel*, bool);
	static auto func = wrapFunction(base::get() + 0x2c96e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

bool LevelEditorLayer::isLayerLocked(int layer) {
        if (layer < 10000 && m_layerLockingEnabled) {
            return m_lockedLayers.at(layer);
        }
        return false;
    }

auto LevelEditorLayer::objectAtPosition(cocos2d::CCPoint p0) -> decltype(objectAtPosition(p0)) {
	using FunctionType = decltype(objectAtPosition(p0))(*)(LevelEditorLayer*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x2cc940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelEditorLayer::onPlaytest() -> decltype(onPlaytest()) {
	using FunctionType = decltype(onPlaytest())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x2d7330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::onResumePlaytest() -> decltype(onResumePlaytest()) {
	using FunctionType = decltype(onResumePlaytest())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x2d7d60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::onStopPlaytest() -> decltype(onStopPlaytest()) {
	using FunctionType = decltype(onStopPlaytest())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x2d7f50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::quickUpdateAllPositions() -> decltype(quickUpdateAllPositions()) {
	using FunctionType = decltype(quickUpdateAllPositions())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x2d70c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void LevelEditorLayer::redoLastAction() {
        return this->handleAction(false, m_redoObjects);
    }

auto LevelEditorLayer::removeAllObjectsOfType(int p0) -> decltype(removeAllObjectsOfType(p0)) {
	using FunctionType = decltype(removeAllObjectsOfType(p0))(*)(LevelEditorLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2cdbb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelEditorLayer::removeSpecial(GameObject* p0) -> decltype(removeSpecial(p0)) {
	using FunctionType = decltype(removeSpecial(p0))(*)(LevelEditorLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x2cfbb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelEditorLayer::tryUpdateSpeedObject(EffectGameObject* p0, bool p1) -> decltype(tryUpdateSpeedObject(p0, p1)) {
	using FunctionType = decltype(tryUpdateSpeedObject(p0, p1))(*)(LevelEditorLayer*, EffectGameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x2d0190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto LevelEditorLayer::typeExistsAtPosition(int p0, cocos2d::CCPoint p1, bool p2, bool p3, float p4) -> decltype(typeExistsAtPosition(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(typeExistsAtPosition(p0, p1, p2, p3, p4))(*)(LevelEditorLayer*, int, cocos2d::CCPoint, bool, bool, float);
	static auto func = wrapFunction(base::get() + 0x2cc340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

void LevelEditorLayer::undoLastAction() {
        return this->handleAction(true, m_undoObjects);
    }

auto LevelEditorLayer::updateEditor(float p0) -> decltype(updateEditor(p0)) {
	using FunctionType = decltype(updateEditor(p0))(*)(LevelEditorLayer*, float);
	static auto func = wrapFunction(base::get() + 0x2d0330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelEditorLayer::updateEditorMode() -> decltype(updateEditorMode()) {
	using FunctionType = decltype(updateEditorMode())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x2d2e10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::updateKeyframeObjects() -> decltype(updateKeyframeObjects()) {
	using FunctionType = decltype(updateKeyframeObjects())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x2d9490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::updateLevelFont(int p0) -> decltype(updateLevelFont(p0)) {
	using FunctionType = decltype(updateLevelFont(p0))(*)(LevelEditorLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2d66d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelEditorLayer::updateObjectColors(cocos2d::CCArray* gameObjects) -> decltype(updateObjectColors(gameObjects)) {
	using FunctionType = decltype(updateObjectColors(gameObjects))(*)(LevelEditorLayer*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x2d1790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, gameObjects);
}

auto LevelEditorLayer::updateOptions() -> decltype(updateOptions()) {
	using FunctionType = decltype(updateOptions())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x2ca8f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::updatePreviewParticles() -> decltype(updatePreviewParticles()) {
	using FunctionType = decltype(updatePreviewParticles())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x2d8ec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelFeatureLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("LevelFeatureLayer::keyBackClicked not implemented");
}

void LevelUpdateDelegate::levelUpdateFinished(GJGameLevel* p0, UpdateResponse p1) {}

void LevelUpdateDelegate::levelUpdateFailed(int p0) {}

void RateLevelDelegate::rateLevelClosed() {}

void NumberInputDelegate::numberInputClosed(NumberInputLayer* p0) {}

auto LevelInfoLayer::create(GJGameLevel* level, bool challenge) -> decltype(create(level, challenge)) {
	using FunctionType = decltype(create(level, challenge))(*)(GJGameLevel*, bool);
	static auto func = wrapFunction(base::get() + 0x2e2860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(level, challenge);
}

auto LevelInfoLayer::scene(GJGameLevel* level, bool challenge) -> decltype(scene(level, challenge)) {
	using FunctionType = decltype(scene(level, challenge))(*)(GJGameLevel*, bool);
	static auto func = wrapFunction(base::get() + 0x2e2810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(level, challenge);
}

auto LevelInfoLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelInfoLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x2ebdd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelInfoLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&LevelInfoLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(LevelInfoLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x2ebde0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelInfoLayer::numberInputClosed(NumberInputLayer* p0) -> decltype(numberInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<NumberInputLayer*>::func(&LevelInfoLayer::numberInputClosed), this);
	using FunctionType = decltype(numberInputClosed(p0))(*)(LevelInfoLayer*, NumberInputLayer*);
	static auto func = wrapFunction(base::get() + 0x2e8e30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelInfoLayer::cellPerformedAction(TableViewCell* p0, int p1, CellAction p2, cocos2d::CCNode* p3) -> decltype(cellPerformedAction(p0, p1, p2, p3)) {
	throw std::runtime_error("LevelInfoLayer::cellPerformedAction not implemented");
}

auto LevelInfoLayer::levelDownloadFinished(GJGameLevel* p0) -> decltype(levelDownloadFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJGameLevel*>::func(&LevelInfoLayer::levelDownloadFinished), this);
	using FunctionType = decltype(levelDownloadFinished(p0))(*)(LevelInfoLayer*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x2e7210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelInfoLayer::levelDownloadFailed(int p0) -> decltype(levelDownloadFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&LevelInfoLayer::levelDownloadFailed), this);
	using FunctionType = decltype(levelDownloadFailed(p0))(*)(LevelInfoLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2e7570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelInfoLayer::levelUpdateFinished(GJGameLevel* p0, UpdateResponse p1) -> decltype(levelUpdateFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<GJGameLevel*, UpdateResponse>::func(&LevelInfoLayer::levelUpdateFinished), this);
	using FunctionType = decltype(levelUpdateFinished(p0, p1))(*)(LevelInfoLayer*, GJGameLevel*, UpdateResponse);
	static auto func = wrapFunction(base::get() + 0x2e76a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelInfoLayer::levelUpdateFailed(int p0) -> decltype(levelUpdateFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&LevelInfoLayer::levelUpdateFailed), this);
	using FunctionType = decltype(levelUpdateFailed(p0))(*)(LevelInfoLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2e7800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelInfoLayer::levelDeleteFinished(int p0) -> decltype(levelDeleteFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&LevelInfoLayer::levelDeleteFinished), this);
	using FunctionType = decltype(levelDeleteFinished(p0))(*)(LevelInfoLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2e7930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelInfoLayer::levelDeleteFailed(int p0) -> decltype(levelDeleteFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&LevelInfoLayer::levelDeleteFailed), this);
	using FunctionType = decltype(levelDeleteFailed(p0))(*)(LevelInfoLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2e7a70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelInfoLayer::rateLevelClosed() -> decltype(rateLevelClosed()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelInfoLayer::rateLevelClosed), this);
	using FunctionType = decltype(rateLevelClosed())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x2e9cd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelInfoLayer::likedItem(LikeItemType p0, int p1, bool p2) -> decltype(likedItem(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<LikeItemType, int, bool>::func(&LevelInfoLayer::likedItem), this);
	using FunctionType = decltype(likedItem(p0, p1, p2))(*)(LevelInfoLayer*, LikeItemType, int, bool);
	static auto func = wrapFunction(base::get() + 0x2e9f50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto LevelInfoLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&LevelInfoLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(LevelInfoLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x2eb810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelInfoLayer::setIDPopupClosed(SetIDPopup* p0, int p1) -> decltype(setIDPopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<SetIDPopup*, int>::func(&LevelInfoLayer::setIDPopupClosed), this);
	using FunctionType = decltype(setIDPopupClosed(p0, p1))(*)(LevelInfoLayer*, SetIDPopup*, int);
	static auto func = wrapFunction(base::get() + 0x2e53a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelInfoLayer::onEnterTransitionDidFinish() -> decltype(onEnterTransitionDidFinish()) {
	throw std::runtime_error("LevelInfoLayer::onEnterTransitionDidFinish not implemented");
}

auto LevelInfoLayer::confirmClone(cocos2d::CCObject* p0) -> decltype(confirmClone(p0)) {
	using FunctionType = decltype(confirmClone(p0))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2e9000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelInfoLayer::confirmDelete(cocos2d::CCObject* p0) -> decltype(confirmDelete(p0)) {
	using FunctionType = decltype(confirmDelete(p0))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2e9170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelInfoLayer::confirmMoveToBottom(cocos2d::CCObject* p0) -> decltype(confirmMoveToBottom(p0)) {
	using FunctionType = decltype(confirmMoveToBottom(p0))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2ea8a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelInfoLayer::confirmMoveToTop(cocos2d::CCObject* p0) -> decltype(confirmMoveToTop(p0)) {
	using FunctionType = decltype(confirmMoveToTop(p0))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2ea760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelInfoLayer::downloadLevel() -> decltype(downloadLevel()) {
	using FunctionType = decltype(downloadLevel())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x2e5770, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelInfoLayer::init(GJGameLevel* level, bool challenge) -> decltype(init(level, challenge)) {
	using FunctionType = decltype(init(level, challenge))(*)(LevelInfoLayer*, GJGameLevel*, bool);
	static auto func = wrapFunction(base::get() + 0x2e2a90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, level, challenge);
}

auto LevelInfoLayer::loadLevelStep() -> decltype(loadLevelStep()) {
	using FunctionType = decltype(loadLevelStep())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x2e8a00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelInfoLayer::onAddToList(cocos2d::CCObject* sender) -> decltype(onAddToList(sender)) {
	using FunctionType = decltype(onAddToList(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2e5160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	using FunctionType = decltype(onBack(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2ebce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onFavorite(cocos2d::CCObject* sender) -> decltype(onFavorite(sender)) {
	using FunctionType = decltype(onFavorite(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2e5430, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onGarage(cocos2d::CCObject* sender) -> decltype(onGarage(sender)) {
	using FunctionType = decltype(onGarage(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2e55b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onInfo(cocos2d::CCObject* sender) -> decltype(onInfo(sender)) {
	using FunctionType = decltype(onInfo(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2e8b60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onLevelInfo(cocos2d::CCObject* sender) -> decltype(onLevelInfo(sender)) {
	using FunctionType = decltype(onLevelInfo(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2ea510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onLevelLeaderboard(cocos2d::CCObject* sender) -> decltype(onLevelLeaderboard(sender)) {
	using FunctionType = decltype(onLevelLeaderboard(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2e54d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onLevelOptions(cocos2d::CCObject* sender) -> decltype(onLevelOptions(sender)) {
	using FunctionType = decltype(onLevelOptions(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2ea3c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onLike(cocos2d::CCObject* sender) -> decltype(onLike(sender)) {
	using FunctionType = decltype(onLike(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2e9e60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onPlay(cocos2d::CCObject* sender) -> decltype(onPlay(sender)) {
	using FunctionType = decltype(onPlay(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2e7bd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onRate(cocos2d::CCObject* sender) -> decltype(onRate(sender)) {
	using FunctionType = decltype(onRate(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2e96e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onRateDemon(cocos2d::CCObject* sender) -> decltype(onRateDemon(sender)) {
	using FunctionType = decltype(onRateDemon(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2e9ce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onRateStars(cocos2d::CCObject* sender) -> decltype(onRateStars(sender)) {
	using FunctionType = decltype(onRateStars(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2e99c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onRateStarsMod(cocos2d::CCObject* sender) -> decltype(onRateStarsMod(sender)) {
	using FunctionType = decltype(onRateStarsMod(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2e9c80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onSetFolder(cocos2d::CCObject* sender) -> decltype(onSetFolder(sender)) {
	using FunctionType = decltype(onSetFolder(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2e5300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onUpdate(cocos2d::CCObject* sender) -> decltype(onUpdate(sender)) {
	using FunctionType = decltype(onUpdate(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2ea280, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onViewProfile(cocos2d::CCObject* sender) -> decltype(onViewProfile(sender)) {
	using FunctionType = decltype(onViewProfile(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2ea460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::playStep4() -> decltype(playStep4()) {
	using FunctionType = decltype(playStep4())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x2e8ab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelInfoLayer::setupLevelInfo() -> decltype(setupLevelInfo()) {
	using FunctionType = decltype(setupLevelInfo())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x2e65c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelInfoLayer::setupPlatformerStats() -> decltype(setupPlatformerStats()) {
	using FunctionType = decltype(setupPlatformerStats())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x2e5a80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelInfoLayer::setupProgressBars() -> decltype(setupProgressBars()) {
	using FunctionType = decltype(setupProgressBars())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x2e5eb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelInfoLayer::showUpdateAlert(UpdateResponse p0) -> decltype(showUpdateAlert(p0)) {
	using FunctionType = decltype(showUpdateAlert(p0))(*)(LevelInfoLayer*, UpdateResponse);
	static auto func = wrapFunction(base::get() + 0x2e7710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelInfoLayer::tryCloneLevel(cocos2d::CCObject* p0) -> decltype(tryCloneLevel(p0)) {
	using FunctionType = decltype(tryCloneLevel(p0))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2e8ba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelInfoLayer::updateLabelValues() -> decltype(updateLabelValues()) {
	using FunctionType = decltype(updateLabelValues())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x2ea9d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelInfoLayer::updateSideButtons() -> decltype(updateSideButtons()) {
	using FunctionType = decltype(updateSideButtons())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x2e9fc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelLeaderboard::create(GJGameLevel* p0, LevelLeaderboardType p1, LevelLeaderboardMode p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(GJGameLevel*, LevelLeaderboardType, LevelLeaderboardMode);
	static auto func = wrapFunction(base::get() + 0x2ebf80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto LevelLeaderboard::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("LevelLeaderboard::registerWithTouchDispatcher not implemented");
}

auto LevelLeaderboard::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("LevelLeaderboard::keyBackClicked not implemented");
}

auto LevelLeaderboard::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelLeaderboard::show), this);
	using FunctionType = decltype(show())(*)(LevelLeaderboard*);
	static auto func = wrapFunction(base::get() + 0x867a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelLeaderboard::loadLeaderboardFinished(cocos2d::CCArray* p0, char const* p1) -> decltype(loadLeaderboardFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*, char const*>::func(&LevelLeaderboard::loadLeaderboardFinished), this);
	using FunctionType = decltype(loadLeaderboardFinished(p0, p1))(*)(LevelLeaderboard*, cocos2d::CCArray*, char const*);
	static auto func = wrapFunction(base::get() + 0x2ee140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelLeaderboard::loadLeaderboardFailed(char const* p0) -> decltype(loadLeaderboardFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&LevelLeaderboard::loadLeaderboardFailed), this);
	using FunctionType = decltype(loadLeaderboardFailed(p0))(*)(LevelLeaderboard*, char const*);
	static auto func = wrapFunction(base::get() + 0x2ee1e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelLeaderboard::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&LevelLeaderboard::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(LevelLeaderboard*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x2ed570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelLeaderboard::updateUserScoreFinished() -> decltype(updateUserScoreFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelLeaderboard::updateUserScoreFinished), this);
	using FunctionType = decltype(updateUserScoreFinished())(*)(LevelLeaderboard*);
	static auto func = wrapFunction(base::get() + 0x2edb90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelLeaderboard::updateUserScoreFailed() -> decltype(updateUserScoreFailed()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelLeaderboard::updateUserScoreFailed), this);
	using FunctionType = decltype(updateUserScoreFailed())(*)(LevelLeaderboard*);
	static auto func = wrapFunction(base::get() + 0x2edba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelLeaderboard::init(GJGameLevel* p0, LevelLeaderboardType p1, LevelLeaderboardMode p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(LevelLeaderboard*, GJGameLevel*, LevelLeaderboardType, LevelLeaderboardMode);
	static auto func = wrapFunction(base::get() + 0x2ec0c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto LevelLeaderboard::onChangeMode(cocos2d::CCObject* sender) -> decltype(onChangeMode(sender)) {
	using FunctionType = decltype(onChangeMode(sender))(*)(LevelLeaderboard*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2edd40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelLeaderboard::onChangeType(cocos2d::CCObject* sender) -> decltype(onChangeType(sender)) {
	using FunctionType = decltype(onChangeType(sender))(*)(LevelLeaderboard*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2edca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelLeaderboard::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(LevelLeaderboard*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x84620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelLeaderboard::onUpdate(cocos2d::CCObject* sender) -> decltype(onUpdate(sender)) {
	using FunctionType = decltype(onUpdate(sender))(*)(LevelLeaderboard*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2eddc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelListCell::init() -> decltype(init()) {
	throw std::runtime_error("LevelListCell::init not implemented");
}

auto LevelListCell::draw() -> decltype(draw()) {
	throw std::runtime_error("LevelListCell::draw not implemented");
}

auto LevelListCell::loadFromList(GJLevelList* p0) -> decltype(loadFromList(p0)) {
	using FunctionType = decltype(loadFromList(p0))(*)(LevelListCell*, GJLevelList*);
	static auto func = wrapFunction(base::get() + 0xbdf90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelListCell::onClick(cocos2d::CCObject* sender) -> decltype(onClick(sender)) {
	using FunctionType = decltype(onClick(sender))(*)(LevelListCell*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xbf3c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

void LevelListDeleteDelegate::levelListDeleteFinished(int p0) {}

void LevelListDeleteDelegate::levelListDeleteFailed(int p0) {}

void SelectListIconDelegate::iconSelectClosed(SelectListIconLayer* p0) {}

LevelListLayer::LevelListLayer() {
        m_buttonMenu = nullptr;
        m_searchKey1 = "";
        m_levelList = nullptr;
        m_searchKey2 = "";
        m_likeButton = nullptr;
        m_exiting = false;
        m_titleInput = nullptr;
        m_editMode = 0;
        m_objects = nullptr;
        m_diffSprite = nullptr;
        m_featureSprite = nullptr;
        m_rewardPosition = cocos2d::CCPointMake(0.f, 0.f);
        m_exited = false;
    }

LevelListLayer* LevelListLayer::create(GJLevelList* list) {
        auto ret = new LevelListLayer();
        if (ret->init(list)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto LevelListLayer::scene(GJLevelList* p0) -> decltype(scene(p0)) {
	using FunctionType = decltype(scene(p0))(*)(GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x2ee9c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelListLayer::onEnter() -> decltype(onEnter()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelListLayer::onEnter), this);
	using FunctionType = decltype(onEnter())(*)(LevelListLayer*);
	static auto func = wrapFunction(base::get() + 0x2f0680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelListLayer::onExit() -> decltype(onExit()) {
	throw std::runtime_error("LevelListLayer::onExit not implemented");
}

auto LevelListLayer::loadLevelsFinished(cocos2d::CCArray* p0, char const* p1, int p2) -> decltype(loadLevelsFinished(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*, char const*, int>::func(&LevelListLayer::loadLevelsFinished), this);
	using FunctionType = decltype(loadLevelsFinished(p0, p1, p2))(*)(LevelListLayer*, cocos2d::CCArray*, char const*, int);
	static auto func = wrapFunction(base::get() + 0x2f1e80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto LevelListLayer::loadLevelsFailed(char const* p0, int p1) -> decltype(loadLevelsFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<char const*, int>::func(&LevelListLayer::loadLevelsFailed), this);
	using FunctionType = decltype(loadLevelsFailed(p0, p1))(*)(LevelListLayer*, char const*, int);
	static auto func = wrapFunction(base::get() + 0x2c4370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelListLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&LevelListLayer::onBack), this);
	using FunctionType = decltype(onBack(sender))(*)(LevelListLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f26e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto LevelListLayer::shareCommentClosed(gd::string p0, ShareCommentLayer* p1) -> decltype(shareCommentClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string, ShareCommentLayer*>::func(&LevelListLayer::shareCommentClosed), this);
	using FunctionType = decltype(shareCommentClosed(p0, p1))(*)(LevelListLayer*, gd::string, ShareCommentLayer*);
	static auto func = wrapFunction(base::get() + 0x2f2ee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelListLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&LevelListLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(LevelListLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x2f2b00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelListLayer::setIDPopupClosed(SetIDPopup* p0, int p1) -> decltype(setIDPopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<SetIDPopup*, int>::func(&LevelListLayer::setIDPopupClosed), this);
	using FunctionType = decltype(setIDPopupClosed(p0, p1))(*)(LevelListLayer*, SetIDPopup*, int);
	static auto func = wrapFunction(base::get() + 0x2f2630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelListLayer::updateResultArray(cocos2d::CCArray* p0) -> decltype(updateResultArray(p0)) {
	throw std::runtime_error("LevelListLayer::updateResultArray not implemented");
}

auto LevelListLayer::cellPerformedAction(TableViewCell* p0, int p1, CellAction p2, cocos2d::CCNode* p3) -> decltype(cellPerformedAction(p0, p1, p2, p3)) {
	auto self = addresser::thunkAdjust(Resolve<TableViewCell*, int, CellAction, cocos2d::CCNode*>::func(&LevelListLayer::cellPerformedAction), this);
	using FunctionType = decltype(cellPerformedAction(p0, p1, p2, p3))(*)(LevelListLayer*, TableViewCell*, int, CellAction, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x2f21e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3);
}

auto LevelListLayer::likedItem(LikeItemType p0, int p1, bool p2) -> decltype(likedItem(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<LikeItemType, int, bool>::func(&LevelListLayer::likedItem), this);
	using FunctionType = decltype(likedItem(p0, p1, p2))(*)(LevelListLayer*, LikeItemType, int, bool);
	static auto func = wrapFunction(base::get() + 0x2f3100, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto LevelListLayer::iconSelectClosed(SelectListIconLayer* p0) -> decltype(iconSelectClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SelectListIconLayer*>::func(&LevelListLayer::iconSelectClosed), this);
	using FunctionType = decltype(iconSelectClosed(p0))(*)(LevelListLayer*, SelectListIconLayer*);
	static auto func = wrapFunction(base::get() + 0x2f33b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelListLayer::levelListDeleteFinished(int p0) -> decltype(levelListDeleteFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&LevelListLayer::levelListDeleteFinished), this);
	using FunctionType = decltype(levelListDeleteFinished(p0))(*)(LevelListLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2f3cd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelListLayer::levelListDeleteFailed(int p0) -> decltype(levelListDeleteFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&LevelListLayer::levelListDeleteFailed), this);
	using FunctionType = decltype(levelListDeleteFailed(p0))(*)(LevelListLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2f3e00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelListLayer::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&LevelListLayer::textInputOpened), this);
	using FunctionType = decltype(textInputOpened(p0))(*)(LevelListLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x2f41c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelListLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&LevelListLayer::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(LevelListLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x2f3f30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelListLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&LevelListLayer::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(LevelListLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x2f4320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelListLayer::cloneList() -> decltype(cloneList()) {
	using FunctionType = decltype(cloneList())(*)(LevelListLayer*);
	static auto func = wrapFunction(base::get() + 0x2f3790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelListLayer::confirmClone(cocos2d::CCObject* p0) -> decltype(confirmClone(p0)) {
	using FunctionType = decltype(confirmClone(p0))(*)(LevelListLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f36a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelListLayer::confirmDelete(cocos2d::CCObject* p0) -> decltype(confirmDelete(p0)) {
	using FunctionType = decltype(confirmDelete(p0))(*)(LevelListLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f3a20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelListLayer::confirmOwnerDelete(cocos2d::CCObject* p0) -> decltype(confirmOwnerDelete(p0)) {
	using FunctionType = decltype(confirmOwnerDelete(p0))(*)(LevelListLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f3b50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelListLayer::init(GJLevelList* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(LevelListLayer*, GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x2eebf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelListLayer::onClaimReward(cocos2d::CCObject* sender) -> decltype(onClaimReward(sender)) {
	using FunctionType = decltype(onClaimReward(sender))(*)(LevelListLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f1650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelListLayer::onFavorite(cocos2d::CCObject* sender) -> decltype(onFavorite(sender)) {
	using FunctionType = decltype(onFavorite(sender))(*)(LevelListLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f2ce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelListLayer::onInfo(cocos2d::CCObject* sender) -> decltype(onInfo(sender)) {
	using FunctionType = decltype(onInfo(sender))(*)(LevelListLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f2fe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelListLayer::onLike(cocos2d::CCObject* sender) -> decltype(onLike(sender)) {
	using FunctionType = decltype(onLike(sender))(*)(LevelListLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f3020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelListLayer::onRefreshLevelList(cocos2d::CCObject* sender) -> decltype(onRefreshLevelList(sender)) {
	using FunctionType = decltype(onRefreshLevelList(sender))(*)(LevelListLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f1cc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelListLayer::onSelectIcon(cocos2d::CCObject* sender) -> decltype(onSelectIcon(sender)) {
	using FunctionType = decltype(onSelectIcon(sender))(*)(LevelListLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f3260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelListLayer::onShare(cocos2d::CCObject* sender) -> decltype(onShare(sender)) {
	using FunctionType = decltype(onShare(sender))(*)(LevelListLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f33d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelListLayer::onToggleEditMode(cocos2d::CCObject* sender) -> decltype(onToggleEditMode(sender)) {
	using FunctionType = decltype(onToggleEditMode(sender))(*)(LevelListLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f3660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelListLayer::onViewProfile(cocos2d::CCObject* sender) -> decltype(onViewProfile(sender)) {
	using FunctionType = decltype(onViewProfile(sender))(*)(LevelListLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f2ca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelListLayer::updateSideButtons() -> decltype(updateSideButtons()) {
	using FunctionType = decltype(updateSideButtons())(*)(LevelListLayer*);
	static auto func = wrapFunction(base::get() + 0x2f3160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelListLayer::updateStatsArt() -> decltype(updateStatsArt()) {
	using FunctionType = decltype(updateStatsArt())(*)(LevelListLayer*);
	static auto func = wrapFunction(base::get() + 0x2f06d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelOptionsLayer::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&LevelOptionsLayer::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(LevelOptionsLayer*, int, float);
	static auto func = wrapFunction(base::get() + 0x30fb80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelOptionsLayer::getValue(int p0) -> decltype(getValue(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&LevelOptionsLayer::getValue), this);
	using FunctionType = decltype(getValue(p0))(*)(LevelOptionsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x30fba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelOptionsLayer::setupOptions() -> decltype(setupOptions()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelOptionsLayer::setupOptions), this);
	using FunctionType = decltype(setupOptions())(*)(LevelOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x30f4e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelOptionsLayer::didToggle(int p0) -> decltype(didToggle(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&LevelOptionsLayer::didToggle), this);
	using FunctionType = decltype(didToggle(p0))(*)(LevelOptionsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x30fbc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelOptionsLayer::init(LevelSettingsObject* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(LevelOptionsLayer*, LevelSettingsObject*);
	static auto func = wrapFunction(base::get() + 0x30f470, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelOptionsLayer::onSettings(cocos2d::CCObject* sender) -> decltype(onSettings(sender)) {
	using FunctionType = decltype(onSettings(sender))(*)(LevelOptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x30f9a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelOptionsLayer2::setupOptions() -> decltype(setupOptions()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelOptionsLayer2::setupOptions), this);
	using FunctionType = decltype(setupOptions())(*)(LevelOptionsLayer2*);
	static auto func = wrapFunction(base::get() + 0x30fe20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

LevelPage::LevelPage() {}

LevelPage* LevelPage::create(GJGameLevel* level) {
        auto ret = new LevelPage();
        if (ret->init(level)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto LevelPage::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&LevelPage::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(LevelPage*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x309700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void LevelPage::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

void LevelPage::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

auto LevelPage::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	throw std::runtime_error("LevelPage::ccTouchCancelled not implemented");
}

auto LevelPage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelPage::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(LevelPage*);
	static auto func = wrapFunction(base::get() + 0x9b1a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelPage::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DialogLayer*>::func(&LevelPage::dialogClosed), this);
	using FunctionType = decltype(dialogClosed(p0))(*)(LevelPage*, DialogLayer*);
	static auto func = wrapFunction(base::get() + 0x308c10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelPage::addSecretCoin() -> decltype(addSecretCoin()) {
	using FunctionType = decltype(addSecretCoin())(*)(LevelPage*);
	static auto func = wrapFunction(base::get() + 0x307810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelPage::addSecretDoor() -> decltype(addSecretDoor()) {
	using FunctionType = decltype(addSecretDoor())(*)(LevelPage*);
	static auto func = wrapFunction(base::get() + 0x307f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelPage::init(GJGameLevel* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(LevelPage*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x305070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelPage::onInfo(cocos2d::CCObject* sender) -> decltype(onInfo(sender)) {
	using FunctionType = decltype(onInfo(sender))(*)(LevelPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x309260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelPage::onPlay(cocos2d::CCObject* sender) -> decltype(onPlay(sender)) {
	using FunctionType = decltype(onPlay(sender))(*)(LevelPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x308cf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelPage::onSecretDoor(cocos2d::CCObject* sender) -> decltype(onSecretDoor(sender)) {
	using FunctionType = decltype(onSecretDoor(sender))(*)(LevelPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x308130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelPage::onTheTower(cocos2d::CCObject* sender) -> decltype(onTheTower(sender)) {
	using FunctionType = decltype(onTheTower(sender))(*)(LevelPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x307150, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelPage::playCoinEffect() -> decltype(playCoinEffect()) {
	using FunctionType = decltype(playCoinEffect())(*)(LevelPage*);
	static auto func = wrapFunction(base::get() + 0x307a50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelPage::playStep3() -> decltype(playStep3()) {
	using FunctionType = decltype(playStep3())(*)(LevelPage*);
	static auto func = wrapFunction(base::get() + 0x309160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelPage::updateDynamicPage(GJGameLevel* p0) -> decltype(updateDynamicPage(p0)) {
	using FunctionType = decltype(updateDynamicPage(p0))(*)(LevelPage*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x305d00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelSearchLayer::scene(int p0) -> decltype(scene(p0)) {
	using FunctionType = decltype(scene(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x2f75f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelSearchLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelSearchLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(LevelSearchLayer*);
	static auto func = wrapFunction(base::get() + 0x2fdcc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelSearchLayer::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&LevelSearchLayer::textInputOpened), this);
	using FunctionType = decltype(textInputOpened(p0))(*)(LevelSearchLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x2fad00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelSearchLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&LevelSearchLayer::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(LevelSearchLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x2fae50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelSearchLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("LevelSearchLayer::textChanged not implemented");
}

auto LevelSearchLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&LevelSearchLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(LevelSearchLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x2facc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelSearchLayer::demonFilterSelectClosed(int p0) -> decltype(demonFilterSelectClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&LevelSearchLayer::demonFilterSelectClosed), this);
	using FunctionType = decltype(demonFilterSelectClosed(p0))(*)(LevelSearchLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2f97f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelSearchLayer::clearFilters() -> decltype(clearFilters()) {
	using FunctionType = decltype(clearFilters())(*)(LevelSearchLayer*);
	static auto func = wrapFunction(base::get() + 0x2f9ca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelSearchLayer::getLevelLenKey() -> decltype(getLevelLenKey()) {
	using FunctionType = decltype(getLevelLenKey())(*)(LevelSearchLayer*);
	static auto func = wrapFunction(base::get() + 0x14b660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelSearchLayer::getSearchObject(SearchType p0, gd::string p1) -> decltype(getSearchObject(p0, p1)) {
	using FunctionType = decltype(getSearchObject(p0, p1))(*)(LevelSearchLayer*, SearchType, gd::string);
	static auto func = wrapFunction(base::get() + 0x2fb290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto LevelSearchLayer::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(LevelSearchLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2f7740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelSearchLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	using FunctionType = decltype(onBack(sender))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2fd040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSearchLayer::onClearFreeSearch(cocos2d::CCObject* sender) -> decltype(onClearFreeSearch(sender)) {
	using FunctionType = decltype(onClearFreeSearch(sender))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2fd000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

void LevelSearchLayer::onClose(cocos2d::CCObject* sender) {
        m_searchInput->onClickTrackNode(false);
    }

auto LevelSearchLayer::onFollowed(cocos2d::CCObject* sender) -> decltype(onFollowed(sender)) {
	using FunctionType = decltype(onFollowed(sender))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2fcac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSearchLayer::onFriends(cocos2d::CCObject* sender) -> decltype(onFriends(sender)) {
	using FunctionType = decltype(onFriends(sender))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2fca00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSearchLayer::onLatestStars(cocos2d::CCObject* sender) -> decltype(onLatestStars(sender)) {
	using FunctionType = decltype(onLatestStars(sender))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2fc940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSearchLayer::onMagic(cocos2d::CCObject* sender) -> decltype(onMagic(sender)) {
	using FunctionType = decltype(onMagic(sender))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2fc7c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSearchLayer::onMoreOptions(cocos2d::CCObject* sender) -> decltype(onMoreOptions(sender)) {
	using FunctionType = decltype(onMoreOptions(sender))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f9a80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSearchLayer::onMostDownloaded(cocos2d::CCObject* sender) -> decltype(onMostDownloaded(sender)) {
	using FunctionType = decltype(onMostDownloaded(sender))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2fc4c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSearchLayer::onMostLikes(cocos2d::CCObject* sender) -> decltype(onMostLikes(sender)) {
	using FunctionType = decltype(onMostLikes(sender))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2fc580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSearchLayer::onMostRecent(cocos2d::CCObject* sender) -> decltype(onMostRecent(sender)) {
	using FunctionType = decltype(onMostRecent(sender))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2fc880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSearchLayer::onSearch(cocos2d::CCObject* sender) -> decltype(onSearch(sender)) {
	using FunctionType = decltype(onSearch(sender))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2fcb80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSearchLayer::onSearchMode(cocos2d::CCObject* sender) -> decltype(onSearchMode(sender)) {
	using FunctionType = decltype(onSearchMode(sender))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f9a30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSearchLayer::onSearchUser(cocos2d::CCObject* sender) -> decltype(onSearchUser(sender)) {
	using FunctionType = decltype(onSearchUser(sender))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2fcdc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSearchLayer::onSpecialDemon(cocos2d::CCObject* sender) -> decltype(onSpecialDemon(sender)) {
	using FunctionType = decltype(onSpecialDemon(sender))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f9690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSearchLayer::onSuggested(cocos2d::CCObject* sender) -> decltype(onSuggested(sender)) {
	using FunctionType = decltype(onSuggested(sender))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2fc640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSearchLayer::onTrending(cocos2d::CCObject* sender) -> decltype(onTrending(sender)) {
	using FunctionType = decltype(onTrending(sender))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2fc700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSearchLayer::toggleDifficulty(cocos2d::CCObject* p0) -> decltype(toggleDifficulty(p0)) {
	using FunctionType = decltype(toggleDifficulty(p0))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2fd3c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelSearchLayer::toggleDifficultyNum(int p0, bool p1) -> decltype(toggleDifficultyNum(p0, p1)) {
	using FunctionType = decltype(toggleDifficultyNum(p0, p1))(*)(LevelSearchLayer*, int, bool);
	static auto func = wrapFunction(base::get() + 0x2fd720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto LevelSearchLayer::toggleStar(cocos2d::CCObject* p0) -> decltype(toggleStar(p0)) {
	using FunctionType = decltype(toggleStar(p0))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2fd0b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelSearchLayer::toggleTimeNum(int p0, bool p1) -> decltype(toggleTimeNum(p0, p1)) {
	using FunctionType = decltype(toggleTimeNum(p0, p1))(*)(LevelSearchLayer*, int, bool);
	static auto func = wrapFunction(base::get() + 0x2fdb30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto LevelSearchLayer::updateSearchLabel(char const* p0) -> decltype(updateSearchLabel(p0)) {
	using FunctionType = decltype(updateSearchLabel(p0))(*)(LevelSearchLayer*, char const*);
	static auto func = wrapFunction(base::get() + 0x2faf20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

LevelSelectLayer::LevelSelectLayer() {}

LevelSelectLayer* LevelSelectLayer::create(int page) {
        auto ret = new LevelSelectLayer();
        if (ret->init(page)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto LevelSelectLayer::scene(int p0) -> decltype(scene(p0)) {
	using FunctionType = decltype(scene(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x303710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelSelectLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelSelectLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(LevelSelectLayer*);
	static auto func = wrapFunction(base::get() + 0x304ed0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelSelectLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&LevelSelectLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(LevelSelectLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x304f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelSelectLayer::updatePageWithObject(cocos2d::CCObject* p0, cocos2d::CCObject* p1) -> decltype(updatePageWithObject(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*, cocos2d::CCObject*>::func(&LevelSelectLayer::updatePageWithObject), this);
	using FunctionType = decltype(updatePageWithObject(p0, p1))(*)(LevelSelectLayer*, cocos2d::CCObject*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x304650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelSelectLayer::scrollLayerMoved(cocos2d::CCPoint p0) -> decltype(scrollLayerMoved(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint>::func(&LevelSelectLayer::scrollLayerMoved), this);
	using FunctionType = decltype(scrollLayerMoved(p0))(*)(LevelSelectLayer*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x3046c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelSelectLayer::colorForPage(int page) -> decltype(colorForPage(page)) {
	using FunctionType = decltype(colorForPage(page))(*)(LevelSelectLayer*, int);
	static auto func = wrapFunction(base::get() + 0x3049e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, page);
}

auto LevelSelectLayer::init(int page) -> decltype(init(page)) {
	using FunctionType = decltype(init(page))(*)(LevelSelectLayer*, int);
	static auto func = wrapFunction(base::get() + 0x303840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, page);
}

auto LevelSelectLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	using FunctionType = decltype(onBack(sender))(*)(LevelSelectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x304e80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSelectLayer::onDownload(cocos2d::CCObject* sender) -> decltype(onDownload(sender)) {
	using FunctionType = decltype(onDownload(sender))(*)(LevelSelectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x304600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSelectLayer::onInfo(cocos2d::CCObject* sender) -> decltype(onInfo(sender)) {
	using FunctionType = decltype(onInfo(sender))(*)(LevelSelectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x305000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSelectLayer::onNext(cocos2d::CCObject* sender) -> decltype(onNext(sender)) {
	using FunctionType = decltype(onNext(sender))(*)(LevelSelectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x304d80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSelectLayer::onPrev(cocos2d::CCObject* sender) -> decltype(onPrev(sender)) {
	using FunctionType = decltype(onPrev(sender))(*)(LevelSelectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x304e00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SelectArtDelegate::selectArtClosed(SelectArtLayer* p0) -> decltype(selectArtClosed(p0)) {
	throw std::runtime_error("SelectArtDelegate::selectArtClosed not implemented");
}

auto SelectSettingDelegate::selectSettingClosed(SelectSettingLayer* p0) -> decltype(selectSettingClosed(p0)) {
	throw std::runtime_error("SelectSettingDelegate::selectSettingClosed not implemented");
}

auto LevelSettingsLayer::create(LevelSettingsObject* p0, LevelEditorLayer* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(LevelSettingsObject*, LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x309ca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto LevelSettingsLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelSettingsLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(LevelSettingsLayer*);
	static auto func = wrapFunction(base::get() + 0x30c750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelSettingsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelSettingsLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(LevelSettingsLayer*);
	static auto func = wrapFunction(base::get() + 0x30d5f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelSettingsLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&LevelSettingsLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(LevelSettingsLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0xc3110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelSettingsLayer::colorSelectClosed(cocos2d::CCNode* p0) -> decltype(colorSelectClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*>::func(&LevelSettingsLayer::colorSelectClosed), this);
	using FunctionType = decltype(colorSelectClosed(p0))(*)(LevelSettingsLayer*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x30ce80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelSettingsLayer::selectArtClosed(SelectArtLayer* p0) -> decltype(selectArtClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SelectArtLayer*>::func(&LevelSettingsLayer::selectArtClosed), this);
	using FunctionType = decltype(selectArtClosed(p0))(*)(LevelSettingsLayer*, SelectArtLayer*);
	static auto func = wrapFunction(base::get() + 0x30d2a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelSettingsLayer::selectSettingClosed(SelectSettingLayer* p0) -> decltype(selectSettingClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SelectSettingLayer*>::func(&LevelSettingsLayer::selectSettingClosed), this);
	using FunctionType = decltype(selectSettingClosed(p0))(*)(LevelSettingsLayer*, SelectSettingLayer*);
	static auto func = wrapFunction(base::get() + 0x30c5d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelSettingsLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	throw std::runtime_error("LevelSettingsLayer::textInputClosed not implemented");
}

auto LevelSettingsLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&LevelSettingsLayer::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(LevelSettingsLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x30ca80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelSettingsLayer::createToggleButton(gd::string p0, cocos2d::SEL_MenuHandler p1, bool p2, cocos2d::CCMenu* p3, cocos2d::CCPoint p4) -> decltype(createToggleButton(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(createToggleButton(p0, p1, p2, p3, p4))(*)(LevelSettingsLayer*, gd::string, cocos2d::SEL_MenuHandler, bool, cocos2d::CCMenu*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x30c7d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto LevelSettingsLayer::init(LevelSettingsObject* p0, LevelEditorLayer* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(LevelSettingsLayer*, LevelSettingsObject*, LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x309e90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto LevelSettingsLayer::onBGArt(cocos2d::CCObject* sender) -> decltype(onBGArt(sender)) {
	using FunctionType = decltype(onBGArt(sender))(*)(LevelSettingsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x30d060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSettingsLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(LevelSettingsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x30cc50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSettingsLayer::onFGArt(cocos2d::CCObject* sender) -> decltype(onFGArt(sender)) {
	using FunctionType = decltype(onFGArt(sender))(*)(LevelSettingsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x30d130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSettingsLayer::onGameplayMode(cocos2d::CCObject* sender) -> decltype(onGameplayMode(sender)) {
	using FunctionType = decltype(onGameplayMode(sender))(*)(LevelSettingsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x30c3a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSettingsLayer::onGArt(cocos2d::CCObject* sender) -> decltype(onGArt(sender)) {
	using FunctionType = decltype(onGArt(sender))(*)(LevelSettingsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x30d0b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSettingsLayer::onLiveEdit(cocos2d::CCObject* sender) -> decltype(onLiveEdit(sender)) {
	using FunctionType = decltype(onLiveEdit(sender))(*)(LevelSettingsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x30cd90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSettingsLayer::onMode(cocos2d::CCObject* sender) -> decltype(onMode(sender)) {
	using FunctionType = decltype(onMode(sender))(*)(LevelSettingsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x30c570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSettingsLayer::onOptionToggle(cocos2d::CCObject* sender) -> decltype(onOptionToggle(sender)) {
	using FunctionType = decltype(onOptionToggle(sender))(*)(LevelSettingsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x30ca40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSettingsLayer::onSettings(cocos2d::CCObject* sender) -> decltype(onSettings(sender)) {
	using FunctionType = decltype(onSettings(sender))(*)(LevelSettingsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x30c4b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSettingsLayer::onShowPicker(cocos2d::CCObject* sender) -> decltype(onShowPicker(sender)) {
	using FunctionType = decltype(onShowPicker(sender))(*)(LevelSettingsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x30cde0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSettingsLayer::onSpeed(cocos2d::CCObject* sender) -> decltype(onSpeed(sender)) {
	using FunctionType = decltype(onSpeed(sender))(*)(LevelSettingsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x30c520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSettingsLayer::updateColorSprite(ColorChannelSprite* p0) -> decltype(updateColorSprite(p0)) {
	using FunctionType = decltype(updateColorSprite(p0))(*)(LevelSettingsLayer*, ColorChannelSprite*);
	static auto func = wrapFunction(base::get() + 0x30cf00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelSettingsLayer::updateColorSprites() -> decltype(updateColorSprites()) {
	using FunctionType = decltype(updateColorSprites())(*)(LevelSettingsLayer*);
	static auto func = wrapFunction(base::get() + 0x30ce90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelSettingsLayer::updateGameplayModeButtons() -> decltype(updateGameplayModeButtons()) {
	using FunctionType = decltype(updateGameplayModeButtons())(*)(LevelSettingsLayer*);
	static auto func = wrapFunction(base::get() + 0x30c3e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelSettingsObject::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x2dd1f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto LevelSettingsObject::objectFromDict(cocos2d::CCDictionary* p0) -> decltype(objectFromDict(p0)) {
	using FunctionType = decltype(objectFromDict(p0))(*)(cocos2d::CCDictionary*);
	static auto func = wrapFunction(base::get() + 0x2deff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

LevelSettingsObject* LevelSettingsObject::objectFromString(gd::string const& str) {
        return objectFromDict(GameToolbox::stringSetupToDict(str, ","));
    }

auto LevelSettingsObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelSettingsObject::init), this);
	using FunctionType = decltype(init())(*)(LevelSettingsObject*);
	static auto func = wrapFunction(base::get() + 0x2dd320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelSettingsObject::getSaveString() -> decltype(getSaveString()) {
	using FunctionType = decltype(getSaveString())(*)(LevelSettingsObject*);
	static auto func = wrapFunction(base::get() + 0x2dd630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelSettingsObject::setupColorsFromLegacyMode(cocos2d::CCDictionary* p0) -> decltype(setupColorsFromLegacyMode(p0)) {
	using FunctionType = decltype(setupColorsFromLegacyMode(p0))(*)(LevelSettingsObject*, cocos2d::CCDictionary*);
	static auto func = wrapFunction(base::get() + 0x2e0840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

bool LevelSettingsObject::shouldUseYSection() {
        return m_platformerMode || m_dynamicLevelHeight;
    }

auto LevelTools::artistForAudio(int p0) -> decltype(artistForAudio(p0)) {
	using FunctionType = decltype(artistForAudio(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x314320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelTools::fbURLForArtist(int p0) -> decltype(fbURLForArtist(p0)) {
	using FunctionType = decltype(fbURLForArtist(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x316430, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelTools::getAudioFileName(int p0) -> decltype(getAudioFileName(p0)) {
	using FunctionType = decltype(getAudioFileName(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x313750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelTools::getAudioString(int p0) -> decltype(getAudioString(p0)) {
	using FunctionType = decltype(getAudioString(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x316950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelTools::getAudioTitle(int p0) -> decltype(getAudioTitle(p0)) {
	using FunctionType = decltype(getAudioTitle(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x312bd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelTools::getLevel(int p0, bool p1) -> decltype(getLevel(p0, p1)) {
	using FunctionType = decltype(getLevel(p0, p1))(*)(int, bool);
	static auto func = wrapFunction(base::get() + 0x310320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

SongInfoObject* LevelTools::getSongObject(int id) {
        auto artistID = artistForAudio(id);
        return SongInfoObject::create(id, getAudioTitle(id), nameForArtist(artistID), artistID, 0.f, "", "", "", 0, "", false, 0, -1);
    }

auto LevelTools::nameForArtist(int p0) -> decltype(nameForArtist(p0)) {
	using FunctionType = decltype(nameForArtist(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x3143f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelTools::ngURLForArtist(int p0) -> decltype(ngURLForArtist(p0)) {
	using FunctionType = decltype(ngURLForArtist(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x315a10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelTools::posForTimeInternal(float time, cocos2d::CCArray* gameObjects, int speedmodValue, bool disabledSpeedmod, bool p4, bool p5, int& p6, int p7) -> decltype(posForTimeInternal(time, gameObjects, speedmodValue, disabledSpeedmod, p4, p5, p6, p7)) {
	using FunctionType = decltype(posForTimeInternal(time, gameObjects, speedmodValue, disabledSpeedmod, p4, p5, p6, p7))(*)(float, cocos2d::CCArray*, int, bool, bool, bool, int&, int);
	static auto func = wrapFunction(base::get() + 0x317ea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(time, gameObjects, speedmodValue, disabledSpeedmod, p4, p5, p6, p7);
}

auto LevelTools::urlForAudio(int p0) -> decltype(urlForAudio(p0)) {
	using FunctionType = decltype(urlForAudio(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x3146f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelTools::verifyLevelIntegrity(gd::string p0, int p1) -> decltype(verifyLevelIntegrity(p0, p1)) {
	using FunctionType = decltype(verifyLevelIntegrity(p0, p1))(*)(gd::string, int);
	static auto func = wrapFunction(base::get() + 0x318500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto LevelTools::ytURLForArtist(int p0) -> decltype(ytURLForArtist(p0)) {
	using FunctionType = decltype(ytURLForArtist(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x315eb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

void LevelUploadDelegate::levelUploadFinished(GJGameLevel* p0) {}

void LevelUploadDelegate::levelUploadFailed(GJGameLevel* p0) {}

auto LikeItemLayer::create(LikeItemType p0, int p1, int p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(LikeItemType, int, int);
	static auto func = wrapFunction(base::get() + 0x318ea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto LikeItemLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("LikeItemLayer::keyBackClicked not implemented");
}

auto LikeItemLayer::init(LikeItemType p0, int p1, int p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(LikeItemLayer*, LikeItemType, int, int);
	static auto func = wrapFunction(base::get() + 0x318fa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto LikeItemLayer::onDislike(cocos2d::CCObject* sender) -> decltype(onDislike(sender)) {
	using FunctionType = decltype(onDislike(sender))(*)(LikeItemLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x319380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LikeItemLayer::onLike(cocos2d::CCObject* sender) -> decltype(onLike(sender)) {
	using FunctionType = decltype(onLike(sender))(*)(LikeItemLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x319370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LikeItemLayer::triggerLike(bool isLiked) -> decltype(triggerLike(isLiked)) {
	using FunctionType = decltype(triggerLike(isLiked))(*)(LikeItemLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x319390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, isLiked);
}

auto ListButtonBar::create(cocos2d::CCArray* p0, cocos2d::CCPoint p1, int p2, int p3, float p4, float p5, float p6, float p7, int p8) -> decltype(create(p0, p1, p2, p3, p4, p5, p6, p7, p8)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5, p6, p7, p8))(*)(cocos2d::CCArray*, cocos2d::CCPoint, int, int, float, float, float, float, int);
	static auto func = wrapFunction(base::get() + 0x6ad70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5, p6, p7, p8);
}

auto ListButtonBar::goToPage(int p0) -> decltype(goToPage(p0)) {
	using FunctionType = decltype(goToPage(p0))(*)(ListButtonBar*, int);
	static auto func = wrapFunction(base::get() + 0x6b380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ListButtonBar::init(cocos2d::CCArray* p0, cocos2d::CCPoint p1, int p2, int p3, float p4, float p5, float p6, float p7, int p8) -> decltype(init(p0, p1, p2, p3, p4, p5, p6, p7, p8)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5, p6, p7, p8))(*)(ListButtonBar*, cocos2d::CCArray*, cocos2d::CCPoint, int, int, float, float, float, float, int);
	static auto func = wrapFunction(base::get() + 0x6ae80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7, p8);
}

auto ListButtonBar::onLeft(cocos2d::CCObject* sender) -> decltype(onLeft(sender)) {
	using FunctionType = decltype(onLeft(sender))(*)(ListButtonBar*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x6b430, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ListButtonBar::onRight(cocos2d::CCObject* sender) -> decltype(onRight(sender)) {
	using FunctionType = decltype(onRight(sender))(*)(ListButtonBar*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x6b410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ListButtonPage::create(cocos2d::CCArray* p0, cocos2d::CCPoint p1, int p2, int p3, float p4, float p5, float p6) -> decltype(create(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5, p6))(*)(cocos2d::CCArray*, cocos2d::CCPoint, int, int, float, float, float);
	static auto func = wrapFunction(base::get() + 0x6b450, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5, p6);
}

auto ListCell::init() -> decltype(init()) {
	throw std::runtime_error("ListCell::init not implemented");
}

auto ListCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ListCell::draw), this);
	using FunctionType = decltype(draw())(*)(ListCell*);
	static auto func = wrapFunction(base::get() + 0x3c6f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ListUploadDelegate::listUploadFinished(GJLevelList* p0) -> decltype(listUploadFinished(p0)) {
	throw std::runtime_error("ListUploadDelegate::listUploadFinished not implemented");
}

auto ListUploadDelegate::listUploadFailed(GJLevelList* p0, int p1) -> decltype(listUploadFailed(p0, p1)) {
	throw std::runtime_error("ListUploadDelegate::listUploadFailed not implemented");
}

LoadingCircle::LoadingCircle() {}

auto LoadingCircle::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x6b840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto LoadingCircle::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LoadingCircle::init), this);
	using FunctionType = decltype(init())(*)(LoadingCircle*);
	static auto func = wrapFunction(base::get() + 0x6b940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LoadingCircle::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LoadingCircle::draw), this);
	using FunctionType = decltype(draw())(*)(LoadingCircle*);
	static auto func = wrapFunction(base::get() + 0x6bbc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

bool LoadingCircle::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) { return true; }

void LoadingCircle::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

void LoadingCircle::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

void LoadingCircle::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

auto LoadingCircle::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LoadingCircle::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(LoadingCircle*);
	static auto func = wrapFunction(base::get() + 0x6bbe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LoadingCircle::fadeAndRemove() -> decltype(fadeAndRemove()) {
	using FunctionType = decltype(fadeAndRemove())(*)(LoadingCircle*);
	static auto func = wrapFunction(base::get() + 0x6bb20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void LoadingCircle::setFade(bool fade) {
        m_fade = fade;
    }

auto LoadingCircle::show() -> decltype(show()) {
	using FunctionType = decltype(show())(*)(LoadingCircle*);
	static auto func = wrapFunction(base::get() + 0x6ba20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LoadingCircleSprite::create(float spinSpeed) -> decltype(create(spinSpeed)) {
	using FunctionType = decltype(create(spinSpeed))(*)(float);
	static auto func = wrapFunction(base::get() + 0x6bc30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(spinSpeed);
}

auto LoadingCircleSprite::fadeInCircle(bool p0, float p1, float p2) -> decltype(fadeInCircle(p0, p1, p2)) {
	using FunctionType = decltype(fadeInCircle(p0, p1, p2))(*)(LoadingCircleSprite*, bool, float, float);
	static auto func = wrapFunction(base::get() + 0x6bd30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

void LoadingCircleSprite::hideCircle() {
        this->stopActionByTag(0);
        this->setOpacity(0);
        this->setVisible(false);
    }

auto LoadingLayer::scene(bool p0) -> decltype(scene(p0)) {
	using FunctionType = decltype(scene(p0))(*)(bool);
	static auto func = wrapFunction(base::get() + 0x3194f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LoadingLayer::getLoadingString() -> decltype(getLoadingString()) {
	using FunctionType = decltype(getLoadingString())(*)(LoadingLayer*);
	static auto func = wrapFunction(base::get() + 0x31a930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LoadingLayer::init(bool p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(LoadingLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x319600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LoadingLayer::loadAssets() -> decltype(loadAssets()) {
	using FunctionType = decltype(loadAssets())(*)(LoadingLayer*);
	static auto func = wrapFunction(base::get() + 0x319ea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void LoadingLayer::loadingFinished() {
        cocos2d::CCDirector::sharedDirector()->replaceScene(MenuLayer::scene(m_fromRefresh));
    }

auto LoadingLayer::updateProgress(int p0) -> decltype(updateProgress(p0)) {
	using FunctionType = decltype(updateProgress(p0))(*)(LoadingLayer*, int);
	static auto func = wrapFunction(base::get() + 0x319e20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LocalLevelManager::sharedState() -> decltype(sharedState()) {
	using FunctionType = decltype(sharedState())(*)();
	static auto func = wrapFunction(base::get() + 0x31b070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto LocalLevelManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LocalLevelManager::init), this);
	using FunctionType = decltype(init())(*)(LocalLevelManager*);
	static auto func = wrapFunction(base::get() + 0x31b110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LocalLevelManager::encodeDataTo(DS_Dictionary* p0) -> decltype(encodeDataTo(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&LocalLevelManager::encodeDataTo), this);
	using FunctionType = decltype(encodeDataTo(p0))(*)(LocalLevelManager*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x31bae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LocalLevelManager::dataLoaded(DS_Dictionary* p0) -> decltype(dataLoaded(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&LocalLevelManager::dataLoaded), this);
	using FunctionType = decltype(dataLoaded(p0))(*)(LocalLevelManager*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x31bb40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LocalLevelManager::firstLoad() -> decltype(firstLoad()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LocalLevelManager::firstLoad), this);
	using FunctionType = decltype(firstLoad())(*)(LocalLevelManager*);
	static auto func = wrapFunction(base::get() + 0x31ba50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LocalLevelManager::getAllLevelsInDict() -> decltype(getAllLevelsInDict()) {
	using FunctionType = decltype(getAllLevelsInDict())(*)(LocalLevelManager*);
	static auto func = wrapFunction(base::get() + 0x31b4e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

cocos2d::CCArray* LocalLevelManager::getCreatedLevels(int folder) {
        if (folder < 1) return m_localLevels;
        auto ret = cocos2d::CCArray::create();
        CCObject* obj;
        CCARRAY_FOREACH(m_localLevels, obj) {
            if (!obj) return ret;
            if (static_cast<GJGameLevel*>(obj)->m_levelFolder == folder) ret->addObject(obj);
        }
        return ret;
    }

cocos2d::CCArray* LocalLevelManager::getCreatedLists(int folder) {
        if (folder < 1) return m_localLists;
        auto ret = cocos2d::CCArray::create();
        CCObject* obj;
        CCARRAY_FOREACH(m_localLists, obj) {
            if (!obj) return ret;
            if (static_cast<GJLevelList*>(obj)->m_folder == folder) ret->addObject(obj);
        }
        return ret;
    }

auto LocalLevelManager::getMainLevelString(int p0) -> decltype(getMainLevelString(p0)) {
	using FunctionType = decltype(getMainLevelString(p0))(*)(LocalLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x31b3d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LocalLevelManager::updateLevelOrder() -> decltype(updateLevelOrder()) {
	using FunctionType = decltype(updateLevelOrder())(*)(LocalLevelManager*);
	static auto func = wrapFunction(base::get() + 0x31b9d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LocalLevelManager::updateLevelRevision() -> decltype(updateLevelRevision()) {
	using FunctionType = decltype(updateLevelRevision())(*)(LocalLevelManager*);
	static auto func = wrapFunction(base::get() + 0x31b640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto MapPackCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MapPackCell::init), this);
	using FunctionType = decltype(init())(*)(MapPackCell*);
	static auto func = wrapFunction(base::get() + 0xb1480, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MapPackCell::draw() -> decltype(draw()) {
	throw std::runtime_error("MapPackCell::draw not implemented");
}

auto MapPackCell::loadFromMapPack(GJMapPack* p0) -> decltype(loadFromMapPack(p0)) {
	using FunctionType = decltype(loadFromMapPack(p0))(*)(MapPackCell*, GJMapPack*);
	static auto func = wrapFunction(base::get() + 0xb14e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MapPackCell::onClick(cocos2d::CCObject* sender) -> decltype(onClick(sender)) {
	using FunctionType = decltype(onClick(sender))(*)(MapPackCell*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xb2000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MapPackCell::playCompleteEffect() -> decltype(playCompleteEffect()) {
	using FunctionType = decltype(playCompleteEffect())(*)(MapPackCell*);
	static auto func = wrapFunction(base::get() + 0xb21d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void MapPackCell::reloadCell() {
        this->loadFromMapPack(m_mapPack);
    }

void MapPackCell::updateBGColor(int idx) {
        m_backgroundLayer->setColor(idx % 2 == 0 ? cocos2d::ccColor3B { 161, 88, 44 } : cocos2d::ccColor3B { 194, 114, 62 });
        m_backgroundLayer->setOpacity(255);
    }

auto MapSelectLayer::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("MapSelectLayer::update not implemented");
}

auto MapSelectLayer::init() -> decltype(init()) {
	throw std::runtime_error("MapSelectLayer::init not implemented");
}

auto MapSelectLayer::onExit() -> decltype(onExit()) {
	throw std::runtime_error("MapSelectLayer::onExit not implemented");
}

auto MapSelectLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	throw std::runtime_error("MapSelectLayer::ccTouchBegan not implemented");
}

auto MapSelectLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	throw std::runtime_error("MapSelectLayer::ccTouchMoved not implemented");
}

auto MapSelectLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	throw std::runtime_error("MapSelectLayer::ccTouchEnded not implemented");
}

auto MapSelectLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	throw std::runtime_error("MapSelectLayer::ccTouchCancelled not implemented");
}

auto MapSelectLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("MapSelectLayer::registerWithTouchDispatcher not implemented");
}

auto MapSelectLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("MapSelectLayer::keyBackClicked not implemented");
}

auto MapSelectLayer::scrollWheel(float p0, float p1) -> decltype(scrollWheel(p0, p1)) {
	throw std::runtime_error("MapSelectLayer::scrollWheel not implemented");
}

MenuGameLayer::MenuGameLayer() {}

MenuGameLayer* MenuGameLayer::create() {
        auto ret = new MenuGameLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto MenuGameLayer::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&MenuGameLayer::update), this);
	using FunctionType = decltype(update(p0))(*)(MenuGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0x31d380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MenuGameLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MenuGameLayer::init), this);
	using FunctionType = decltype(init())(*)(MenuGameLayer*);
	static auto func = wrapFunction(base::get() + 0x31c560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MenuGameLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&MenuGameLayer::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(MenuGameLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x31e740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void MenuGameLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

void MenuGameLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

auto MenuGameLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	throw std::runtime_error("MenuGameLayer::ccTouchCancelled not implemented");
}

auto MenuGameLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MenuGameLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(MenuGameLayer*);
	static auto func = wrapFunction(base::get() + 0x31e8f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MenuGameLayer::destroyPlayer() -> decltype(destroyPlayer()) {
	using FunctionType = decltype(destroyPlayer())(*)(MenuGameLayer*);
	static auto func = wrapFunction(base::get() + 0x31e480, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto MenuGameLayer::getBGColor(int p0) -> decltype(getBGColor(p0)) {
	using FunctionType = decltype(getBGColor(p0))(*)(MenuGameLayer*, int);
	static auto func = wrapFunction(base::get() + 0x31cde0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MenuGameLayer::resetPlayer() -> decltype(resetPlayer()) {
	using FunctionType = decltype(resetPlayer())(*)(MenuGameLayer*);
	static auto func = wrapFunction(base::get() + 0x31d850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto MenuGameLayer::tryJump(float p0) -> decltype(tryJump(p0)) {
	using FunctionType = decltype(tryJump(p0))(*)(MenuGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0x31d0b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MenuGameLayer::updateColor(float p0) -> decltype(updateColor(p0)) {
	using FunctionType = decltype(updateColor(p0))(*)(MenuGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0x31cc90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

MenuLayer* MenuLayer::get() {
        return GameManager::get()->m_menuLayer;
    }

auto MenuLayer::scene(bool isVideoOptionsOpen) -> decltype(scene(isVideoOptionsOpen)) {
	using FunctionType = decltype(scene(isVideoOptionsOpen))(*)(bool);
	static auto func = wrapFunction(base::get() + 0x31ea40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(isVideoOptionsOpen);
}

auto MenuLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MenuLayer::init), this);
	using FunctionType = decltype(init())(*)(MenuLayer*);
	static auto func = wrapFunction(base::get() + 0x31ebd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MenuLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MenuLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(MenuLayer*);
	static auto func = wrapFunction(base::get() + 0x3210c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MenuLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&MenuLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(MenuLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x3214a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MenuLayer::googlePlaySignedIn() -> decltype(googlePlaySignedIn()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MenuLayer::googlePlaySignedIn), this);
	using FunctionType = decltype(googlePlaySignedIn())(*)(MenuLayer*);
	static auto func = wrapFunction(base::get() + 0x320ac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MenuLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&MenuLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(MenuLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x321290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MenuLayer::endGame() -> decltype(endGame()) {
	using FunctionType = decltype(endGame())(*)(MenuLayer*);
	static auto func = wrapFunction(base::get() + 0x321510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto MenuLayer::firstNetworkTest() -> decltype(firstNetworkTest()) {
	using FunctionType = decltype(firstNetworkTest())(*)(MenuLayer*);
	static auto func = wrapFunction(base::get() + 0x320430, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto MenuLayer::onAchievements(cocos2d::CCObject* sender) -> decltype(onAchievements(sender)) {
	using FunctionType = decltype(onAchievements(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x320960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onCreator(cocos2d::CCObject* sender) -> decltype(onCreator(sender)) {
	using FunctionType = decltype(onCreator(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x320e70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onDaily(cocos2d::CCObject* sender) -> decltype(onDaily(sender)) {
	using FunctionType = decltype(onDaily(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3201e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

void MenuLayer::onEveryplay(cocos2d::CCObject* sender) {}

auto MenuLayer::onGarage(cocos2d::CCObject* sender) -> decltype(onGarage(sender)) {
	using FunctionType = decltype(onGarage(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x320f00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onMoreGames(cocos2d::CCObject* sender) -> decltype(onMoreGames(sender)) {
	using FunctionType = decltype(onMoreGames(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x320880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onMyProfile(cocos2d::CCObject* sender) -> decltype(onMyProfile(sender)) {
	using FunctionType = decltype(onMyProfile(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x320720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onOptions(cocos2d::CCObject* sender) -> decltype(onOptions(sender)) {
	using FunctionType = decltype(onOptions(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x320bb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onOptionsInstant() -> decltype(onOptionsInstant()) {
	using FunctionType = decltype(onOptionsInstant())(*)(MenuLayer*);
	static auto func = wrapFunction(base::get() + 0x320bc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto MenuLayer::onPlay(cocos2d::CCObject* sender) -> decltype(onPlay(sender)) {
	using FunctionType = decltype(onPlay(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x320b10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onQuit(cocos2d::CCObject* sender) -> decltype(onQuit(sender)) {
	using FunctionType = decltype(onQuit(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3210d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onRobTop(cocos2d::CCObject* sender) -> decltype(onRobTop(sender)) {
	using FunctionType = decltype(onRobTop(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3207c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onStats(cocos2d::CCObject* sender) -> decltype(onStats(sender)) {
	using FunctionType = decltype(onStats(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x320d50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::openOptions(bool videoOptions) -> decltype(openOptions(videoOptions)) {
	using FunctionType = decltype(openOptions(videoOptions))(*)(MenuLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x320bd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, videoOptions);
}

void MenuLayer::showMeltdownPromo() {}

auto MenuLayer::showTOS() -> decltype(showTOS()) {
	using FunctionType = decltype(showTOS())(*)(MenuLayer*);
	static auto func = wrapFunction(base::get() + 0x320600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto MenuLayer::updateUserProfileButton() -> decltype(updateUserProfileButton()) {
	using FunctionType = decltype(updateUserProfileButton())(*)(MenuLayer*);
	static auto func = wrapFunction(base::get() + 0x320330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void MenuLayer::videoOptionsClosed() {
        m_menuGameLayer->m_videoOptionsOpen = false;
    }

void MenuLayer::videoOptionsOpened() {
        m_menuGameLayer->m_videoOptionsOpen = true;
    }

auto MenuLayer::willClose() -> decltype(willClose()) {
	using FunctionType = decltype(willClose())(*)(MenuLayer*);
	static auto func = wrapFunction(base::get() + 0x3211f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void MessageListDelegate::loadMessagesFinished(cocos2d::CCArray* p0, char const* p1) {}

void MessageListDelegate::loadMessagesFailed(char const* p0, GJErrorCode p1) {}

void MessageListDelegate::forceReloadMessages(bool p0) {}

void MessageListDelegate::setupPageInfo(gd::string p0, char const* p1) {}

auto MessagesProfilePage::create(bool p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(bool);
	static auto func = wrapFunction(base::get() + 0x3216b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto MessagesProfilePage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("MessagesProfilePage::registerWithTouchDispatcher not implemented");
}

auto MessagesProfilePage::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MessagesProfilePage::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(MessagesProfilePage*);
	static auto func = wrapFunction(base::get() + 0x322cb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MessagesProfilePage::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&MessagesProfilePage::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(MessagesProfilePage*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x322a50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MessagesProfilePage::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&MessagesProfilePage::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(MessagesProfilePage*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x13d2a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MessagesProfilePage::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&MessagesProfilePage::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(p0, p1))(*)(MessagesProfilePage*, int, int);
	static auto func = wrapFunction(base::get() + 0x322a80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MessagesProfilePage::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&MessagesProfilePage::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(p0, p1))(*)(MessagesProfilePage*, int, int);
	static auto func = wrapFunction(base::get() + 0x13d460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MessagesProfilePage::loadMessagesFinished(cocos2d::CCArray* p0, char const* p1) -> decltype(loadMessagesFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*, char const*>::func(&MessagesProfilePage::loadMessagesFinished), this);
	using FunctionType = decltype(loadMessagesFinished(p0, p1))(*)(MessagesProfilePage*, cocos2d::CCArray*, char const*);
	static auto func = wrapFunction(base::get() + 0x323300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MessagesProfilePage::loadMessagesFailed(char const* p0, GJErrorCode p1) -> decltype(loadMessagesFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<char const*, GJErrorCode>::func(&MessagesProfilePage::loadMessagesFailed), this);
	using FunctionType = decltype(loadMessagesFailed(p0, p1))(*)(MessagesProfilePage*, char const*, GJErrorCode);
	static auto func = wrapFunction(base::get() + 0x13dc50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MessagesProfilePage::forceReloadMessages(bool p0) -> decltype(forceReloadMessages(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&MessagesProfilePage::forceReloadMessages), this);
	using FunctionType = decltype(forceReloadMessages(p0))(*)(MessagesProfilePage*, bool);
	static auto func = wrapFunction(base::get() + 0x323450, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MessagesProfilePage::setupPageInfo(gd::string p0, char const* p1) -> decltype(setupPageInfo(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string, char const*>::func(&MessagesProfilePage::setupPageInfo), this);
	using FunctionType = decltype(setupPageInfo(p0, p1))(*)(MessagesProfilePage*, gd::string, char const*);
	static auto func = wrapFunction(base::get() + 0x323470, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MessagesProfilePage::deleteSelected() -> decltype(deleteSelected()) {
	using FunctionType = decltype(deleteSelected())(*)(MessagesProfilePage*);
	static auto func = wrapFunction(base::get() + 0x3227d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto MessagesProfilePage::init(bool p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(MessagesProfilePage*, bool);
	static auto func = wrapFunction(base::get() + 0x321850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MessagesProfilePage::loadPage(int p0) -> decltype(loadPage(p0)) {
	using FunctionType = decltype(loadPage(p0))(*)(MessagesProfilePage*, int);
	static auto func = wrapFunction(base::get() + 0x322d60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MessagesProfilePage::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(MessagesProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x322bf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MessagesProfilePage::onDeleteSelected(cocos2d::CCObject* sender) -> decltype(onDeleteSelected(sender)) {
	using FunctionType = decltype(onDeleteSelected(sender))(*)(MessagesProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3224e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MessagesProfilePage::onNextPage(cocos2d::CCObject* sender) -> decltype(onNextPage(sender)) {
	using FunctionType = decltype(onNextPage(sender))(*)(MessagesProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x323610, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MessagesProfilePage::onPrevPage(cocos2d::CCObject* sender) -> decltype(onPrevPage(sender)) {
	using FunctionType = decltype(onPrevPage(sender))(*)(MessagesProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x323620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MessagesProfilePage::onSentMessages(cocos2d::CCObject* sender) -> decltype(onSentMessages(sender)) {
	using FunctionType = decltype(onSentMessages(sender))(*)(MessagesProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x322450, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MessagesProfilePage::onToggleAllObjects(cocos2d::CCObject* sender) -> decltype(onToggleAllObjects(sender)) {
	using FunctionType = decltype(onToggleAllObjects(sender))(*)(MessagesProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x322270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MessagesProfilePage::setupCommentsBrowser(cocos2d::CCArray* p0) -> decltype(setupCommentsBrowser(p0)) {
	using FunctionType = decltype(setupCommentsBrowser(p0))(*)(MessagesProfilePage*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x323170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MessagesProfilePage::untoggleAll() -> decltype(untoggleAll()) {
	using FunctionType = decltype(untoggleAll())(*)(MessagesProfilePage*);
	static auto func = wrapFunction(base::get() + 0x322cc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

MoreOptionsLayer::MoreOptionsLayer() {}

MoreOptionsLayer* MoreOptionsLayer::create() {
        auto ret = new MoreOptionsLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto MoreOptionsLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MoreOptionsLayer::init), this);
	using FunctionType = decltype(init())(*)(MoreOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x35da20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MoreOptionsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MoreOptionsLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(MoreOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x360c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MoreOptionsLayer::textInputShouldOffset(CCTextInputNode* p0, float p1) -> decltype(textInputShouldOffset(p0, p1)) {
	throw std::runtime_error("MoreOptionsLayer::textInputShouldOffset not implemented");
}

auto MoreOptionsLayer::textInputReturn(CCTextInputNode* p0) -> decltype(textInputReturn(p0)) {
	throw std::runtime_error("MoreOptionsLayer::textInputReturn not implemented");
}

auto MoreOptionsLayer::googlePlaySignedIn() -> decltype(googlePlaySignedIn()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MoreOptionsLayer::googlePlaySignedIn), this);
	using FunctionType = decltype(googlePlaySignedIn())(*)(MoreOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x360ca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MoreOptionsLayer::dropDownLayerWillClose(GJDropDownLayer* p0) -> decltype(dropDownLayerWillClose(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJDropDownLayer*>::func(&MoreOptionsLayer::dropDownLayerWillClose), this);
	using FunctionType = decltype(dropDownLayerWillClose(p0))(*)(MoreOptionsLayer*, GJDropDownLayer*);
	static auto func = wrapFunction(base::get() + 0x3607f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MoreOptionsLayer::addToggle(char const* p0, char const* p1, char const* p2) -> decltype(addToggle(p0, p1, p2)) {
	using FunctionType = decltype(addToggle(p0, p1, p2))(*)(MoreOptionsLayer*, char const*, char const*, char const*);
	static auto func = wrapFunction(base::get() + 0x35ee10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto MoreOptionsLayer::goToPage(int p0) -> decltype(goToPage(p0)) {
	using FunctionType = decltype(goToPage(p0))(*)(MoreOptionsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x35f890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MoreOptionsLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(MoreOptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x360b30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MoreOptionsLayer::onFMODDebug(cocos2d::CCObject* sender) -> decltype(onFMODDebug(sender)) {
	using FunctionType = decltype(onFMODDebug(sender))(*)(MoreOptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3606a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MoreOptionsLayer::onKeybindings(cocos2d::CCObject* sender) -> decltype(onKeybindings(sender)) {
	using FunctionType = decltype(onKeybindings(sender))(*)(MoreOptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xdba40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MoreOptionsLayer::onSongBrowser(cocos2d::CCObject* sender) -> decltype(onSongBrowser(sender)) {
	using FunctionType = decltype(onSongBrowser(sender))(*)(MoreOptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x360630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MoreOptionsLayer::onToggle(cocos2d::CCObject* sender) -> decltype(onToggle(sender)) {
	using FunctionType = decltype(onToggle(sender))(*)(MoreOptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x35fe30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

MoreSearchLayer* MoreSearchLayer::create() {
        auto ret = new MoreSearchLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto MoreSearchLayer::audioNext(cocos2d::CCObject* sender) -> decltype(audioNext(sender)) {
	using FunctionType = decltype(audioNext(sender))(*)(MoreSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x301c60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MoreSearchLayer::audioPrevious(cocos2d::CCObject* sender) -> decltype(audioPrevious(sender)) {
	using FunctionType = decltype(audioPrevious(sender))(*)(MoreSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x301d80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MoreSearchLayer::createToggleButton(gd::string p0, cocos2d::SEL_MenuHandler p1, bool p2, cocos2d::CCMenu* p3, cocos2d::CCPoint p4) -> decltype(createToggleButton(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(createToggleButton(p0, p1, p2, p3, p4))(*)(MoreSearchLayer*, gd::string, cocos2d::SEL_MenuHandler, bool, cocos2d::CCMenu*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x302730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto MoreSearchLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(MoreSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x302990, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MoreSearchLayer::onInfo(cocos2d::CCObject* sender) -> decltype(onInfo(sender)) {
	using FunctionType = decltype(onInfo(sender))(*)(MoreSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3025e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MoreSearchLayer::onSongFilter(cocos2d::CCObject* sender) -> decltype(onSongFilter(sender)) {
	using FunctionType = decltype(onSongFilter(sender))(*)(MoreSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3012c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MoreSearchLayer::onSongMode(cocos2d::CCObject* sender) -> decltype(onSongMode(sender)) {
	using FunctionType = decltype(onSongMode(sender))(*)(MoreSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x301fe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MoreSearchLayer::selectSong(int songID) -> decltype(selectSong(songID)) {
	using FunctionType = decltype(selectSong(songID))(*)(MoreSearchLayer*, int);
	static auto func = wrapFunction(base::get() + 0x301ea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, songID);
}

auto MoreSearchLayer::toggleSongNodes(bool p0, bool p1) -> decltype(toggleSongNodes(p0, p1)) {
	using FunctionType = decltype(toggleSongNodes(p0, p1))(*)(MoreSearchLayer*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x3024a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto MoreSearchLayer::updateAudioLabel() -> decltype(updateAudioLabel()) {
	using FunctionType = decltype(updateAudioLabel())(*)(MoreSearchLayer*);
	static auto func = wrapFunction(base::get() + 0x3019a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto MoreSearchLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MoreSearchLayer::init), this);
	using FunctionType = decltype(init())(*)(MoreSearchLayer*);
	static auto func = wrapFunction(base::get() + 0x2fe020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MoreSearchLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MoreSearchLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(MoreSearchLayer*);
	static auto func = wrapFunction(base::get() + 0x302d90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MoreSearchLayer::textInputShouldOffset(CCTextInputNode* p0, float p1) -> decltype(textInputShouldOffset(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*, float>::func(&MoreSearchLayer::textInputShouldOffset), this);
	using FunctionType = decltype(textInputShouldOffset(p0, p1))(*)(MoreSearchLayer*, CCTextInputNode*, float);
	static auto func = wrapFunction(base::get() + 0x7b5c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MoreSearchLayer::textInputReturn(CCTextInputNode* p0) -> decltype(textInputReturn(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&MoreSearchLayer::textInputReturn), this);
	using FunctionType = decltype(textInputReturn(p0))(*)(MoreSearchLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x7b620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

MoreVideoOptionsLayer::MoreVideoOptionsLayer() {
        m_page = 0;
        m_toggleCount = 0;
        m_pageCount = 0;
        m_fpsInput = nullptr;
        m_fpsNodes = nullptr;
    }

MoreVideoOptionsLayer* MoreVideoOptionsLayer::create() {
        auto ret = new MoreVideoOptionsLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto MoreVideoOptionsLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MoreVideoOptionsLayer::init), this);
	using FunctionType = decltype(init())(*)(MoreVideoOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x362eb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MoreVideoOptionsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MoreVideoOptionsLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(MoreVideoOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x3657d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MoreVideoOptionsLayer::addToggle(char const* label, char const* key, char const* description) -> decltype(addToggle(label, key, description)) {
	using FunctionType = decltype(addToggle(label, key, description))(*)(MoreVideoOptionsLayer*, char const*, char const*, char const*);
	static auto func = wrapFunction(base::get() + 0x3639b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, label, key, description);
}

auto MoreVideoOptionsLayer::countForPage(int p0) -> decltype(countForPage(p0)) {
	using FunctionType = decltype(countForPage(p0))(*)(MoreVideoOptionsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x364010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MoreVideoOptionsLayer::goToPage(int p0) -> decltype(goToPage(p0)) {
	using FunctionType = decltype(goToPage(p0))(*)(MoreVideoOptionsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x364430, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MoreVideoOptionsLayer::layerForPage(int p0) -> decltype(layerForPage(p0)) {
	using FunctionType = decltype(layerForPage(p0))(*)(MoreVideoOptionsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x364270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MoreVideoOptionsLayer::objectsForPage(int p0) -> decltype(objectsForPage(p0)) {
	using FunctionType = decltype(objectsForPage(p0))(*)(MoreVideoOptionsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x3640e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MoreVideoOptionsLayer::onApplyFPS(cocos2d::CCObject* sender) -> decltype(onApplyFPS(sender)) {
	using FunctionType = decltype(onApplyFPS(sender))(*)(MoreVideoOptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3652b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MoreVideoOptionsLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(MoreVideoOptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x365780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MoreVideoOptionsLayer::onInfo(cocos2d::CCObject* sender) -> decltype(onInfo(sender)) {
	using FunctionType = decltype(onInfo(sender))(*)(MoreVideoOptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3655a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MoreVideoOptionsLayer::onNextPage(cocos2d::CCObject* sender) -> decltype(onNextPage(sender)) {
	using FunctionType = decltype(onNextPage(sender))(*)(MoreVideoOptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x364410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MoreVideoOptionsLayer::onPrevPage(cocos2d::CCObject* sender) -> decltype(onPrevPage(sender)) {
	using FunctionType = decltype(onPrevPage(sender))(*)(MoreVideoOptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x364420, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MoreVideoOptionsLayer::onToggle(cocos2d::CCObject* sender) -> decltype(onToggle(sender)) {
	using FunctionType = decltype(onToggle(sender))(*)(MoreVideoOptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x364840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MoreVideoOptionsLayer::updateFPSButtons() -> decltype(updateFPSButtons()) {
	using FunctionType = decltype(updateFPSButtons())(*)(MoreVideoOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x3651e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto MPLobbyLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("MPLobbyLayer::keyBackClicked not implemented");
}

auto MPLobbyLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	throw std::runtime_error("MPLobbyLayer::keyDown not implemented");
}

auto MPLobbyLayer::joinLobbyFinished(int p0) -> decltype(joinLobbyFinished(p0)) {
	throw std::runtime_error("MPLobbyLayer::joinLobbyFinished not implemented");
}

auto MPLobbyLayer::joinLobbyFailed(int p0, GJMPErrorCode p1) -> decltype(joinLobbyFailed(p0, p1)) {
	throw std::runtime_error("MPLobbyLayer::joinLobbyFailed not implemented");
}

auto MPLobbyLayer::updateComments() -> decltype(updateComments()) {
	throw std::runtime_error("MPLobbyLayer::updateComments not implemented");
}

auto MPLobbyLayer::didUploadMPComment(int p0) -> decltype(didUploadMPComment(p0)) {
	throw std::runtime_error("MPLobbyLayer::didUploadMPComment not implemented");
}

auto MPLobbyLayer::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	throw std::runtime_error("MPLobbyLayer::textInputOpened not implemented");
}

auto MPLobbyLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	throw std::runtime_error("MPLobbyLayer::textInputClosed not implemented");
}

auto MPLobbyLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("MPLobbyLayer::textChanged not implemented");
}

auto MPLobbyLayer::keyUp(cocos2d::enumKeyCodes p0) -> decltype(keyUp(p0)) {
	throw std::runtime_error("MPLobbyLayer::keyUp not implemented");
}

auto MPLobbyLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	throw std::runtime_error("MPLobbyLayer::FLAlert_Clicked not implemented");
}

auto MPLobbyLayer::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	throw std::runtime_error("MPLobbyLayer::uploadActionFinished not implemented");
}

auto MPLobbyLayer::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	throw std::runtime_error("MPLobbyLayer::uploadActionFailed not implemented");
}

auto MPLobbyLayer::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	throw std::runtime_error("MPLobbyLayer::onClosePopup not implemented");
}

MultilineBitmapFont::MultilineBitmapFont() {
        m_specialDescriptors = nullptr;
        m_characters = nullptr;
        m_lines = nullptr;
        m_unkInt = 0;
        m_unkBool = false;
        m_unkPtr = nullptr;
        m_height = 0;
        m_width = 0;
        m_position = cocos2d::CCPointMake(0.f, 0.f);
        m_maxWidth = 0.f;
        m_disableColor = false;
    }

MultilineBitmapFont* MultilineBitmapFont::createWithFont(char const* p0, gd::string p1, float p2, float p3, cocos2d::CCPoint p4, int p5, bool p6) {
        auto ret = new MultilineBitmapFont();
        if (ret->initWithFont(p0, p1, p2, p3, p4, p5, p6)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto MultilineBitmapFont::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&MultilineBitmapFont::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(MultilineBitmapFont*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x6c750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MultilineBitmapFont::initWithFont(char const* p0, gd::string p1, float p2, float p3, cocos2d::CCPoint p4, int p5, bool p6) -> decltype(initWithFont(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(initWithFont(p0, p1, p2, p3, p4, p5, p6))(*)(MultilineBitmapFont*, char const*, gd::string, float, float, cocos2d::CCPoint, int, bool);
	static auto func = wrapFunction(base::get() + 0x6bea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6);
}

auto MultilineBitmapFont::moveSpecialDescriptors(int p0, int p1) -> decltype(moveSpecialDescriptors(p0, p1)) {
	using FunctionType = decltype(moveSpecialDescriptors(p0, p1))(*)(MultilineBitmapFont*, int, int);
	static auto func = wrapFunction(base::get() + 0x6d0a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto MultilineBitmapFont::readColorInfo(gd::string p0) -> decltype(readColorInfo(p0)) {
	using FunctionType = decltype(readColorInfo(p0))(*)(MultilineBitmapFont*, gd::string);
	static auto func = wrapFunction(base::get() + 0x6c7d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MultilineBitmapFont::stringWithMaxWidth(gd::string p0, float p1, float p2) -> decltype(stringWithMaxWidth(p0, p1, p2)) {
	using FunctionType = decltype(stringWithMaxWidth(p0, p1, p2))(*)(MultilineBitmapFont*, gd::string, float, float);
	static auto func = wrapFunction(base::get() + 0x6d130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto MultiplayerLayer::init() -> decltype(init()) {
	throw std::runtime_error("MultiplayerLayer::init not implemented");
}

auto MultiplayerLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("MultiplayerLayer::keyBackClicked not implemented");
}

auto MusicBrowser::create(int p0, GJSongType p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(int, GJSongType);
	static auto func = wrapFunction(base::get() + 0x323840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto MusicBrowser::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&MusicBrowser::update), this);
	using FunctionType = decltype(update(p0))(*)(MusicBrowser*, float);
	static auto func = wrapFunction(base::get() + 0x3245b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MusicBrowser::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("MusicBrowser::registerWithTouchDispatcher not implemented");
}

auto MusicBrowser::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MusicBrowser::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(MusicBrowser*);
	static auto func = wrapFunction(base::get() + 0x325c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MusicBrowser::musicActionFinished(GJMusicAction p0) -> decltype(musicActionFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJMusicAction>::func(&MusicBrowser::musicActionFinished), this);
	using FunctionType = decltype(musicActionFinished(p0))(*)(MusicBrowser*, GJMusicAction);
	static auto func = wrapFunction(base::get() + 0x324eb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MusicBrowser::musicActionFailed(GJMusicAction p0) -> decltype(musicActionFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJMusicAction>::func(&MusicBrowser::musicActionFailed), this);
	using FunctionType = decltype(musicActionFailed(p0))(*)(MusicBrowser*, GJMusicAction);
	static auto func = wrapFunction(base::get() + 0x324f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MusicBrowser::sliderEnded(Slider* p0) -> decltype(sliderEnded(p0)) {
	auto self = addresser::thunkAdjust(Resolve<Slider*>::func(&MusicBrowser::sliderEnded), this);
	using FunctionType = decltype(sliderEnded(p0))(*)(MusicBrowser*, Slider*);
	static auto func = wrapFunction(base::get() + 0x324bf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MusicBrowser::setTextPopupClosed(SetTextPopup* p0, gd::string p1) -> decltype(setTextPopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<SetTextPopup*, gd::string>::func(&MusicBrowser::setTextPopupClosed), this);
	using FunctionType = decltype(setTextPopupClosed(p0, p1))(*)(MusicBrowser*, SetTextPopup*, gd::string);
	static auto func = wrapFunction(base::get() + 0x325a00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MusicBrowser::cellPerformedAction(TableViewCell* p0, int p1, CellAction p2, cocos2d::CCNode* p3) -> decltype(cellPerformedAction(p0, p1, p2, p3)) {
	auto self = addresser::thunkAdjust(Resolve<TableViewCell*, int, CellAction, cocos2d::CCNode*>::func(&MusicBrowser::cellPerformedAction), this);
	using FunctionType = decltype(cellPerformedAction(p0, p1, p2, p3))(*)(MusicBrowser*, TableViewCell*, int, CellAction, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x325750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3);
}

auto MusicBrowser::getSelectedCellIdx() -> decltype(getSelectedCellIdx()) {
	throw std::runtime_error("MusicBrowser::getSelectedCellIdx not implemented");
}

auto MusicBrowser::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&MusicBrowser::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(MusicBrowser*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x325ba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MusicBrowser::init(int p0, GJSongType p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(MusicBrowser*, int, GJSongType);
	static auto func = wrapFunction(base::get() + 0x3239f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto MusicBrowser::onArtistFilters(cocos2d::CCObject* sender) -> decltype(onArtistFilters(sender)) {
	using FunctionType = decltype(onArtistFilters(sender))(*)(MusicBrowser*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x325b10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MusicBrowser::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(MusicBrowser*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x325c00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MusicBrowser::onPage(cocos2d::CCObject* sender) -> decltype(onPage(sender)) {
	using FunctionType = decltype(onPage(sender))(*)(MusicBrowser*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x325790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MusicBrowser::onPlaybackControl(cocos2d::CCObject* sender) -> decltype(onPlaybackControl(sender)) {
	using FunctionType = decltype(onPlaybackControl(sender))(*)(MusicBrowser*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x324b90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MusicBrowser::onSearch(cocos2d::CCObject* sender) -> decltype(onSearch(sender)) {
	using FunctionType = decltype(onSearch(sender))(*)(MusicBrowser*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3258b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MusicBrowser::onTagFilters(cocos2d::CCObject* sender) -> decltype(onTagFilters(sender)) {
	using FunctionType = decltype(onTagFilters(sender))(*)(MusicBrowser*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x325aa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MusicBrowser::setupList(MusicSearchResult* p0) -> decltype(setupList(p0)) {
	using FunctionType = decltype(setupList(p0))(*)(MusicBrowser*, MusicSearchResult*);
	static auto func = wrapFunction(base::get() + 0x325050, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicBrowser::setupSongControls() -> decltype(setupSongControls()) {
	using FunctionType = decltype(setupSongControls())(*)(MusicBrowser*);
	static auto func = wrapFunction(base::get() + 0x3248b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void PlatformDownloadDelegate::downloadFinished(char const* p0) {}

void PlatformDownloadDelegate::downloadFailed(char const* p0) {}

auto MusicDownloadManager::sharedState() -> decltype(sharedState()) {
	using FunctionType = decltype(sharedState())(*)();
	static auto func = wrapFunction(base::get() + 0x3277b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto MusicDownloadManager::init() -> decltype(init()) {
	throw std::runtime_error("MusicDownloadManager::init not implemented");
}

auto MusicDownloadManager::addDLToActive(char const* tag, cocos2d::CCObject* obj) -> decltype(addDLToActive(tag, obj)) {
	using FunctionType = decltype(addDLToActive(tag, obj))(*)(MusicDownloadManager*, char const*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3299f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, tag, obj);
}

auto MusicDownloadManager::addMusicDownloadDelegate(MusicDownloadDelegate* p0) -> decltype(addMusicDownloadDelegate(p0)) {
	using FunctionType = decltype(addMusicDownloadDelegate(p0))(*)(MusicDownloadManager*, MusicDownloadDelegate*);
	static auto func = wrapFunction(base::get() + 0x327f30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void MusicDownloadManager::clearSong(int songID) {
        const char* key = cocos2d::CCString::createWithFormat("%i", songID)->getCString();
        m_songObjects->removeObjectForKey(key);
    }

auto MusicDownloadManager::clearUnusedSongs() -> decltype(clearUnusedSongs()) {
	using FunctionType = decltype(clearUnusedSongs())(*)(MusicDownloadManager*);
	static auto func = wrapFunction(base::get() + 0x329160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto MusicDownloadManager::createArtistsInfo(gd::string p0) -> decltype(createArtistsInfo(p0)) {
	using FunctionType = decltype(createArtistsInfo(p0))(*)(MusicDownloadManager*, gd::string);
	static auto func = wrapFunction(base::get() + 0x328c50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::createSongsInfo(gd::string p0, gd::string p1) -> decltype(createSongsInfo(p0, p1)) {
	using FunctionType = decltype(createSongsInfo(p0, p1))(*)(MusicDownloadManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x3288a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto MusicDownloadManager::dataLoaded(DS_Dictionary* p0) -> decltype(dataLoaded(p0)) {
	using FunctionType = decltype(dataLoaded(p0))(*)(MusicDownloadManager*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x32a450, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::downloadCustomSong(int p0) -> decltype(downloadCustomSong(p0)) {
	using FunctionType = decltype(downloadCustomSong(p0))(*)(MusicDownloadManager*, int);
	static auto func = wrapFunction(base::get() + 0x32ad40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::downloadSong(int p0) -> decltype(downloadSong(p0)) {
	using FunctionType = decltype(downloadSong(p0))(*)(MusicDownloadManager*, int);
	static auto func = wrapFunction(base::get() + 0x329460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::generateCustomContentURL(gd::string p0) -> decltype(generateCustomContentURL(p0)) {
	using FunctionType = decltype(generateCustomContentURL(p0))(*)(MusicDownloadManager*, gd::string);
	static auto func = wrapFunction(base::get() + 0x32e2e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::getCustomContentURL() -> decltype(getCustomContentURL()) {
	using FunctionType = decltype(getCustomContentURL())(*)(MusicDownloadManager*);
	static auto func = wrapFunction(base::get() + 0x32a940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto MusicDownloadManager::getDLObject(char const* p0) -> decltype(getDLObject(p0)) {
	using FunctionType = decltype(getDLObject(p0))(*)(MusicDownloadManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x39d70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::getDownloadedSongs() -> decltype(getDownloadedSongs()) {
	using FunctionType = decltype(getDownloadedSongs())(*)(MusicDownloadManager*);
	static auto func = wrapFunction(base::get() + 0x3290a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto MusicDownloadManager::getSongInfo(int p0, bool p1) -> decltype(getSongInfo(p0, p1)) {
	using FunctionType = decltype(getSongInfo(p0, p1))(*)(MusicDownloadManager*, int, bool);
	static auto func = wrapFunction(base::get() + 0x328180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto MusicDownloadManager::getSongInfoObject(int p0) -> decltype(getSongInfoObject(p0)) {
	using FunctionType = decltype(getSongInfoObject(p0))(*)(MusicDownloadManager*, int);
	static auto func = wrapFunction(base::get() + 0x329b70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

bool MusicDownloadManager::isResourceSong(int id) {
        return m_resourceSongUnorderedSet.contains(id);
    }

auto MusicDownloadManager::isSongDownloaded(int p0) -> decltype(isSongDownloaded(p0)) {
	using FunctionType = decltype(isSongDownloaded(p0))(*)(MusicDownloadManager*, int);
	static auto func = wrapFunction(base::get() + 0x329c80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::loadSongInfoFinished(SongInfoObject* p0) -> decltype(loadSongInfoFinished(p0)) {
	using FunctionType = decltype(loadSongInfoFinished(p0))(*)(MusicDownloadManager*, SongInfoObject*);
	static auto func = wrapFunction(base::get() + 0x32ec70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::onDownloadSongCompleted(cocos2d::extension::CCHttpClient* p0, cocos2d::extension::CCHttpResponse* p1) -> decltype(onDownloadSongCompleted(p0, p1)) {
	using FunctionType = decltype(onDownloadSongCompleted(p0, p1))(*)(MusicDownloadManager*, cocos2d::extension::CCHttpClient*, cocos2d::extension::CCHttpResponse*);
	static auto func = wrapFunction(base::get() + 0x329750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto MusicDownloadManager::onGetSongInfoCompleted(gd::string p0, gd::string p1) -> decltype(onGetSongInfoCompleted(p0, p1)) {
	using FunctionType = decltype(onGetSongInfoCompleted(p0, p1))(*)(MusicDownloadManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x328460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto MusicDownloadManager::pathForSFX(int p0) -> decltype(pathForSFX(p0)) {
	using FunctionType = decltype(pathForSFX(p0))(*)(MusicDownloadManager*, int);
	static auto func = wrapFunction(base::get() + 0x32a230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::pathForSFXFolder(int p0) -> decltype(pathForSFXFolder(p0)) {
	using FunctionType = decltype(pathForSFXFolder(p0))(*)(MusicDownloadManager*, int);
	static auto func = wrapFunction(base::get() + 0x32a0e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::pathForSong(int p0) -> decltype(pathForSong(p0)) {
	using FunctionType = decltype(pathForSong(p0))(*)(MusicDownloadManager*, int);
	static auto func = wrapFunction(base::get() + 0x329f00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::pathForSongFolder(int p0) -> decltype(pathForSongFolder(p0)) {
	using FunctionType = decltype(pathForSongFolder(p0))(*)(MusicDownloadManager*, int);
	static auto func = wrapFunction(base::get() + 0x329db0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::showTOS(FLAlertLayerProtocol* p0) -> decltype(showTOS(p0)) {
	using FunctionType = decltype(showTOS(p0))(*)(MusicDownloadManager*, FLAlertLayerProtocol*);
	static auto func = wrapFunction(base::get() + 0x32a2f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::songStateChanged() -> decltype(songStateChanged()) {
	using FunctionType = decltype(songStateChanged())(*)(MusicDownloadManager*);
	static auto func = wrapFunction(base::get() + 0x328120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto OptionsObjectDelegate::stateChanged(OptionsObject* p0) -> decltype(stateChanged(p0)) {
	throw std::runtime_error("OptionsObjectDelegate::stateChanged not implemented");
}

MusicSearchResult::MusicSearchResult() : MusicSearchResult(geode::CutoffConstructor, sizeof(MusicSearchResult)) {
	// here we construct it as normal as we can, then destruct it
	// using the generated functions. this ensures no memory gets leaked
	// no crashes :pray:
	CCDestructor::lock(this) = true;
	MusicSearchResult::~MusicSearchResult();
	using FunctionType = void(*)(MusicSearchResult*);
	static auto func = wrapFunction(base::get() + 0x326990, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
}

MusicSearchResult* MusicSearchResult::create(GJSongType songType) {
        auto ret = new MusicSearchResult();
        if (ret->init(songType)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto MusicSearchResult::updateObjects(AudioSortType p0) -> decltype(updateObjects(p0)) {
	auto self = addresser::thunkAdjust(Resolve<AudioSortType>::func(&MusicSearchResult::updateObjects), this);
	using FunctionType = decltype(updateObjects(p0))(*)(MusicSearchResult*, AudioSortType);
	static auto func = wrapFunction(base::get() + 0x331610, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MusicSearchResult::stateChanged(OptionsObject* p0) -> decltype(stateChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<OptionsObject*>::func(&MusicSearchResult::stateChanged), this);
	using FunctionType = decltype(stateChanged(p0))(*)(MusicSearchResult*, OptionsObject*);
	static auto func = wrapFunction(base::get() + 0x331600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MusicSearchResult::applyTagFilters(cocos2d::CCArray* p0) -> decltype(applyTagFilters(p0)) {
	using FunctionType = decltype(applyTagFilters(p0))(*)(MusicSearchResult*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x331530, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicSearchResult::getFilesMatchingSearch(cocos2d::CCArray* p0, gd::string p1) -> decltype(getFilesMatchingSearch(p0, p1)) {
	using FunctionType = decltype(getFilesMatchingSearch(p0, p1))(*)(MusicSearchResult*, cocos2d::CCArray*, gd::string);
	static auto func = wrapFunction(base::get() + 0x331b60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

bool MusicSearchResult::init(GJSongType songType) {
        m_songType = songType;
        return true;
    }

void MusicSearchResult::updateObjects() {
        this->updateObjects(m_sortType);
    }

auto NCSInfoLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("NCSInfoLayer::keyBackClicked not implemented");
}

auto NewgroundsInfoLayer::init() -> decltype(init()) {
	throw std::runtime_error("NewgroundsInfoLayer::init not implemented");
}

auto NewgroundsInfoLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("NewgroundsInfoLayer::keyBackClicked not implemented");
}

auto NewgroundsInfoLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&NewgroundsInfoLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(NewgroundsInfoLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0xc5690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

NumberInputLayer::NumberInputLayer() {
        m_okButton = nullptr;
        m_minimum = 4;
        m_maximum = 4;
        m_inputString = "";
        m_delegate = nullptr;
    }

NumberInputLayer* NumberInputLayer::create() {
        auto ret = new NumberInputLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto NumberInputLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&NumberInputLayer::init), this);
	using FunctionType = decltype(init())(*)(NumberInputLayer*);
	static auto func = wrapFunction(base::get() + 0x3326e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto NumberInputLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&NumberInputLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(NumberInputLayer*);
	static auto func = wrapFunction(base::get() + 0x52d60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto NumberInputLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("NumberInputLayer::keyBackClicked not implemented");
}

void NumberInputLayer::deleteLast() {
        if (!m_inputString.empty()) {
            m_inputString = m_inputString.substr(0, m_inputString.size() - 1);
            this->updateNumberState();
        }
    }

void NumberInputLayer::inputNumber(int num) {
        if (m_inputString.size() < m_maximum) {
            m_inputString += cocos2d::CCString::createWithFormat("%i", num)->getCString();
            this->updateNumberState();
        }
    }

auto NumberInputLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(NumberInputLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x84620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

void NumberInputLayer::onDone(cocos2d::CCObject* sender) {
        if (m_delegate) m_delegate->numberInputClosed(this);
        this->onClose(nullptr);
    }

auto NumberInputLayer::onNumber(cocos2d::CCObject* sender) -> decltype(onNumber(sender)) {
	using FunctionType = decltype(onNumber(sender))(*)(NumberInputLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x332c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto NumberInputLayer::updateNumberState() -> decltype(updateNumberState()) {
	using FunctionType = decltype(updateNumberState())(*)(NumberInputLayer*);
	static auto func = wrapFunction(base::get() + 0x332e20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto OBB2D::create(cocos2d::CCPoint center, float width, float height, float rotationAngle) -> decltype(create(center, width, height, rotationAngle)) {
	using FunctionType = decltype(create(center, width, height, rotationAngle))(*)(cocos2d::CCPoint, float, float, float);
	static auto func = wrapFunction(base::get() + 0x6d880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(center, width, height, rotationAngle);
}

auto OBB2D::calculateWithCenter(cocos2d::CCPoint center, float width, float height, float rotationAngle) -> decltype(calculateWithCenter(center, width, height, rotationAngle)) {
	using FunctionType = decltype(calculateWithCenter(center, width, height, rotationAngle))(*)(OBB2D*, cocos2d::CCPoint, float, float, float);
	static auto func = wrapFunction(base::get() + 0x6da50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, center, width, height, rotationAngle);
}

auto OBB2D::orderCorners() -> decltype(orderCorners()) {
	using FunctionType = decltype(orderCorners())(*)(OBB2D*);
	static auto func = wrapFunction(base::get() + 0x6dd70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto OBB2D::overlaps1Way(OBB2D* p0) -> decltype(overlaps1Way(p0)) {
	using FunctionType = decltype(overlaps1Way(p0))(*)(OBB2D*, OBB2D*);
	static auto func = wrapFunction(base::get() + 0x6e100, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ObjectControlGameObject::init() -> decltype(init()) {
	throw std::runtime_error("ObjectControlGameObject::init not implemented");
}

auto ObjectControlGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("ObjectControlGameObject::customObjectSetup not implemented");
}

auto ObjectControlGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("ObjectControlGameObject::getSaveString not implemented");
}

auto ObjectManager::instance() -> decltype(instance()) {
	using FunctionType = decltype(instance())(*)();
	static auto func = wrapFunction(base::get() + 0x6e3d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto ObjectManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ObjectManager::init), this);
	using FunctionType = decltype(init())(*)(ObjectManager*);
	static auto func = wrapFunction(base::get() + 0x6e460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ObjectManager::loadCopiedAnimations() -> decltype(loadCopiedAnimations()) {
	using FunctionType = decltype(loadCopiedAnimations())(*)(ObjectManager*);
	static auto func = wrapFunction(base::get() + 0x6e800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ObjectManager::setup() -> decltype(setup()) {
	using FunctionType = decltype(setup())(*)(ObjectManager*);
	static auto func = wrapFunction(base::get() + 0x6e4c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ObjectToolbox::sharedState() -> decltype(sharedState()) {
	using FunctionType = decltype(sharedState())(*)();
	static auto func = wrapFunction(base::get() + 0x332f90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto ObjectToolbox::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ObjectToolbox::init), this);
	using FunctionType = decltype(init())(*)(ObjectToolbox*);
	static auto func = wrapFunction(base::get() + 0x333050, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ObjectToolbox::gridNodeSizeForKey(int key) -> decltype(gridNodeSizeForKey(key)) {
	using FunctionType = decltype(gridNodeSizeForKey(key))(*)(ObjectToolbox*, int);
	static auto func = wrapFunction(base::get() + 0x35ae80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, key);
}

const char* ObjectToolbox::intKeyToFrame(int key) {
        return m_allKeys[key].c_str();
    }

void OnlineListDelegate::loadListFinished(cocos2d::CCArray* p0, char const* p1) {}

void OnlineListDelegate::loadListFailed(char const* p0) {}

void OnlineListDelegate::setupPageInfo(gd::string p0, char const* p1) {}

auto OptionsCell::loadFromObject(OptionsObject* p0) -> decltype(loadFromObject(p0)) {
	using FunctionType = decltype(loadFromObject(p0))(*)(OptionsCell*, OptionsObject*);
	static auto func = wrapFunction(base::get() + 0xb49f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

OptionsLayer* OptionsLayer::create() {
        auto ret = new OptionsLayer();
        if (ret->init("Settings")) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto OptionsLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&OptionsLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(OptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x35bff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto OptionsLayer::layerHidden() -> decltype(layerHidden()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&OptionsLayer::layerHidden), this);
	using FunctionType = decltype(layerHidden())(*)(OptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x35d840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void OptionsLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) {}

auto OptionsLayer::musicSliderChanged(cocos2d::CCObject* p0) -> decltype(musicSliderChanged(p0)) {
	using FunctionType = decltype(musicSliderChanged(p0))(*)(OptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x35cc70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto OptionsLayer::onAccount(cocos2d::CCObject* sender) -> decltype(onAccount(sender)) {
	using FunctionType = decltype(onAccount(sender))(*)(OptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x35d760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto OptionsLayer::onHelp(cocos2d::CCObject* sender) -> decltype(onHelp(sender)) {
	using FunctionType = decltype(onHelp(sender))(*)(OptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x35d710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto OptionsLayer::onOptions(cocos2d::CCObject* sender) -> decltype(onOptions(sender)) {
	using FunctionType = decltype(onOptions(sender))(*)(OptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x35ce50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto OptionsLayer::onRate(cocos2d::CCObject* sender) -> decltype(onRate(sender)) {
	using FunctionType = decltype(onRate(sender))(*)(OptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x35d7b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto OptionsLayer::onSecretVault(cocos2d::CCObject* sender) -> decltype(onSecretVault(sender)) {
	using FunctionType = decltype(onSecretVault(sender))(*)(OptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x35cfb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto OptionsLayer::onSoundtracks(cocos2d::CCObject* sender) -> decltype(onSoundtracks(sender)) {
	using FunctionType = decltype(onSoundtracks(sender))(*)(OptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x35ce00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto OptionsLayer::onSupport(cocos2d::CCObject* sender) -> decltype(onSupport(sender)) {
	using FunctionType = decltype(onSupport(sender))(*)(OptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x35d820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto OptionsLayer::onVideo(cocos2d::CCObject* sender) -> decltype(onVideo(sender)) {
	using FunctionType = decltype(onVideo(sender))(*)(OptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x35d6f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto OptionsLayer::sfxSliderChanged(cocos2d::CCObject* p0) -> decltype(sfxSliderChanged(p0)) {
	using FunctionType = decltype(sfxSliderChanged(p0))(*)(OptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x35cd70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto OptionsScrollLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("OptionsScrollLayer::registerWithTouchDispatcher not implemented");
}

auto OptionsScrollLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&OptionsScrollLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(OptionsScrollLayer*);
	static auto func = wrapFunction(base::get() + 0x326150, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto OptionsScrollLayer::cellPerformedAction(TableViewCell* p0, int p1, CellAction p2, cocos2d::CCNode* p3) -> decltype(cellPerformedAction(p0, p1, p2, p3)) {
	throw std::runtime_error("OptionsScrollLayer::cellPerformedAction not implemented");
}

auto ParentalOptionsLayer::init() -> decltype(init()) {
	throw std::runtime_error("ParentalOptionsLayer::init not implemented");
}

auto ParentalOptionsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("ParentalOptionsLayer::keyBackClicked not implemented");
}

auto ParticleGameObject::init() -> decltype(init()) {
	throw std::runtime_error("ParticleGameObject::init not implemented");
}

auto ParticleGameObject::setScaleX(float p0) -> decltype(setScaleX(p0)) {
	throw std::runtime_error("ParticleGameObject::setScaleX not implemented");
}

auto ParticleGameObject::setScaleY(float p0) -> decltype(setScaleY(p0)) {
	throw std::runtime_error("ParticleGameObject::setScaleY not implemented");
}

auto ParticleGameObject::setScale(float p0) -> decltype(setScale(p0)) {
	throw std::runtime_error("ParticleGameObject::setScale not implemented");
}

auto ParticleGameObject::setRotation(float p0) -> decltype(setRotation(p0)) {
	throw std::runtime_error("ParticleGameObject::setRotation not implemented");
}

auto ParticleGameObject::setRotationX(float p0) -> decltype(setRotationX(p0)) {
	throw std::runtime_error("ParticleGameObject::setRotationX not implemented");
}

auto ParticleGameObject::setRotationY(float p0) -> decltype(setRotationY(p0)) {
	throw std::runtime_error("ParticleGameObject::setRotationY not implemented");
}

auto ParticleGameObject::setChildColor(cocos2d::ccColor3B const& p0) -> decltype(setChildColor(p0)) {
	throw std::runtime_error("ParticleGameObject::setChildColor not implemented");
}

auto ParticleGameObject::customSetup() -> decltype(customSetup()) {
	throw std::runtime_error("ParticleGameObject::customSetup not implemented");
}

auto ParticleGameObject::addMainSpriteToParent(bool p0) -> decltype(addMainSpriteToParent(p0)) {
	throw std::runtime_error("ParticleGameObject::addMainSpriteToParent not implemented");
}

auto ParticleGameObject::resetObject() -> decltype(resetObject()) {
	throw std::runtime_error("ParticleGameObject::resetObject not implemented");
}

auto ParticleGameObject::deactivateObject(bool p0) -> decltype(deactivateObject(p0)) {
	throw std::runtime_error("ParticleGameObject::deactivateObject not implemented");
}

auto ParticleGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("ParticleGameObject::customObjectSetup not implemented");
}

auto ParticleGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("ParticleGameObject::getSaveString not implemented");
}

auto ParticleGameObject::claimParticle() -> decltype(claimParticle()) {
	throw std::runtime_error("ParticleGameObject::claimParticle not implemented");
}

auto ParticleGameObject::unclaimParticle() -> decltype(unclaimParticle()) {
	throw std::runtime_error("ParticleGameObject::unclaimParticle not implemented");
}

auto ParticleGameObject::particleWasActivated() -> decltype(particleWasActivated()) {
	throw std::runtime_error("ParticleGameObject::particleWasActivated not implemented");
}

auto ParticleGameObject::setObjectColor(cocos2d::ccColor3B const& p0) -> decltype(setObjectColor(p0)) {
	throw std::runtime_error("ParticleGameObject::setObjectColor not implemented");
}

auto ParticleGameObject::blendModeChanged() -> decltype(blendModeChanged()) {
	throw std::runtime_error("ParticleGameObject::blendModeChanged not implemented");
}

auto ParticleGameObject::updateParticleColor(cocos2d::ccColor3B const& p0) -> decltype(updateParticleColor(p0)) {
	throw std::runtime_error("ParticleGameObject::updateParticleColor not implemented");
}

auto ParticleGameObject::updateParticleOpacity(unsigned char p0) -> decltype(updateParticleOpacity(p0)) {
	throw std::runtime_error("ParticleGameObject::updateParticleOpacity not implemented");
}

auto ParticleGameObject::updateMainParticleOpacity(unsigned char p0) -> decltype(updateMainParticleOpacity(p0)) {
	throw std::runtime_error("ParticleGameObject::updateMainParticleOpacity not implemented");
}

auto ParticleGameObject::updateSecondaryParticleOpacity(unsigned char p0) -> decltype(updateSecondaryParticleOpacity(p0)) {
	throw std::runtime_error("ParticleGameObject::updateSecondaryParticleOpacity not implemented");
}

auto ParticleGameObject::updateSyncedAnimation(float p0, int p1) -> decltype(updateSyncedAnimation(p0, p1)) {
	throw std::runtime_error("ParticleGameObject::updateSyncedAnimation not implemented");
}

auto ParticleGameObject::updateAnimateOnTrigger(bool p0) -> decltype(updateAnimateOnTrigger(p0)) {
	throw std::runtime_error("ParticleGameObject::updateAnimateOnTrigger not implemented");
}

auto ParticleGameObject::setParticleString(gd::string p0) -> decltype(setParticleString(p0)) {
	using FunctionType = decltype(setParticleString(p0))(*)(ParticleGameObject*, gd::string);
	static auto func = wrapFunction(base::get() + 0x4880b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ParticleGameObject::updateParticle() -> decltype(updateParticle()) {
	using FunctionType = decltype(updateParticle())(*)(ParticleGameObject*);
	static auto func = wrapFunction(base::get() + 0x488140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ParticlePreviewLayer::draw() -> decltype(draw()) {
	throw std::runtime_error("ParticlePreviewLayer::draw not implemented");
}

auto ParticlePreviewLayer::visit() -> decltype(visit()) {
	throw std::runtime_error("ParticlePreviewLayer::visit not implemented");
}

PauseLayer::PauseLayer() {}

PauseLayer* PauseLayer::create(bool p0) {
        auto ret = new PauseLayer();
        if (ret && ret->init(p0)) {
            ret->autorelease();
            return ret;
        }
        CC_SAFE_DELETE(ret);
        return nullptr;
    }

auto PauseLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PauseLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(PauseLayer*);
	static auto func = wrapFunction(base::get() + 0x369070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PauseLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&PauseLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(PauseLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x368fa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PauseLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PauseLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(PauseLayer*);
	static auto func = wrapFunction(base::get() + 0x366b00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PauseLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&PauseLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(PauseLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x368de0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void PauseLayer::keyUp(cocos2d::enumKeyCodes p0) {}

auto PauseLayer::goEdit() -> decltype(goEdit()) {
	using FunctionType = decltype(goEdit())(*)(PauseLayer*);
	static auto func = wrapFunction(base::get() + 0x368b80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

bool PauseLayer::init(bool p0) {
        m_unkBool1 = p0;
        return CCBlockLayer::init();
    }

auto PauseLayer::musicSliderChanged(cocos2d::CCObject* p0) -> decltype(musicSliderChanged(p0)) {
	using FunctionType = decltype(musicSliderChanged(p0))(*)(PauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3683c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PauseLayer::onEdit(cocos2d::CCObject* sender) -> decltype(onEdit(sender)) {
	using FunctionType = decltype(onEdit(sender))(*)(PauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3687e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto PauseLayer::onNormalMode(cocos2d::CCObject* sender) -> decltype(onNormalMode(sender)) {
	using FunctionType = decltype(onNormalMode(sender))(*)(PauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x368530, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto PauseLayer::onPracticeMode(cocos2d::CCObject* sender) -> decltype(onPracticeMode(sender)) {
	using FunctionType = decltype(onPracticeMode(sender))(*)(PauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x368450, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto PauseLayer::onQuit(cocos2d::CCObject* sender) -> decltype(onQuit(sender)) {
	using FunctionType = decltype(onQuit(sender))(*)(PauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x368e50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto PauseLayer::onRestart(cocos2d::CCObject* sender) -> decltype(onRestart(sender)) {
	using FunctionType = decltype(onRestart(sender))(*)(PauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3686a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto PauseLayer::onRestartFull(cocos2d::CCObject* sender) -> decltype(onRestartFull(sender)) {
	using FunctionType = decltype(onRestartFull(sender))(*)(PauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x368740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto PauseLayer::onResume(cocos2d::CCObject* sender) -> decltype(onResume(sender)) {
	using FunctionType = decltype(onResume(sender))(*)(PauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x368610, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto PauseLayer::onSettings(cocos2d::CCObject* sender) -> decltype(onSettings(sender)) {
	using FunctionType = decltype(onSettings(sender))(*)(PauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3677d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto PauseLayer::sfxSliderChanged(cocos2d::CCObject* p0) -> decltype(sfxSliderChanged(p0)) {
	using FunctionType = decltype(sfxSliderChanged(p0))(*)(PauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x35cd70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PauseLayer::tryQuit(cocos2d::CCObject* sender) -> decltype(tryQuit(sender)) {
	using FunctionType = decltype(tryQuit(sender))(*)(PauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x368c50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto PlatformToolbox::getDisplaySize() -> decltype(getDisplaySize()) {
	using FunctionType = decltype(getDisplaySize())(*)();
	static auto func = wrapFunction(base::get() + 0x786d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

void PlatformToolbox::hideCursor() {
        cocos2d::CCEGLView::sharedOpenGLView()->showCursor(false);
    }

bool PlatformToolbox::isControllerConnected() {
        #ifdef GEODE_IS_WINDOWS
            return cocos2d::CCApplication::sharedApplication()->getControllerConnected();
        #else
            return false;
        #endif
    }

void PlatformToolbox::showCursor() {
        cocos2d::CCEGLView::sharedOpenGLView()->showCursor(true);
    }

auto PlayerCheckpoint::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x3a4210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto PlayerCheckpoint::init() -> decltype(init()) {
	throw std::runtime_error("PlayerCheckpoint::init not implemented");
}

auto PlayerControlGameObject::init() -> decltype(init()) {
	throw std::runtime_error("PlayerControlGameObject::init not implemented");
}

auto PlayerControlGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("PlayerControlGameObject::customObjectSetup not implemented");
}

auto PlayerControlGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("PlayerControlGameObject::getSaveString not implemented");
}

auto PlayerFireBoostSprite::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x38cf30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto PlayerFireBoostSprite::init() -> decltype(init()) {
	throw std::runtime_error("PlayerFireBoostSprite::init not implemented");
}

void PlayerFireBoostSprite::animateFireIn() {
        this->stopAllActions();

        auto scaleto = cocos2d::CCScaleTo::create(0.06f, m_size * 0.6f, m_size * 1.5f);
        auto callfunc = cocos2d::CCCallFunc::create(this, callfunc_selector(PlayerFireBoostSprite::loopFireAnimation));
        auto sequence = cocos2d::CCSequence::create(scaleto, callfunc, nullptr);
        this->runAction(sequence);
    }

void PlayerFireBoostSprite::animateFireOut() {
        this->stopAllActions();
        auto action = cocos2d::CCScaleTo::create(0.4f, 0.01f, 0.01f);
        this->runAction(action);
    }

auto PlayerFireBoostSprite::loopFireAnimation() -> decltype(loopFireAnimation()) {
	using FunctionType = decltype(loopFireAnimation())(*)(PlayerFireBoostSprite*);
	static auto func = wrapFunction(base::get() + 0x38d030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::create(int p0, int p1, GJBaseGameLayer* p2, cocos2d::CCLayer* p3, bool p4) -> decltype(create(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4))(*)(int, int, GJBaseGameLayer*, cocos2d::CCLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x370960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4);
}

auto PlayerObject::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&PlayerObject::update), this);
	using FunctionType = decltype(update(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x373010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::setScaleX(float p0) -> decltype(setScaleX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&PlayerObject::setScaleX), this);
	using FunctionType = decltype(setScaleX(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x38cac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::setScaleY(float p0) -> decltype(setScaleY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&PlayerObject::setScaleY), this);
	using FunctionType = decltype(setScaleY(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x38cae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::setScale(float p0) -> decltype(setScale(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&PlayerObject::setScale), this);
	using FunctionType = decltype(setScale(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x38cad0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::setPosition(cocos2d::CCPoint const& p0) -> decltype(setPosition(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint const&>::func(&PlayerObject::setPosition), this);
	using FunctionType = decltype(setPosition(p0))(*)(PlayerObject*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x3868b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::setVisible(bool p0) -> decltype(setVisible(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&PlayerObject::setVisible), this);
	using FunctionType = decltype(setVisible(p0))(*)(PlayerObject*, bool);
	static auto func = wrapFunction(base::get() + 0x38caf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::setRotation(float p0) -> decltype(setRotation(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&PlayerObject::setRotation), this);
	using FunctionType = decltype(setRotation(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x38c9f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&PlayerObject::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(PlayerObject*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x387d60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::setColor(cocos2d::ccColor3B const& p0) -> decltype(setColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B const&>::func(&PlayerObject::setColor), this);
	using FunctionType = decltype(setColor(p0))(*)(PlayerObject*, cocos2d::ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x387580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::setFlipX(bool p0) -> decltype(setFlipX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&PlayerObject::setFlipX), this);
	using FunctionType = decltype(setFlipX(p0))(*)(PlayerObject*, bool);
	static auto func = wrapFunction(base::get() + 0x38ca00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::setFlipY(bool p0) -> decltype(setFlipY(p0)) {
	throw std::runtime_error("PlayerObject::setFlipY not implemented");
}

auto PlayerObject::resetObject() -> decltype(resetObject()) {
	throw std::runtime_error("PlayerObject::resetObject not implemented");
}

auto PlayerObject::getRealPosition() -> decltype(getRealPosition()) {
	throw std::runtime_error("PlayerObject::getRealPosition not implemented");
}

auto PlayerObject::getOrientedBox() -> decltype(getOrientedBox()) {
	throw std::runtime_error("PlayerObject::getOrientedBox not implemented");
}

auto PlayerObject::getObjectRotation() -> decltype(getObjectRotation()) {
	throw std::runtime_error("PlayerObject::getObjectRotation not implemented");
}

auto PlayerObject::animationFinished(char const* p0) -> decltype(animationFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&PlayerObject::animationFinished), this);
	using FunctionType = decltype(animationFinished(p0))(*)(PlayerObject*, char const*);
	static auto func = wrapFunction(base::get() + 0x38cb10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::activateStreak() -> decltype(activateStreak()) {
	using FunctionType = decltype(activateStreak())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x38a300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::addAllParticles() -> decltype(addAllParticles()) {
	using FunctionType = decltype(addAllParticles())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x372900, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::animatePlatformerJump(float p0) -> decltype(animatePlatformerJump(p0)) {
	using FunctionType = decltype(animatePlatformerJump(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x376ef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::boostPlayer(float p0) -> decltype(boostPlayer(p0)) {
	using FunctionType = decltype(boostPlayer(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x38a150, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::bumpPlayer(float p0, int p1, bool p2, GameObject* p3) -> decltype(bumpPlayer(p0, p1, p2, p3)) {
	using FunctionType = decltype(bumpPlayer(p0, p1, p2, p3))(*)(PlayerObject*, float, int, bool, GameObject*);
	static auto func = wrapFunction(base::get() + 0x389910, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto PlayerObject::collidedWithObject(float p0, GameObject* p1, cocos2d::CCRect p2, bool p3) -> decltype(collidedWithObject(p0, p1, p2, p3)) {
	using FunctionType = decltype(collidedWithObject(p0, p1, p2, p3))(*)(PlayerObject*, float, GameObject*, cocos2d::CCRect, bool);
	static auto func = wrapFunction(base::get() + 0x37bb80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto PlayerObject::collidedWithObjectInternal(float p0, GameObject* p1, cocos2d::CCRect p2, bool p3) -> decltype(collidedWithObjectInternal(p0, p1, p2, p3)) {
	using FunctionType = decltype(collidedWithObjectInternal(p0, p1, p2, p3))(*)(PlayerObject*, float, GameObject*, cocos2d::CCRect, bool);
	static auto func = wrapFunction(base::get() + 0x37bc40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto PlayerObject::collidedWithSlopeInternal(float dt, GameObject* object, bool forced) -> decltype(collidedWithSlopeInternal(dt, object, forced)) {
	using FunctionType = decltype(collidedWithSlopeInternal(dt, object, forced))(*)(PlayerObject*, float, GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x3799e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, dt, object, forced);
}

auto PlayerObject::copyAttributes(PlayerObject* p0) -> decltype(copyAttributes(p0)) {
	using FunctionType = decltype(copyAttributes(p0))(*)(PlayerObject*, PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x38a710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::createFadeOutDartStreak() -> decltype(createFadeOutDartStreak()) {
	using FunctionType = decltype(createFadeOutDartStreak())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x382830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::createRobot(int p0) -> decltype(createRobot(p0)) {
	using FunctionType = decltype(createRobot(p0))(*)(PlayerObject*, int);
	static auto func = wrapFunction(base::get() + 0x372180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::createSpider(int p0) -> decltype(createSpider(p0)) {
	using FunctionType = decltype(createSpider(p0))(*)(PlayerObject*, int);
	static auto func = wrapFunction(base::get() + 0x372540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void PlayerObject::disableCustomGlowColor() {
        m_hasCustomGlowColor = false;
    }

auto PlayerObject::disablePlayerControls() -> decltype(disablePlayerControls()) {
	using FunctionType = decltype(disablePlayerControls())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x389620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::disableSwingFire() -> decltype(disableSwingFire()) {
	using FunctionType = decltype(disableSwingFire())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x385170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::doReversePlayer(bool p0) -> decltype(doReversePlayer(p0)) {
	using FunctionType = decltype(doReversePlayer(p0))(*)(PlayerObject*, bool);
	static auto func = wrapFunction(base::get() + 0x3826e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::enablePlayerControls() -> decltype(enablePlayerControls()) {
	using FunctionType = decltype(enablePlayerControls())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x389770, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::fadeOutStreak2(float p0) -> decltype(fadeOutStreak2(p0)) {
	using FunctionType = decltype(fadeOutStreak2(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x38a400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::flipGravity(bool p0, bool p1) -> decltype(flipGravity(p0, p1)) {
	using FunctionType = decltype(flipGravity(p0, p1))(*)(PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x384440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

void PlayerObject::gameEventTriggered(int p0, int p1) {
        if (this->m_gameLayer) {
            this->m_gameLayer->gameEventTriggered(static_cast<GJGameEvent>(p0), p1, static_cast<int>(this->m_savedObjectType));
        }
    }

auto PlayerObject::handleRotatedCollisionInternal(float p0, GameObject* p1, cocos2d::CCRect p2, bool p3, bool p4, bool p5) -> decltype(handleRotatedCollisionInternal(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(handleRotatedCollisionInternal(p0, p1, p2, p3, p4, p5))(*)(PlayerObject*, float, GameObject*, cocos2d::CCRect, bool, bool, bool);
	static auto func = wrapFunction(base::get() + 0x379310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

TodoReturn PlayerObject::handleRotatedObjectCollision(float p0, GameObject* p1, cocos2d::CCRect p2, bool p3) {
        return this->handleRotatedCollisionInternal(p0, p1, p2, p3, false, false);
    }

auto PlayerObject::hitGround(GameObject* p0, bool p1) -> decltype(hitGround(p0, p1)) {
	using FunctionType = decltype(hitGround(p0, p1))(*)(PlayerObject*, GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x3861a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::incrementJumps() -> decltype(incrementJumps()) {
	using FunctionType = decltype(incrementJumps())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x376e10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::init(int p0, int p1, GJBaseGameLayer* p2, cocos2d::CCLayer* p3, bool p4) -> decltype(init(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4))(*)(PlayerObject*, int, int, GJBaseGameLayer*, cocos2d::CCLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x370a00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

bool PlayerObject::isFlying() {
        return m_isShip || m_isBird || m_isDart || m_isSwing;
    }

bool PlayerObject::isInBasicMode() {
        return !this->isFlying() && !m_isBall && !m_isSpider;
    }

bool PlayerObject::isInNormalMode() {
        return !this->isFlying() && !m_isBall && !m_isRobot && !m_isSpider;
    }

auto PlayerObject::levelFlipFinished() -> decltype(levelFlipFinished()) {
	using FunctionType = decltype(levelFlipFinished())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x3759e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::loadFromCheckpoint(PlayerCheckpoint* p0) -> decltype(loadFromCheckpoint(p0)) {
	using FunctionType = decltype(loadFromCheckpoint(p0))(*)(PlayerObject*, PlayerCheckpoint*);
	static auto func = wrapFunction(base::get() + 0x38bc30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::lockPlayer() -> decltype(lockPlayer()) {
	using FunctionType = decltype(lockPlayer())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x389540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::placeStreakPoint() -> decltype(placeStreakPoint()) {
	using FunctionType = decltype(placeStreakPoint())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x38a8f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::playBumpEffect(int p0, GameObject* p1) -> decltype(playBumpEffect(p0, p1)) {
	using FunctionType = decltype(playBumpEffect(p0, p1))(*)(PlayerObject*, int, GameObject*);
	static auto func = wrapFunction(base::get() + 0x389cc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::playCompleteEffect(bool p0, bool p1) -> decltype(playCompleteEffect(p0, p1)) {
	using FunctionType = decltype(playCompleteEffect(p0, p1))(*)(PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x36e2b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::playDeathEffect() -> decltype(playDeathEffect()) {
	using FunctionType = decltype(playDeathEffect())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x3691a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::playDynamicSpiderRun() -> decltype(playDynamicSpiderRun()) {
	using FunctionType = decltype(playDynamicSpiderRun())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x38b740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::playerDestroyed(bool p0) -> decltype(playerDestroyed(p0)) {
	using FunctionType = decltype(playerDestroyed(p0))(*)(PlayerObject*, bool);
	static auto func = wrapFunction(base::get() + 0x381f10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::playSpawnEffect() -> decltype(playSpawnEffect()) {
	using FunctionType = decltype(playSpawnEffect())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x381650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::playSpiderDashEffect(cocos2d::CCPoint from, cocos2d::CCPoint to) -> decltype(playSpiderDashEffect(from, to)) {
	using FunctionType = decltype(playSpiderDashEffect(from, to))(*)(PlayerObject*, cocos2d::CCPoint, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x37f340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, from, to);
}

auto PlayerObject::postCollision(float p0) -> decltype(postCollision(p0)) {
	using FunctionType = decltype(postCollision(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x3777f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::preSlopeCollision(float p0, GameObject* p1) -> decltype(preSlopeCollision(p0, p1)) {
	using FunctionType = decltype(preSlopeCollision(p0, p1))(*)(PlayerObject*, float, GameObject*);
	static auto func = wrapFunction(base::get() + 0x3794b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::propellPlayer(float p0, bool p1, int p2) -> decltype(propellPlayer(p0, p1, p2)) {
	using FunctionType = decltype(propellPlayer(p0, p1, p2))(*)(PlayerObject*, float, bool, int);
	static auto func = wrapFunction(base::get() + 0x389ac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto PlayerObject::pushButton(PlayerButton p0) -> decltype(pushButton(p0)) {
	using FunctionType = decltype(pushButton(p0))(*)(PlayerObject*, PlayerButton);
	static auto func = wrapFunction(base::get() + 0x382110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::redirectPlayerForce(float p0, float p1, float p2, float p3) -> decltype(redirectPlayerForce(p0, p1, p2, p3)) {
	using FunctionType = decltype(redirectPlayerForce(p0, p1, p2, p3))(*)(PlayerObject*, float, float, float, float);
	static auto func = wrapFunction(base::get() + 0x389ed0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto PlayerObject::releaseAllButtons() -> decltype(releaseAllButtons()) {
	using FunctionType = decltype(releaseAllButtons())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x389370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::releaseButton(PlayerButton p0) -> decltype(releaseButton(p0)) {
	using FunctionType = decltype(releaseButton(p0))(*)(PlayerObject*, PlayerButton);
	static auto func = wrapFunction(base::get() + 0x3823a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::removePendingCheckpoint() -> decltype(removePendingCheckpoint()) {
	using FunctionType = decltype(removePendingCheckpoint())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x38c400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::resetPlayerIcon() -> decltype(resetPlayerIcon()) {
	using FunctionType = decltype(resetPlayerIcon())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x385550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::resetStreak() -> decltype(resetStreak()) {
	using FunctionType = decltype(resetStreak())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x375870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::resetTouchedRings(bool p0) -> decltype(resetTouchedRings(p0)) {
	using FunctionType = decltype(resetTouchedRings(p0))(*)(PlayerObject*, bool);
	static auto func = wrapFunction(base::get() + 0x3824b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::reversePlayer(EffectGameObject* p0) -> decltype(reversePlayer(p0)) {
	using FunctionType = decltype(reversePlayer(p0))(*)(PlayerObject*, EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x382600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::ringJump(RingObject* p0, bool p1) -> decltype(ringJump(p0, p1)) {
	using FunctionType = decltype(ringJump(p0, p1))(*)(PlayerObject*, RingObject*, bool);
	static auto func = wrapFunction(base::get() + 0x382dd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::rotateGameplayObject(GameObject* p0) -> decltype(rotateGameplayObject(p0)) {
	using FunctionType = decltype(rotateGameplayObject(p0))(*)(PlayerObject*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x37b5c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void PlayerObject::rotateGameplayOnly(bool param) {
        m_isSideways = param;
        this->updatePlayerArt();
    }

auto PlayerObject::runBallRotation(float p0) -> decltype(runBallRotation(p0)) {
	using FunctionType = decltype(runBallRotation(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x377490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::runBallRotation2() -> decltype(runBallRotation2()) {
	using FunctionType = decltype(runBallRotation2())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x3776f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void PlayerObject::runNormalRotation() {
        this->runNormalRotation(false, 1.0f);
    }

auto PlayerObject::runNormalRotation(bool p0, float p1) -> decltype(runNormalRotation(p0, p1)) {
	throw std::runtime_error("PlayerObject::runNormalRotation not implemented");
}

auto PlayerObject::runRotateAction(bool p0, int p1) -> decltype(runRotateAction(p0, p1)) {
	using FunctionType = decltype(runRotateAction(p0, p1))(*)(PlayerObject*, bool, int);
	static auto func = wrapFunction(base::get() + 0x3775c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::setSecondColor(cocos2d::ccColor3B const& p0) -> decltype(setSecondColor(p0)) {
	using FunctionType = decltype(setSecondColor(p0))(*)(PlayerObject*, cocos2d::ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x387610, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::setupStreak() -> decltype(setupStreak()) {
	using FunctionType = decltype(setupStreak())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x372a50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::setYVelocity(double velocity, int p1) -> decltype(setYVelocity(velocity, p1)) {
	using FunctionType = decltype(setYVelocity(velocity, p1))(*)(PlayerObject*, double, int);
	static auto func = wrapFunction(base::get() + 0x372fa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, velocity, p1);
}

auto PlayerObject::spawnPortalCircle(cocos2d::ccColor3B p0, float p1) -> decltype(spawnPortalCircle(p0, p1)) {
	using FunctionType = decltype(spawnPortalCircle(p0, p1))(*)(PlayerObject*, cocos2d::ccColor3B, float);
	static auto func = wrapFunction(base::get() + 0x381930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::spiderTestJump(bool p0) -> decltype(spiderTestJump(p0)) {
	using FunctionType = decltype(spiderTestJump(p0))(*)(PlayerObject*, bool);
	static auto func = wrapFunction(base::get() + 0x37e510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::spiderTestJumpInternal(bool p0) -> decltype(spiderTestJumpInternal(p0)) {
	using FunctionType = decltype(spiderTestJumpInternal(p0))(*)(PlayerObject*, bool);
	static auto func = wrapFunction(base::get() + 0x37e5c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::startDashing(DashRingObject* p0) -> decltype(startDashing(p0)) {
	using FunctionType = decltype(startDashing(p0))(*)(PlayerObject*, DashRingObject*);
	static auto func = wrapFunction(base::get() + 0x37fae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::stopDashing() -> decltype(stopDashing()) {
	using FunctionType = decltype(stopDashing())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x380820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::stopParticles() -> decltype(stopParticles()) {
	using FunctionType = decltype(stopParticles())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x375af0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::stopPlatformerJumpAnimation() -> decltype(stopPlatformerJumpAnimation()) {
	using FunctionType = decltype(stopPlatformerJumpAnimation())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x3772d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::switchedDirTo(PlayerButton p0) -> decltype(switchedDirTo(p0)) {
	using FunctionType = decltype(switchedDirTo(p0))(*)(PlayerObject*, PlayerButton);
	static auto func = wrapFunction(base::get() + 0x382000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::switchedToMode(GameObjectType p0) -> decltype(switchedToMode(p0)) {
	using FunctionType = decltype(switchedToMode(p0))(*)(PlayerObject*, GameObjectType);
	static auto func = wrapFunction(base::get() + 0x3860a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::toggleBirdMode(bool p0, bool p1) -> decltype(toggleBirdMode(p0, p1)) {
	using FunctionType = decltype(toggleBirdMode(p0, p1))(*)(PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x384a90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::toggleDartMode(bool p0, bool p1) -> decltype(toggleDartMode(p0, p1)) {
	using FunctionType = decltype(toggleDartMode(p0, p1))(*)(PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x385200, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::toggleFlyMode(bool p0, bool p1) -> decltype(toggleFlyMode(p0, p1)) {
	using FunctionType = decltype(toggleFlyMode(p0, p1))(*)(PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x384760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::toggleGhostEffect(GhostType p0) -> decltype(toggleGhostEffect(p0)) {
	using FunctionType = decltype(toggleGhostEffect(p0))(*)(PlayerObject*, GhostType);
	static auto func = wrapFunction(base::get() + 0x3890a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void PlayerObject::togglePlatformerMode(bool val) {
        m_isPlatformer = val;
    }

auto PlayerObject::togglePlayerScale(bool p0, bool p1) -> decltype(togglePlayerScale(p0, p1)) {
	using FunctionType = decltype(togglePlayerScale(p0, p1))(*)(PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x38a970, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::toggleRobotMode(bool p0, bool p1) -> decltype(toggleRobotMode(p0, p1)) {
	using FunctionType = decltype(toggleRobotMode(p0, p1))(*)(PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x385960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::toggleRollMode(bool p0, bool p1) -> decltype(toggleRollMode(p0, p1)) {
	using FunctionType = decltype(toggleRollMode(p0, p1))(*)(PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x3857e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::toggleSpiderMode(bool p0, bool p1) -> decltype(toggleSpiderMode(p0, p1)) {
	using FunctionType = decltype(toggleSpiderMode(p0, p1))(*)(PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x385ce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::toggleSwingMode(bool p0, bool p1) -> decltype(toggleSwingMode(p0, p1)) {
	using FunctionType = decltype(toggleSwingMode(p0, p1))(*)(PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x384d90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::toggleVisibility(bool p0) -> decltype(toggleVisibility(p0)) {
	using FunctionType = decltype(toggleVisibility(p0))(*)(PlayerObject*, bool);
	static auto func = wrapFunction(base::get() + 0x3756d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::unrotateGameplayObject(GameObject* p0) -> decltype(unrotateGameplayObject(p0)) {
	using FunctionType = decltype(unrotateGameplayObject(p0))(*)(PlayerObject*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x37b8b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updateCollide(PlayerCollisionDirection p0, GameObject* p1) -> decltype(updateCollide(p0, p1)) {
	using FunctionType = decltype(updateCollide(p0, p1))(*)(PlayerObject*, PlayerCollisionDirection, GameObject*);
	static auto func = wrapFunction(base::get() + 0x37e1c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::updateDashArt() -> decltype(updateDashArt()) {
	using FunctionType = decltype(updateDashArt())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x380390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void PlayerObject::updateEffects(float param) {
        m_waveTrail->updateStroke(param);
    }

auto PlayerObject::updateGlowColor() -> decltype(updateGlowColor()) {
	using FunctionType = decltype(updateGlowColor())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x3876a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::updateInternalActions(float p0) -> decltype(updateInternalActions(p0)) {
	using FunctionType = decltype(updateInternalActions(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x38d0c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updateJump(float p0) -> decltype(updateJump(p0)) {
	using FunctionType = decltype(updateJump(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x375b90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updateMove(float p0) -> decltype(updateMove(p0)) {
	using FunctionType = decltype(updateMove(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x374350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updatePlayerArt() -> decltype(updatePlayerArt()) {
	using FunctionType = decltype(updatePlayerArt())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x382a30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::updatePlayerBirdFrame(int p0) -> decltype(updatePlayerBirdFrame(p0)) {
	using FunctionType = decltype(updatePlayerBirdFrame(p0))(*)(PlayerObject*, int);
	static auto func = wrapFunction(base::get() + 0x388550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updatePlayerDartFrame(int p0) -> decltype(updatePlayerDartFrame(p0)) {
	using FunctionType = decltype(updatePlayerDartFrame(p0))(*)(PlayerObject*, int);
	static auto func = wrapFunction(base::get() + 0x388c50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updatePlayerFrame(int p0) -> decltype(updatePlayerFrame(p0)) {
	using FunctionType = decltype(updatePlayerFrame(p0))(*)(PlayerObject*, int);
	static auto func = wrapFunction(base::get() + 0x387ec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updatePlayerGlow() -> decltype(updatePlayerGlow()) {
	using FunctionType = decltype(updatePlayerGlow())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x38a510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::updatePlayerJetpackFrame(int p0) -> decltype(updatePlayerJetpackFrame(p0)) {
	using FunctionType = decltype(updatePlayerJetpackFrame(p0))(*)(PlayerObject*, int);
	static auto func = wrapFunction(base::get() + 0x388320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void PlayerObject::updatePlayerRobotFrame(int id) {
        if (id < 1) id = 1;
        else if (id > 0x43) id = 0x44;

        createRobot(id);
    }

auto PlayerObject::updatePlayerRollFrame(int p0) -> decltype(updatePlayerRollFrame(p0)) {
	using FunctionType = decltype(updatePlayerRollFrame(p0))(*)(PlayerObject*, int);
	static auto func = wrapFunction(base::get() + 0x3887f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updatePlayerScale() -> decltype(updatePlayerScale()) {
	using FunctionType = decltype(updatePlayerScale())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x38a490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::updatePlayerShipFrame(int p0) -> decltype(updatePlayerShipFrame(p0)) {
	using FunctionType = decltype(updatePlayerShipFrame(p0))(*)(PlayerObject*, int);
	static auto func = wrapFunction(base::get() + 0x3880f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void PlayerObject::updatePlayerSpiderFrame(int id) {
        if (id < 1) id = 1;
        else if (id > 0x44) id = 0x45;

        createSpider(id);
    }

auto PlayerObject::updatePlayerSwingFrame(int p0) -> decltype(updatePlayerSwingFrame(p0)) {
	using FunctionType = decltype(updatePlayerSwingFrame(p0))(*)(PlayerObject*, int);
	static auto func = wrapFunction(base::get() + 0x388a20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updateRobotAnimationSpeed() -> decltype(updateRobotAnimationSpeed()) {
	using FunctionType = decltype(updateRobotAnimationSpeed())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x38b350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::updateRotation(float p0, float p1) -> decltype(updateRotation(p0, p1)) {
	using FunctionType = decltype(updateRotation(p0, p1))(*)(PlayerObject*, float, float);
	static auto func = wrapFunction(base::get() + 0x377370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::updateRotation(float p0) -> decltype(updateRotation(p0)) {
	using FunctionType = decltype(updateRotation(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x37b1f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updateShipRotation(float p0) -> decltype(updateShipRotation(p0)) {
	using FunctionType = decltype(updateShipRotation(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x37ae10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updateSwingFire() -> decltype(updateSwingFire()) {
	using FunctionType = decltype(updateSwingFire())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x385040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::updateTimeMod(float p0, bool p1) -> decltype(updateTimeMod(p0, p1)) {
	using FunctionType = decltype(updateTimeMod(p0, p1))(*)(PlayerObject*, float, bool);
	static auto func = wrapFunction(base::get() + 0x38afc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

PlayLayer::~PlayLayer() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x38e920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) PlayLayer(geode::CutoffConstructor, sizeof(PlayLayer));
	CCDestructor::lock(this) = true;
}

PlayLayer* PlayLayer::get() {
        return GameManager::get()->m_playLayer;
    }

auto PlayLayer::scene(GJGameLevel* level, bool useReplay, bool dontCreateObjects) -> decltype(scene(level, useReplay, dontCreateObjects)) {
	using FunctionType = decltype(scene(level, useReplay, dontCreateObjects))(*)(GJGameLevel*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x38ebc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(level, useReplay, dontCreateObjects);
}

auto PlayLayer::onEnterTransitionDidFinish() -> decltype(onEnterTransitionDidFinish()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayLayer::onEnterTransitionDidFinish), this);
	using FunctionType = decltype(onEnterTransitionDidFinish())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x3a4190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayLayer::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayLayer::onExit), this);
	using FunctionType = decltype(onExit())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x3a41c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayLayer::postUpdate(float p0) -> decltype(postUpdate(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&PlayLayer::postUpdate), this);
	using FunctionType = decltype(postUpdate(p0))(*)(PlayLayer*, float);
	static auto func = wrapFunction(base::get() + 0x39da60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::checkForEnd() -> decltype(checkForEnd()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayLayer::checkForEnd), this);
	using FunctionType = decltype(checkForEnd())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x39de30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayLayer::testTime() -> decltype(testTime()) {
	throw std::runtime_error("PlayLayer::testTime not implemented");
}

auto PlayLayer::updateVerifyDamage() -> decltype(updateVerifyDamage()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayLayer::updateVerifyDamage), this);
	using FunctionType = decltype(updateVerifyDamage())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x39e000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayLayer::updateAttemptTime(float p0) -> decltype(updateAttemptTime(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&PlayLayer::updateAttemptTime), this);
	using FunctionType = decltype(updateAttemptTime(p0))(*)(PlayLayer*, float);
	static auto func = wrapFunction(base::get() + 0x39e0f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::updateVisibility(float p0) -> decltype(updateVisibility(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&PlayLayer::updateVisibility), this);
	using FunctionType = decltype(updateVisibility(p0))(*)(PlayLayer*, float);
	static auto func = wrapFunction(base::get() + 0x3984e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::opacityForObject(GameObject* p0) -> decltype(opacityForObject(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GameObject*>::func(&PlayLayer::opacityForObject), this);
	using FunctionType = decltype(opacityForObject(p0))(*)(PlayLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x399410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::updateColor(cocos2d::ccColor3B& color, float fadeTime, int colorID, bool blending, float opacity, cocos2d::ccHSVValue& copyHSV, int colorIDToCopy, bool copyOpacity, EffectGameObject* callerObject, int unk1, int unk2) -> decltype(updateColor(color, fadeTime, colorID, blending, opacity, copyHSV, colorIDToCopy, copyOpacity, callerObject, unk1, unk2)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B&, float, int, bool, float, cocos2d::ccHSVValue&, int, bool, EffectGameObject*, int, int>::func(&PlayLayer::updateColor), this);
	using FunctionType = decltype(updateColor(color, fadeTime, colorID, blending, opacity, copyHSV, colorIDToCopy, copyOpacity, callerObject, unk1, unk2))(*)(PlayLayer*, cocos2d::ccColor3B&, float, int, bool, float, cocos2d::ccHSVValue&, int, bool, EffectGameObject*, int, int);
	static auto func = wrapFunction(base::get() + 0x39b0c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, color, fadeTime, colorID, blending, opacity, copyHSV, colorIDToCopy, copyOpacity, callerObject, unk1, unk2);
}

auto PlayLayer::activateEndTrigger(int p0, bool p1, bool p2) -> decltype(activateEndTrigger(p0, p1, p2)) {
	throw std::runtime_error("PlayLayer::activateEndTrigger not implemented");
}

auto PlayLayer::activatePlatformerEndTrigger(EndTriggerGameObject* p0, gd::vector<int> const& p1) -> decltype(activatePlatformerEndTrigger(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<EndTriggerGameObject*, gd::vector<int> const&>::func(&PlayLayer::activatePlatformerEndTrigger), this);
	using FunctionType = decltype(activatePlatformerEndTrigger(p0, p1))(*)(PlayLayer*, EndTriggerGameObject*, gd::vector<int> const&);
	static auto func = wrapFunction(base::get() + 0x395320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto PlayLayer::toggleGlitter(bool p0) -> decltype(toggleGlitter(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&PlayLayer::toggleGlitter), this);
	using FunctionType = decltype(toggleGlitter(p0))(*)(PlayLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x39c9d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::destroyPlayer(PlayerObject* p0, GameObject* p1) -> decltype(destroyPlayer(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<PlayerObject*, GameObject*>::func(&PlayLayer::destroyPlayer), this);
	using FunctionType = decltype(destroyPlayer(p0, p1))(*)(PlayLayer*, PlayerObject*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x39caf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto PlayLayer::toggleGroundVisibility(bool p0) -> decltype(toggleGroundVisibility(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&PlayLayer::toggleGroundVisibility), this);
	using FunctionType = decltype(toggleGroundVisibility(p0))(*)(PlayLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x39c820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::toggleMGVisibility(bool p0) -> decltype(toggleMGVisibility(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&PlayLayer::toggleMGVisibility), this);
	using FunctionType = decltype(toggleMGVisibility(p0))(*)(PlayLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x39c8a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::toggleHideAttempts(bool p0) -> decltype(toggleHideAttempts(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&PlayLayer::toggleHideAttempts), this);
	using FunctionType = decltype(toggleHideAttempts(p0))(*)(PlayLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x39c8e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::timeForPos(cocos2d::CCPoint p0, int p1, int p2, bool p3, int p4) -> decltype(timeForPos(p0, p1, p2, p3, p4)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint, int, int, bool, int>::func(&PlayLayer::timeForPos), this);
	using FunctionType = decltype(timeForPos(p0, p1, p2, p3, p4))(*)(PlayLayer*, cocos2d::CCPoint, int, int, bool, int);
	static auto func = wrapFunction(base::get() + 0x39c6f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3, p4);
}

auto PlayLayer::posForTime(float p0) -> decltype(posForTime(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&PlayLayer::posForTime), this);
	using FunctionType = decltype(posForTime(p0))(*)(PlayLayer*, float);
	static auto func = wrapFunction(base::get() + 0x39c780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::resetSPTriggered() -> decltype(resetSPTriggered()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayLayer::resetSPTriggered), this);
	using FunctionType = decltype(resetSPTriggered())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x39c7e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayLayer::updateTimeWarp(float p0) -> decltype(updateTimeWarp(p0)) {
	throw std::runtime_error("PlayLayer::updateTimeWarp not implemented");
}

auto PlayLayer::playGravityEffect(bool p0) -> decltype(playGravityEffect(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&PlayLayer::playGravityEffect), this);
	using FunctionType = decltype(playGravityEffect(p0))(*)(PlayLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x39b180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::manualUpdateObjectColors(GameObject* p0) -> decltype(manualUpdateObjectColors(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GameObject*>::func(&PlayLayer::manualUpdateObjectColors), this);
	using FunctionType = decltype(manualUpdateObjectColors(p0))(*)(PlayLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x399420, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::checkpointActivated(CheckpointGameObject* p0) -> decltype(checkpointActivated(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CheckpointGameObject*>::func(&PlayLayer::checkpointActivated), this);
	using FunctionType = decltype(checkpointActivated(p0))(*)(PlayLayer*, CheckpointGameObject*);
	static auto func = wrapFunction(base::get() + 0x39e130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::flipArt(bool p0) -> decltype(flipArt(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&PlayLayer::flipArt), this);
	using FunctionType = decltype(flipArt(p0))(*)(PlayLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x39bb60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::updateTimeLabel(int p0, int p1, bool p2) -> decltype(updateTimeLabel(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<int, int, bool>::func(&PlayLayer::updateTimeLabel), this);
	using FunctionType = decltype(updateTimeLabel(p0, p1, p2))(*)(PlayLayer*, int, int, bool);
	static auto func = wrapFunction(base::get() + 0x39b690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto PlayLayer::checkSnapshot() -> decltype(checkSnapshot()) {
	throw std::runtime_error("PlayLayer::checkSnapshot not implemented");
}

auto PlayLayer::toggleProgressbar() -> decltype(toggleProgressbar()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayLayer::toggleProgressbar), this);
	using FunctionType = decltype(toggleProgressbar())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x39b890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayLayer::toggleInfoLabel() -> decltype(toggleInfoLabel()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayLayer::toggleInfoLabel), this);
	using FunctionType = decltype(toggleInfoLabel())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x39c670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayLayer::removeAllCheckpoints() -> decltype(removeAllCheckpoints()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayLayer::removeAllCheckpoints), this);
	using FunctionType = decltype(removeAllCheckpoints())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x3a1130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayLayer::toggleMusicInPractice() -> decltype(toggleMusicInPractice()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayLayer::toggleMusicInPractice), this);
	using FunctionType = decltype(toggleMusicInPractice())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x39ba30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayLayer::currencyWillExit(CurrencyRewardLayer* p0) -> decltype(currencyWillExit(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CurrencyRewardLayer*>::func(&PlayLayer::currencyWillExit), this);
	using FunctionType = decltype(currencyWillExit(p0))(*)(PlayLayer*, CurrencyRewardLayer*);
	static auto func = wrapFunction(base::get() + 0x39d880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::circleWaveWillBeRemoved(CCCircleWave* p0) -> decltype(circleWaveWillBeRemoved(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCCircleWave*>::func(&PlayLayer::circleWaveWillBeRemoved), this);
	using FunctionType = decltype(circleWaveWillBeRemoved(p0))(*)(PlayLayer*, CCCircleWave*);
	static auto func = wrapFunction(base::get() + 0x39da40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DialogLayer*>::func(&PlayLayer::dialogClosed), this);
	using FunctionType = decltype(dialogClosed(p0))(*)(PlayLayer*, DialogLayer*);
	static auto func = wrapFunction(base::get() + 0x39d8a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

void PlayLayer::addCircle(CCCircleWave* cw) {
        m_circleWaveArray->addObject(cw);
    }

auto PlayLayer::addObject(GameObject* p0) -> decltype(addObject(p0)) {
	using FunctionType = decltype(addObject(p0))(*)(PlayLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x396eb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayLayer::applyCustomEnterEffect(GameObject* p0, bool p1) -> decltype(applyCustomEnterEffect(p0, p1)) {
	using FunctionType = decltype(applyCustomEnterEffect(p0, p1))(*)(PlayLayer*, GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x399aa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayLayer::applyEnterEffect(GameObject* p0, int p1, bool p2) -> decltype(applyEnterEffect(p0, p1, p2)) {
	using FunctionType = decltype(applyEnterEffect(p0, p1, p2))(*)(PlayLayer*, GameObject*, int, bool);
	static auto func = wrapFunction(base::get() + 0x39a790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

bool PlayLayer::canPauseGame() {
        return !m_hasCompletedLevel && !m_levelEndAnimationStarted;
    }

auto PlayLayer::createCheckpoint() -> decltype(createCheckpoint()) {
	using FunctionType = decltype(createCheckpoint())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x39e150, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::createObjectsFromSetupFinished() -> decltype(createObjectsFromSetupFinished()) {
	using FunctionType = decltype(createObjectsFromSetupFinished())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x396a10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::delayedResetLevel() -> decltype(delayedResetLevel()) {
	using FunctionType = decltype(delayedResetLevel())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x3a1de0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::fullReset() -> decltype(fullReset()) {
	using FunctionType = decltype(fullReset())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x3a1ce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::getCurrentPercent() -> decltype(getCurrentPercent()) {
	using FunctionType = decltype(getCurrentPercent())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x39ca70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

int PlayLayer::getCurrentPercentInt() { // i love this
        return static_cast<int>(this->getCurrentPercent());
    }

auto PlayLayer::getTempMilliTime() -> decltype(getTempMilliTime()) {
	using FunctionType = decltype(getTempMilliTime())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x3cef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::init(GJGameLevel* level, bool useReplay, bool dontCreateObjects) -> decltype(init(level, useReplay, dontCreateObjects)) {
	using FunctionType = decltype(init(level, useReplay, dontCreateObjects))(*)(PlayLayer*, GJGameLevel*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x38ec70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, level, useReplay, dontCreateObjects);
}

auto PlayLayer::levelComplete() -> decltype(levelComplete()) {
	using FunctionType = decltype(levelComplete())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x390c30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::loadDefaultColors() -> decltype(loadDefaultColors()) {
	using FunctionType = decltype(loadDefaultColors())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x39ad80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::loadFromCheckpoint(CheckpointObject* p0) -> decltype(loadFromCheckpoint(p0)) {
	using FunctionType = decltype(loadFromCheckpoint(p0))(*)(PlayLayer*, CheckpointObject*);
	static auto func = wrapFunction(base::get() + 0x3a07b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayLayer::markCheckpoint() -> decltype(markCheckpoint()) {
	using FunctionType = decltype(markCheckpoint())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x3a06e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::onQuit() -> decltype(onQuit()) {
	using FunctionType = decltype(onQuit())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x3a3db0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::optimizeColorGroups() -> decltype(optimizeColorGroups()) {
	using FunctionType = decltype(optimizeColorGroups())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x397d10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::optimizeOpacityGroups() -> decltype(optimizeOpacityGroups()) {
	using FunctionType = decltype(optimizeOpacityGroups())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x397fa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::pauseGame(bool p0) -> decltype(pauseGame(p0)) {
	using FunctionType = decltype(pauseGame(p0))(*)(PlayLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x3a31f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayLayer::playEndAnimationToPos(cocos2d::CCPoint p0) -> decltype(playEndAnimationToPos(p0)) {
	using FunctionType = decltype(playEndAnimationToPos(p0))(*)(PlayLayer*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x394aa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayLayer::playPlatformerEndAnimationToPos(cocos2d::CCPoint p0, bool p1) -> decltype(playPlatformerEndAnimationToPos(p0, p1)) {
	using FunctionType = decltype(playPlatformerEndAnimationToPos(p0, p1))(*)(PlayLayer*, cocos2d::CCPoint, bool);
	static auto func = wrapFunction(base::get() + 0x395430, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayLayer::prepareCreateObjectsFromSetup(gd::string& p0) -> decltype(prepareCreateObjectsFromSetup(p0)) {
	using FunctionType = decltype(prepareCreateObjectsFromSetup(p0))(*)(PlayLayer*, gd::string&);
	static auto func = wrapFunction(base::get() + 0x395f80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayLayer::processCreateObjectsFromSetup() -> decltype(processCreateObjectsFromSetup()) {
	using FunctionType = decltype(processCreateObjectsFromSetup())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x396230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::removeCheckpoint(bool p0) -> decltype(removeCheckpoint(p0)) {
	using FunctionType = decltype(removeCheckpoint(p0))(*)(PlayLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x3a0ff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayLayer::resetLevel() -> decltype(resetLevel()) {
	using FunctionType = decltype(resetLevel())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x3a1f90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::resetLevelFromStart() -> decltype(resetLevelFromStart()) {
	using FunctionType = decltype(resetLevelFromStart())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x3a1df0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::resume() -> decltype(resume()) {
	using FunctionType = decltype(resume())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x3a37c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::resumeAndRestart(bool p0) -> decltype(resumeAndRestart(p0)) {
	using FunctionType = decltype(resumeAndRestart(p0))(*)(PlayLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x3a34b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayLayer::scanDynamicSaveObjects() -> decltype(scanDynamicSaveObjects()) {
	using FunctionType = decltype(scanDynamicSaveObjects())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x3a1180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::setupHasCompleted() -> decltype(setupHasCompleted()) {
	using FunctionType = decltype(setupHasCompleted())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x38f9c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::showCompleteEffect() -> decltype(showCompleteEffect()) {
	using FunctionType = decltype(showCompleteEffect())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x391fd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::showCompleteText() -> decltype(showCompleteText()) {
	using FunctionType = decltype(showCompleteText())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x3919a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::showHint() -> decltype(showHint()) {
	using FunctionType = decltype(showHint())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x39d8c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::showNewBest(bool p0, int p1, int p2, bool p3, bool p4, bool p5) -> decltype(showNewBest(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(showNewBest(p0, p1, p2, p3, p4, p5))(*)(PlayLayer*, bool, int, int, bool, bool, bool);
	static auto func = wrapFunction(base::get() + 0x3925f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto PlayLayer::startGame() -> decltype(startGame()) {
	using FunctionType = decltype(startGame())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x390bd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::startMusic() -> decltype(startMusic()) {
	using FunctionType = decltype(startMusic())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x3a3c60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::storeCheckpoint(CheckpointObject* p0) -> decltype(storeCheckpoint(p0)) {
	using FunctionType = decltype(storeCheckpoint(p0))(*)(PlayLayer*, CheckpointObject*);
	static auto func = wrapFunction(base::get() + 0x3a0610, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayLayer::togglePracticeMode(bool practiceMode) -> decltype(togglePracticeMode(practiceMode)) {
	using FunctionType = decltype(togglePracticeMode(practiceMode))(*)(PlayLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x3a2f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, practiceMode);
}

auto PlayLayer::updateAttempts() -> decltype(updateAttempts()) {
	using FunctionType = decltype(updateAttempts())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x3a2c70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::updateInfoLabel() -> decltype(updateInfoLabel()) {
	using FunctionType = decltype(updateInfoLabel())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x39bb90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::updateProgressbar() -> decltype(updateProgressbar()) {
	using FunctionType = decltype(updateProgressbar())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x39b4f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::updateTestModeLabel() -> decltype(updateTestModeLabel()) {
	using FunctionType = decltype(updateTestModeLabel())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x390b40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::updateTimeWarp(EffectGameObject* p0, float p1) -> decltype(updateTimeWarp(p0, p1)) {
	using FunctionType = decltype(updateTimeWarp(p0, p1))(*)(PlayLayer*, EffectGameObject*, float);
	static auto func = wrapFunction(base::get() + 0x394a40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto UserInfoDelegate::getUserInfoFinished(GJUserScore* p0) -> decltype(getUserInfoFinished(p0)) {
	throw std::runtime_error("UserInfoDelegate::getUserInfoFinished not implemented");
}

auto UserInfoDelegate::getUserInfoFailed(int p0) -> decltype(getUserInfoFailed(p0)) {
	throw std::runtime_error("UserInfoDelegate::getUserInfoFailed not implemented");
}

auto UserInfoDelegate::userInfoChanged(GJUserScore* p0) -> decltype(userInfoChanged(p0)) {
	throw std::runtime_error("UserInfoDelegate::userInfoChanged not implemented");
}

auto ProfilePage::create(int accountID, bool ownProfile) -> decltype(create(accountID, ownProfile)) {
	using FunctionType = decltype(create(accountID, ownProfile))(*)(int, bool);
	static auto func = wrapFunction(base::get() + 0x3a7a20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(accountID, ownProfile);
}

auto ProfilePage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("ProfilePage::registerWithTouchDispatcher not implemented");
}

auto ProfilePage::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ProfilePage::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(ProfilePage*);
	static auto func = wrapFunction(base::get() + 0x3ae050, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ProfilePage::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ProfilePage::show), this);
	using FunctionType = decltype(show())(*)(ProfilePage*);
	static auto func = wrapFunction(base::get() + 0x3ae2e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ProfilePage::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&ProfilePage::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(ProfilePage*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x3ada20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ProfilePage::updateUserScoreFinished() -> decltype(updateUserScoreFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ProfilePage::updateUserScoreFinished), this);
	using FunctionType = decltype(updateUserScoreFinished())(*)(ProfilePage*);
	static auto func = wrapFunction(base::get() + 0x3ae1a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ProfilePage::updateUserScoreFailed() -> decltype(updateUserScoreFailed()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ProfilePage::updateUserScoreFailed), this);
	using FunctionType = decltype(updateUserScoreFailed())(*)(ProfilePage*);
	static auto func = wrapFunction(base::get() + 0x3ae290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ProfilePage::getUserInfoFinished(GJUserScore* p0) -> decltype(getUserInfoFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJUserScore*>::func(&ProfilePage::getUserInfoFinished), this);
	using FunctionType = decltype(getUserInfoFinished(p0))(*)(ProfilePage*, GJUserScore*);
	static auto func = wrapFunction(base::get() + 0x3aeb40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ProfilePage::getUserInfoFailed(int p0) -> decltype(getUserInfoFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&ProfilePage::getUserInfoFailed), this);
	using FunctionType = decltype(getUserInfoFailed(p0))(*)(ProfilePage*, int);
	static auto func = wrapFunction(base::get() + 0x3aec30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ProfilePage::userInfoChanged(GJUserScore* p0) -> decltype(userInfoChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJUserScore*>::func(&ProfilePage::userInfoChanged), this);
	using FunctionType = decltype(userInfoChanged(p0))(*)(ProfilePage*, GJUserScore*);
	static auto func = wrapFunction(base::get() + 0x3aec80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ProfilePage::loadCommentsFinished(cocos2d::CCArray* p0, char const* p1) -> decltype(loadCommentsFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*, char const*>::func(&ProfilePage::loadCommentsFinished), this);
	using FunctionType = decltype(loadCommentsFinished(p0, p1))(*)(ProfilePage*, cocos2d::CCArray*, char const*);
	static auto func = wrapFunction(base::get() + 0x3af270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ProfilePage::loadCommentsFailed(char const* p0) -> decltype(loadCommentsFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&ProfilePage::loadCommentsFailed), this);
	using FunctionType = decltype(loadCommentsFailed(p0))(*)(ProfilePage*, char const*);
	static auto func = wrapFunction(base::get() + 0x3af2f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ProfilePage::setupPageInfo(gd::string p0, char const* p1) -> decltype(setupPageInfo(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string, char const*>::func(&ProfilePage::setupPageInfo), this);
	using FunctionType = decltype(setupPageInfo(p0, p1))(*)(ProfilePage*, gd::string, char const*);
	static auto func = wrapFunction(base::get() + 0x3af350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ProfilePage::commentUploadFinished(int p0) -> decltype(commentUploadFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&ProfilePage::commentUploadFinished), this);
	using FunctionType = decltype(commentUploadFinished(p0))(*)(ProfilePage*, int);
	static auto func = wrapFunction(base::get() + 0x3af550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ProfilePage::commentUploadFailed(int p0, CommentError p1) -> decltype(commentUploadFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, CommentError>::func(&ProfilePage::commentUploadFailed), this);
	using FunctionType = decltype(commentUploadFailed(p0, p1))(*)(ProfilePage*, int, CommentError);
	static auto func = wrapFunction(base::get() + 0x3af5a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ProfilePage::commentDeleteFailed(int p0, int p1) -> decltype(commentDeleteFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&ProfilePage::commentDeleteFailed), this);
	using FunctionType = decltype(commentDeleteFailed(p0, p1))(*)(ProfilePage*, int, int);
	static auto func = wrapFunction(base::get() + 0x3af6c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ProfilePage::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&ProfilePage::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(ProfilePage*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x3add10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ProfilePage::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&ProfilePage::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(p0, p1))(*)(ProfilePage*, int, int);
	static auto func = wrapFunction(base::get() + 0x3add60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ProfilePage::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&ProfilePage::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(p0, p1))(*)(ProfilePage*, int, int);
	static auto func = wrapFunction(base::get() + 0x3adf20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ProfilePage::init(int accountID, bool ownProfile) -> decltype(init(accountID, ownProfile)) {
	using FunctionType = decltype(init(accountID, ownProfile))(*)(ProfilePage*, int, bool);
	static auto func = wrapFunction(base::get() + 0x3a7c00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, accountID, ownProfile);
}

auto ProfilePage::loadPage(int p0) -> decltype(loadPage(p0)) {
	using FunctionType = decltype(loadPage(p0))(*)(ProfilePage*, int);
	static auto func = wrapFunction(base::get() + 0x3aee30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ProfilePage::loadPageFromUserInfo(GJUserScore* p0) -> decltype(loadPageFromUserInfo(p0)) {
	using FunctionType = decltype(loadPageFromUserInfo(p0))(*)(ProfilePage*, GJUserScore*);
	static auto func = wrapFunction(base::get() + 0x3a9240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ProfilePage::onBlockUser(cocos2d::CCObject* sender) -> decltype(onBlockUser(sender)) {
	using FunctionType = decltype(onBlockUser(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3ad200, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3adfd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onComment(cocos2d::CCObject* sender) -> decltype(onComment(sender)) {
	using FunctionType = decltype(onComment(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3acc50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onCommentHistory(cocos2d::CCObject* sender) -> decltype(onCommentHistory(sender)) {
	using FunctionType = decltype(onCommentHistory(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3acbc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onCopyName(cocos2d::CCObject* sender) -> decltype(onCopyName(sender)) {
	using FunctionType = decltype(onCopyName(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3ac290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onFollow(cocos2d::CCObject* sender) -> decltype(onFollow(sender)) {
	using FunctionType = decltype(onFollow(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3ad450, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onFriend(cocos2d::CCObject* sender) -> decltype(onFriend(sender)) {
	using FunctionType = decltype(onFriend(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3ace10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onFriends(cocos2d::CCObject* sender) -> decltype(onFriends(sender)) {
	using FunctionType = decltype(onFriends(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3aeae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onMessages(cocos2d::CCObject* sender) -> decltype(onMessages(sender)) {
	using FunctionType = decltype(onMessages(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3aeab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onMyLevels(cocos2d::CCObject* sender) -> decltype(onMyLevels(sender)) {
	using FunctionType = decltype(onMyLevels(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3ac8b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onMyLists(cocos2d::CCObject* sender) -> decltype(onMyLists(sender)) {
	using FunctionType = decltype(onMyLists(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3aca60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onNextPage(cocos2d::CCObject* sender) -> decltype(onNextPage(sender)) {
	using FunctionType = decltype(onNextPage(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3af530, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onPrevPage(cocos2d::CCObject* sender) -> decltype(onPrevPage(sender)) {
	using FunctionType = decltype(onPrevPage(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3af540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onRequests(cocos2d::CCObject* sender) -> decltype(onRequests(sender)) {
	using FunctionType = decltype(onRequests(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3aeb10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onSendMessage(cocos2d::CCObject* sender) -> decltype(onSendMessage(sender)) {
	using FunctionType = decltype(onSendMessage(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3acc00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onSettings(cocos2d::CCObject* sender) -> decltype(onSettings(sender)) {
	using FunctionType = decltype(onSettings(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3ae900, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onStatInfo(cocos2d::CCObject* sender) -> decltype(onStatInfo(sender)) {
	using FunctionType = decltype(onStatInfo(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3ac0c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onTwitch(cocos2d::CCObject* sender) -> decltype(onTwitch(sender)) {
	using FunctionType = decltype(onTwitch(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3ae760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onTwitter(cocos2d::CCObject* sender) -> decltype(onTwitter(sender)) {
	using FunctionType = decltype(onTwitter(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3ae5d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onYouTube(cocos2d::CCObject* sender) -> decltype(onYouTube(sender)) {
	using FunctionType = decltype(onYouTube(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3ae440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::setupCommentsBrowser(cocos2d::CCArray* p0) -> decltype(setupCommentsBrowser(p0)) {
	using FunctionType = decltype(setupCommentsBrowser(p0))(*)(ProfilePage*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x3af120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ProfilePage::showNoAccountError() -> decltype(showNoAccountError()) {
	using FunctionType = decltype(showNoAccountError())(*)(ProfilePage*);
	static auto func = wrapFunction(base::get() + 0x3ae060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ProfilePage::toggleShip(cocos2d::CCObject* sender) -> decltype(toggleShip(sender)) {
	using FunctionType = decltype(toggleShip(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3ac010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::updatePageArrows() -> decltype(updatePageArrows()) {
	using FunctionType = decltype(updatePageArrows())(*)(ProfilePage*);
	static auto func = wrapFunction(base::get() + 0x3af4c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PromoInterstitial::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	throw std::runtime_error("PromoInterstitial::ccTouchBegan not implemented");
}

auto PromoInterstitial::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	throw std::runtime_error("PromoInterstitial::ccTouchMoved not implemented");
}

auto PromoInterstitial::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	throw std::runtime_error("PromoInterstitial::ccTouchEnded not implemented");
}

auto PromoInterstitial::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	throw std::runtime_error("PromoInterstitial::ccTouchCancelled not implemented");
}

auto PromoInterstitial::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("PromoInterstitial::keyBackClicked not implemented");
}

auto PromoInterstitial::show() -> decltype(show()) {
	throw std::runtime_error("PromoInterstitial::show not implemented");
}

auto PurchaseItemPopup::create(GJStoreItem* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(GJStoreItem*);
	static auto func = wrapFunction(base::get() + 0x2a74d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto PurchaseItemPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("PurchaseItemPopup::keyBackClicked not implemented");
}

auto PurchaseItemPopup::init(GJStoreItem* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(PurchaseItemPopup*, GJStoreItem*);
	static auto func = wrapFunction(base::get() + 0x2a75c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PurchaseItemPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(PurchaseItemPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x84620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto PurchaseItemPopup::onPurchase(cocos2d::CCObject* sender) -> decltype(onPurchase(sender)) {
	using FunctionType = decltype(onPurchase(sender))(*)(PurchaseItemPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2a8470, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto RandTriggerGameObject::init() -> decltype(init()) {
	throw std::runtime_error("RandTriggerGameObject::init not implemented");
}

auto RandTriggerGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	throw std::runtime_error("RandTriggerGameObject::triggerObject not implemented");
}

auto RandTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("RandTriggerGameObject::customObjectSetup not implemented");
}

auto RandTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("RandTriggerGameObject::getSaveString not implemented");
}

RateDemonLayer::RateDemonLayer() {
        m_uploadFinished = false;
        m_submitButton = nullptr;
        m_demons = nullptr;
        m_unkPtr = nullptr;
        m_levelID = 0;
        m_demonRate = 0;
        m_moderator = false;
        m_popup = nullptr;
        m_delegate = nullptr;
    }

RateDemonLayer* RateDemonLayer::create(int levelID) {
        auto ret = new RateDemonLayer();
        if (ret->init(levelID)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto RateDemonLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RateDemonLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(RateDemonLayer*);
	static auto func = wrapFunction(base::get() + 0x3b22a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RateDemonLayer::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&RateDemonLayer::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(p0, p1))(*)(RateDemonLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x3b2080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto RateDemonLayer::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&RateDemonLayer::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(p0, p1))(*)(RateDemonLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x3b2110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto RateDemonLayer::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&RateDemonLayer::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(RateDemonLayer*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x3b21e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto RateDemonLayer::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(RateDemonLayer*, int);
	static auto func = wrapFunction(base::get() + 0x3b1790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto RateDemonLayer::onRate(cocos2d::CCObject* sender) -> decltype(onRate(sender)) {
	using FunctionType = decltype(onRate(sender))(*)(RateDemonLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3b1ee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto RateDemonLayer::selectRating(cocos2d::CCObject* p0) -> decltype(selectRating(p0)) {
	using FunctionType = decltype(selectRating(p0))(*)(RateDemonLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3b1d60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

RateLevelLayer::RateLevelLayer() {
        m_submitButton = nullptr;
        m_difficulties = nullptr;
        m_levelID = 0;
        m_levelRate = 0;
        m_delegate = nullptr;
    }

RateLevelLayer* RateLevelLayer::create(int levelID) {
        auto ret = new RateLevelLayer();
        if (ret->init(levelID)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto RateLevelLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RateLevelLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(RateLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x3b2ab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RateLevelLayer::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(RateLevelLayer*, int);
	static auto func = wrapFunction(base::get() + 0x3b23c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto RateLevelLayer::onRate(cocos2d::CCObject* sender) -> decltype(onRate(sender)) {
	using FunctionType = decltype(onRate(sender))(*)(RateLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3b2a20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto RateLevelLayer::selectRating(cocos2d::CCObject* sender) -> decltype(selectRating(sender)) {
	using FunctionType = decltype(selectRating(sender))(*)(RateLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3b28d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto RateStarsLayer::create(int p0, bool p1, bool p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(int, bool, bool);
	static auto func = wrapFunction(base::get() + 0x3b2c40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto RateStarsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RateStarsLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(RateStarsLayer*);
	static auto func = wrapFunction(base::get() + 0x3b3b90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RateStarsLayer::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&RateStarsLayer::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(p0, p1))(*)(RateStarsLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x3b3990, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto RateStarsLayer::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&RateStarsLayer::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(p0, p1))(*)(RateStarsLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x3b3a10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto RateStarsLayer::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&RateStarsLayer::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(RateStarsLayer*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x3b3ad0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto RateStarsLayer::getStarsButton(int p0, cocos2d::SEL_MenuHandler p1, cocos2d::CCMenu* p2, float p3) -> decltype(getStarsButton(p0, p1, p2, p3)) {
	using FunctionType = decltype(getStarsButton(p0, p1, p2, p3))(*)(RateStarsLayer*, int, cocos2d::SEL_MenuHandler, cocos2d::CCMenu*, float);
	static auto func = wrapFunction(base::get() + 0x3b3470, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto RateStarsLayer::init(int p0, bool p1, bool p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(RateStarsLayer*, int, bool, bool);
	static auto func = wrapFunction(base::get() + 0x3b2d90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto RateStarsLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(RateStarsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3b3b50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto RateStarsLayer::onFeature(cocos2d::CCObject* sender) -> decltype(onFeature(sender)) {
	using FunctionType = decltype(onFeature(sender))(*)(RateStarsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3b3440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto RateStarsLayer::onRate(cocos2d::CCObject* sender) -> decltype(onRate(sender)) {
	using FunctionType = decltype(onRate(sender))(*)(RateStarsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3b37a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto RateStarsLayer::selectRating(cocos2d::CCObject* p0) -> decltype(selectRating(p0)) {
	using FunctionType = decltype(selectRating(p0))(*)(RateStarsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3b35b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto RetryLevelLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x3959c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto RetryLevelLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RetryLevelLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(RetryLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x3b4c40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RetryLevelLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&RetryLevelLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(RetryLevelLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x3b4ad0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto RetryLevelLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RetryLevelLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(RetryLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x3b3d00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RetryLevelLayer::showLayer(bool p0) -> decltype(showLayer(p0)) {
	throw std::runtime_error("RetryLevelLayer::showLayer not implemented");
}

auto RetryLevelLayer::enterAnimFinished() -> decltype(enterAnimFinished()) {
	throw std::runtime_error("RetryLevelLayer::enterAnimFinished not implemented");
}

auto RetryLevelLayer::rewardedVideoFinished() -> decltype(rewardedVideoFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RetryLevelLayer::rewardedVideoFinished), this);
	using FunctionType = decltype(rewardedVideoFinished())(*)(RetryLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x3b4a00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RetryLevelLayer::shouldOffsetRewardCurrency() -> decltype(shouldOffsetRewardCurrency()) {
	throw std::runtime_error("RetryLevelLayer::shouldOffsetRewardCurrency not implemented");
}

void RetryLevelLayer::keyUp(cocos2d::enumKeyCodes p0) {}

auto RetryLevelLayer::onMenu(cocos2d::CCObject* sender) -> decltype(onMenu(sender)) {
	using FunctionType = decltype(onMenu(sender))(*)(RetryLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3b4b20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto RetryLevelLayer::setupLastProgress() -> decltype(setupLastProgress()) {
	using FunctionType = decltype(setupLastProgress())(*)(RetryLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x3b4460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

RewardsPage::RewardsPage() {
        m_leftLabel = nullptr;
        m_rightLabel = nullptr;
        m_leftChest = nullptr;
        m_rightChest = nullptr;
        m_leftOpen = false;
        m_rightOpen = false;
        m_openLayer = nullptr;
    }

RewardsPage* RewardsPage::create() {
        auto ret = new RewardsPage();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

char const* RewardsPage::getRewardFrame(int type, int state) {
        return cocos2d::CCString::createWithFormat("chest_%02d_%02d_001.png", type, state)->getCString();
    }

auto RewardsPage::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RewardsPage::init), this);
	using FunctionType = decltype(init())(*)(RewardsPage*);
	static auto func = wrapFunction(base::get() + 0x3b5120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RewardsPage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RewardsPage::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(RewardsPage*);
	static auto func = wrapFunction(base::get() + 0x425d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RewardsPage::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RewardsPage::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(RewardsPage*);
	static auto func = wrapFunction(base::get() + 0x84650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RewardsPage::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RewardsPage::show), this);
	using FunctionType = decltype(show())(*)(RewardsPage*);
	static auto func = wrapFunction(base::get() + 0x3ae2e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void RewardsPage::FLAlert_Clicked(FLAlertLayer* p0, bool p1) {}

auto RewardsPage::rewardsStatusFinished(int p0) -> decltype(rewardsStatusFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&RewardsPage::rewardsStatusFinished), this);
	using FunctionType = decltype(rewardsStatusFinished(p0))(*)(RewardsPage*, int);
	static auto func = wrapFunction(base::get() + 0x3b6120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto RewardsPage::rewardsStatusFailed() -> decltype(rewardsStatusFailed()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RewardsPage::rewardsStatusFailed), this);
	using FunctionType = decltype(rewardsStatusFailed())(*)(RewardsPage*);
	static auto func = wrapFunction(base::get() + 0x3b6370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RewardsPage::onFreeStuff(cocos2d::CCObject* sender) -> decltype(onFreeStuff(sender)) {
	using FunctionType = decltype(onFreeStuff(sender))(*)(RewardsPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3b6920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto RewardsPage::onReward(cocos2d::CCObject* sender) -> decltype(onReward(sender)) {
	using FunctionType = decltype(onReward(sender))(*)(RewardsPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3b5fe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

void RewardsPage::unlockLayerClosed(RewardUnlockLayer* layer) {
        if (m_openLayer == layer) m_openLayer = nullptr;
    }

auto RewardUnlockLayer::create(int p0, RewardsPage* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(int, RewardsPage*);
	static auto func = wrapFunction(base::get() + 0x3b6950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

void RewardUnlockLayer::keyBackClicked() {}

auto RewardUnlockLayer::currencyWillExit(CurrencyRewardLayer* p0) -> decltype(currencyWillExit(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CurrencyRewardLayer*>::func(&RewardUnlockLayer::currencyWillExit), this);
	using FunctionType = decltype(currencyWillExit(p0))(*)(RewardUnlockLayer*, CurrencyRewardLayer*);
	static auto func = wrapFunction(base::get() + 0x3ba210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto RewardUnlockLayer::connectionTimeout() -> decltype(connectionTimeout()) {
	using FunctionType = decltype(connectionTimeout())(*)(RewardUnlockLayer*);
	static auto func = wrapFunction(base::get() + 0x3b7850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void RewardUnlockLayer::labelEnterFinishedO(cocos2d::CCObject* p0) {}

auto RewardUnlockLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(RewardUnlockLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3ba220, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto RewardUnlockLayer::playDropSound() -> decltype(playDropSound()) {
	using FunctionType = decltype(playDropSound())(*)(RewardUnlockLayer*);
	static auto func = wrapFunction(base::get() + 0x3b78b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

bool RewardUnlockLayer::readyToCollect(GJRewardItem* item) {
        return item ? m_chestType == (int)item->m_rewardType : false;
    }

auto RewardUnlockLayer::showCollectReward(GJRewardItem* p0) -> decltype(showCollectReward(p0)) {
	using FunctionType = decltype(showCollectReward(p0))(*)(RewardUnlockLayer*, GJRewardItem*);
	static auto func = wrapFunction(base::get() + 0x3b7790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto RewardUnlockLayer::step2() -> decltype(step2()) {
	using FunctionType = decltype(step2())(*)(RewardUnlockLayer*);
	static auto func = wrapFunction(base::get() + 0x3b7950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto RewardUnlockLayer::step3() -> decltype(step3()) {
	using FunctionType = decltype(step3())(*)(RewardUnlockLayer*);
	static auto func = wrapFunction(base::get() + 0x3b7a50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto RotateGameplayGameObject::init() -> decltype(init()) {
	throw std::runtime_error("RotateGameplayGameObject::init not implemented");
}

auto RotateGameplayGameObject::updateStartValues() -> decltype(updateStartValues()) {
	throw std::runtime_error("RotateGameplayGameObject::updateStartValues not implemented");
}

auto RotateGameplayGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("RotateGameplayGameObject::customObjectSetup not implemented");
}

auto RotateGameplayGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("RotateGameplayGameObject::getSaveString not implemented");
}

auto ScrollingLayer::draw() -> decltype(draw()) {
	throw std::runtime_error("ScrollingLayer::draw not implemented");
}

auto ScrollingLayer::visit() -> decltype(visit()) {
	throw std::runtime_error("ScrollingLayer::visit not implemented");
}

auto ScrollingLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&ScrollingLayer::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(ScrollingLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x70ff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ScrollingLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&ScrollingLayer::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(ScrollingLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x710e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ScrollingLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&ScrollingLayer::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(ScrollingLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x711f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ScrollingLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	throw std::runtime_error("ScrollingLayer::ccTouchCancelled not implemented");
}

auto SearchButton::create(char const* p0, char const* p1, float p2, char const* p3) -> decltype(create(p0, p1, p2, p3)) {
	using FunctionType = decltype(create(p0, p1, p2, p3))(*)(char const*, char const*, float, char const*);
	static auto func = wrapFunction(base::get() + 0x2fdcd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3);
}

auto SearchButton::init(char const* p0, char const* p1, float p2, char const* p3) -> decltype(init(p0, p1, p2, p3)) {
	using FunctionType = decltype(init(p0, p1, p2, p3))(*)(SearchButton*, char const*, char const*, float, char const*);
	static auto func = wrapFunction(base::get() + 0x2fdda0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto SetTextPopup::create(gd::string value, gd::string placeholder, int maxLength, gd::string title, gd::string okBtnText, bool showResetBtn, float p6) -> decltype(create(value, placeholder, maxLength, title, okBtnText, showResetBtn, p6)) {
	using FunctionType = decltype(create(value, placeholder, maxLength, title, okBtnText, showResetBtn, p6))(*)(gd::string, gd::string, int, gd::string, gd::string, bool, float);
	static auto func = wrapFunction(base::get() + 0x2957d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(value, placeholder, maxLength, title, okBtnText, showResetBtn, p6);
}

auto SetTextPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetTextPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SetTextPopup*);
	static auto func = wrapFunction(base::get() + 0x296490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetTextPopup::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetTextPopup::show), this);
	using FunctionType = decltype(show())(*)(SetTextPopup*);
	static auto func = wrapFunction(base::get() + 0x8ba30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetTextPopup::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	throw std::runtime_error("SetTextPopup::textInputClosed not implemented");
}

auto SetTextPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetTextPopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetTextPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x296280, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetTextPopup::init(gd::string p0, gd::string p1, int p2, gd::string p3, gd::string p4, bool p5, float p6) -> decltype(init(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5, p6))(*)(SetTextPopup*, gd::string, gd::string, int, gd::string, gd::string, bool, float);
	static auto func = wrapFunction(base::get() + 0x295940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6);
}

auto SetTextPopup::onCancel(cocos2d::CCObject* sender) -> decltype(onCancel(sender)) {
	using FunctionType = decltype(onCancel(sender))(*)(SetTextPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x296370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetTextPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SetTextPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x296400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetTextPopup::onResetValue(cocos2d::CCObject* sender) -> decltype(onResetValue(sender)) {
	using FunctionType = decltype(onResetValue(sender))(*)(SetTextPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x296220, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

void SetTextPopup::updateTextInputLabel() {
        m_disableDelegate = true;
        m_input->setString(m_value);
        m_disableDelegate = false;
    }

auto SecretGame01Layer::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("SecretGame01Layer::update not implemented");
}

auto SecretGame01Layer::init() -> decltype(init()) {
	throw std::runtime_error("SecretGame01Layer::init not implemented");
}

auto SecretLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretLayer::init), this);
	using FunctionType = decltype(init())(*)(SecretLayer*);
	static auto func = wrapFunction(base::get() + 0x3c5700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SecretLayer*);
	static auto func = wrapFunction(base::get() + 0x3cabb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretLayer::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SecretLayer::textInputOpened), this);
	using FunctionType = decltype(textInputOpened(p0))(*)(SecretLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x3c84b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SecretLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SecretLayer::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(SecretLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x3c8600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SecretLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("SecretLayer::textChanged not implemented");
}

void SecretLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) {}

auto SecretLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	using FunctionType = decltype(onBack(sender))(*)(SecretLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3cab10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SecretLayer::onSubmit(cocos2d::CCObject* sender) -> decltype(onSubmit(sender)) {
	using FunctionType = decltype(onSubmit(sender))(*)(SecretLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3c6a40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SecretLayer2::scene() -> decltype(scene()) {
	using FunctionType = decltype(scene())(*)();
	static auto func = wrapFunction(base::get() + 0x3cadf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto SecretLayer2::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretLayer2::init), this);
	using FunctionType = decltype(init())(*)(SecretLayer2*);
	static auto func = wrapFunction(base::get() + 0x3caf70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretLayer2::onExit() -> decltype(onExit()) {
	throw std::runtime_error("SecretLayer2::onExit not implemented");
}

auto SecretLayer2::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretLayer2::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SecretLayer2*);
	static auto func = wrapFunction(base::get() + 0x3d2590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretLayer2::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SecretLayer2::textInputOpened), this);
	using FunctionType = decltype(textInputOpened(p0))(*)(SecretLayer2*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x3cfa10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SecretLayer2::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SecretLayer2::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(SecretLayer2*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x3cfb60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SecretLayer2::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("SecretLayer2::textChanged not implemented");
}

void SecretLayer2::FLAlert_Clicked(FLAlertLayer* p0, bool p1) {}

auto SecretLayer2::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DialogLayer*>::func(&SecretLayer2::dialogClosed), this);
	using FunctionType = decltype(dialogClosed(p0))(*)(SecretLayer2*, DialogLayer*);
	static auto func = wrapFunction(base::get() + 0x3cd250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SecretLayer2::getBasicMessage() -> decltype(getBasicMessage()) {
	using FunctionType = decltype(getBasicMessage())(*)(SecretLayer2*);
	static auto func = wrapFunction(base::get() + 0x3d0880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SecretLayer2::getErrorMessage() -> decltype(getErrorMessage()) {
	using FunctionType = decltype(getErrorMessage())(*)(SecretLayer2*);
	static auto func = wrapFunction(base::get() + 0x3d13e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SecretLayer2::getMessage() -> decltype(getMessage()) {
	using FunctionType = decltype(getMessage())(*)(SecretLayer2*);
	static auto func = wrapFunction(base::get() + 0x3cffb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SecretLayer2::getThreadMessage() -> decltype(getThreadMessage()) {
	using FunctionType = decltype(getThreadMessage())(*)(SecretLayer2*);
	static auto func = wrapFunction(base::get() + 0x3d0190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SecretLayer2::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	using FunctionType = decltype(onBack(sender))(*)(SecretLayer2*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3d24e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SecretLayer2::onDoor(cocos2d::CCObject* sender) -> decltype(onDoor(sender)) {
	using FunctionType = decltype(onDoor(sender))(*)(SecretLayer2*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3cd5a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SecretLayer2::onSecretLevel(cocos2d::CCObject* sender) -> decltype(onSecretLevel(sender)) {
	using FunctionType = decltype(onSecretLevel(sender))(*)(SecretLayer2*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3cd2f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SecretLayer2::onSubmit(cocos2d::CCObject* sender) -> decltype(onSubmit(sender)) {
	using FunctionType = decltype(onSubmit(sender))(*)(SecretLayer2*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3cdf00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SecretLayer2::showCompletedLevel() -> decltype(showCompletedLevel()) {
	using FunctionType = decltype(showCompletedLevel())(*)(SecretLayer2*);
	static auto func = wrapFunction(base::get() + 0x3cc5a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SecretLayer2::showSecretLevel() -> decltype(showSecretLevel()) {
	using FunctionType = decltype(showSecretLevel())(*)(SecretLayer2*);
	static auto func = wrapFunction(base::get() + 0x3cc430, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SecretLayer2::updateMessageLabel(gd::string text) -> decltype(updateMessageLabel(text)) {
	using FunctionType = decltype(updateMessageLabel(text))(*)(SecretLayer2*, gd::string);
	static auto func = wrapFunction(base::get() + 0x3cff20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, text);
}

auto SecretLayer2::updateSearchLabel(char const* p0) -> decltype(updateSearchLabel(p0)) {
	using FunctionType = decltype(updateSearchLabel(p0))(*)(SecretLayer2*, char const*);
	static auto func = wrapFunction(base::get() + 0x3cfc30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

SecretLayer3::SecretLayer3() {
        m_lockInput = false;
        m_locksArray = nullptr;
        m_demonEyes = nullptr;
        m_demonBody = nullptr;
        m_secretChest = nullptr;
    }

SecretLayer3* SecretLayer3::create() {
        auto ret = new SecretLayer3();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto SecretLayer3::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretLayer3::init), this);
	using FunctionType = decltype(init())(*)(SecretLayer3*);
	static auto func = wrapFunction(base::get() + 0x3d2b20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretLayer3::onExit() -> decltype(onExit()) {
	throw std::runtime_error("SecretLayer3::onExit not implemented");
}

auto SecretLayer3::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretLayer3::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SecretLayer3*);
	static auto func = wrapFunction(base::get() + 0x3d8420, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretLayer3::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DialogLayer*>::func(&SecretLayer3::dialogClosed), this);
	using FunctionType = decltype(dialogClosed(p0))(*)(SecretLayer3*, DialogLayer*);
	static auto func = wrapFunction(base::get() + 0x3d7e20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SecretLayer3::onClick(cocos2d::CCObject* sender) -> decltype(onClick(sender)) {
	using FunctionType = decltype(onClick(sender))(*)(SecretLayer3*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3d5090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SecretLayer4::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretLayer4::init), this);
	using FunctionType = decltype(init())(*)(SecretLayer4*);
	static auto func = wrapFunction(base::get() + 0x3d87b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretLayer4::onExit() -> decltype(onExit()) {
	throw std::runtime_error("SecretLayer4::onExit not implemented");
}

auto SecretLayer4::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretLayer4::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SecretLayer4*);
	static auto func = wrapFunction(base::get() + 0x3dc3b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretLayer4::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	throw std::runtime_error("SecretLayer4::textInputOpened not implemented");
}

auto SecretLayer4::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	throw std::runtime_error("SecretLayer4::textInputClosed not implemented");
}

auto SecretLayer4::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("SecretLayer4::textChanged not implemented");
}

void SecretLayer4::FLAlert_Clicked(FLAlertLayer* p0, bool p1) {}

void SecretLayer4::dialogClosed(DialogLayer* p0) {}

SecretLayer5::SecretLayer5() {
        m_unk1b8 = -1;
        m_unk1bc = -1;
        m_unk1c0 = 0;
        m_unk1c4 = 0;
        m_unk1c8 = 0;
        m_unk1cc = -1;
        m_textInput = nullptr;
        m_messageLabel = nullptr;
        m_exiting = false;
        m_torchFires = nullptr;
        m_loading = false;
        m_rewardStatus = 0;
        m_chestID = "";
        m_uiLocked = false;
        m_soundEffects = {};
        m_chatIndex = -1;
    }

SecretLayer5* SecretLayer5::create() {
        auto ret = new SecretLayer5();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto SecretLayer5::scene() -> decltype(scene()) {
	using FunctionType = decltype(scene())(*)();
	static auto func = wrapFunction(base::get() + 0x2c02c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto SecretLayer5::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretLayer5::init), this);
	using FunctionType = decltype(init())(*)(SecretLayer5*);
	static auto func = wrapFunction(base::get() + 0x3dccc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretLayer5::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretLayer5::onExit), this);
	using FunctionType = decltype(onExit())(*)(SecretLayer5*);
	static auto func = wrapFunction(base::get() + 0x3d25a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretLayer5::updateTweenActionInt(float p0, int p1) -> decltype(updateTweenActionInt(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, int>::func(&SecretLayer5::updateTweenActionInt), this);
	using FunctionType = decltype(updateTweenActionInt(p0, p1))(*)(SecretLayer5*, float, int);
	static auto func = wrapFunction(base::get() + 0x3de3d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SecretLayer5::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretLayer5::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SecretLayer5*);
	static auto func = wrapFunction(base::get() + 0x3e0c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretLayer5::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SecretLayer5::textInputOpened), this);
	using FunctionType = decltype(textInputOpened(p0))(*)(SecretLayer5*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x3dffe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SecretLayer5::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SecretLayer5::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(SecretLayer5*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x3e0130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SecretLayer5::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SecretLayer5::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SecretLayer5*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x3e0130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

void SecretLayer5::FLAlert_Clicked(FLAlertLayer* p0, bool p1) {}

void SecretLayer5::dialogClosed(DialogLayer* p0) {}

auto SecretLayer5::onlineRewardStatusFinished(gd::string p0) -> decltype(onlineRewardStatusFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string>::func(&SecretLayer5::onlineRewardStatusFinished), this);
	using FunctionType = decltype(onlineRewardStatusFinished(p0))(*)(SecretLayer5*, gd::string);
	static auto func = wrapFunction(base::get() + 0x3df6b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SecretLayer5::onlineRewardStatusFailed() -> decltype(onlineRewardStatusFailed()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretLayer5::onlineRewardStatusFailed), this);
	using FunctionType = decltype(onlineRewardStatusFailed())(*)(SecretLayer5*);
	static auto func = wrapFunction(base::get() + 0x3df820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretLayer5::animateHead() -> decltype(animateHead()) {
	using FunctionType = decltype(animateHead())(*)(SecretLayer5*);
	static auto func = wrapFunction(base::get() + 0x3de060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SecretLayer5::claimOnlineReward() -> decltype(claimOnlineReward()) {
	using FunctionType = decltype(claimOnlineReward())(*)(SecretLayer5*);
	static auto func = wrapFunction(base::get() + 0x3df490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SecretLayer5::fadeInSubmitMessage() -> decltype(fadeInSubmitMessage()) {
	using FunctionType = decltype(fadeInSubmitMessage())(*)(SecretLayer5*);
	static auto func = wrapFunction(base::get() + 0x3dde60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SecretLayer5::fadeOutMessage() -> decltype(fadeOutMessage()) {
	using FunctionType = decltype(fadeOutMessage())(*)(SecretLayer5*);
	static auto func = wrapFunction(base::get() + 0x3de030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SecretLayer5::finishLoadingState() -> decltype(finishLoadingState()) {
	using FunctionType = decltype(finishLoadingState())(*)(SecretLayer5*);
	static auto func = wrapFunction(base::get() + 0x3de420, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

gd::string SecretLayer5::getMessage() {
        return " ";
    }

auto SecretLayer5::handleSecretResponse() -> decltype(handleSecretResponse()) {
	using FunctionType = decltype(handleSecretResponse())(*)(SecretLayer5*);
	static auto func = wrapFunction(base::get() + 0x3de440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void SecretLayer5::hideTextInput() {
        m_textInput->setTouchEnabled(false);
        m_textInput->onClickTrackNode(false);
        m_textInput->setVisible(false);
        m_messageArea->stopAllActions();
        m_messageArea->runAction(cocos2d::CCFadeTo::create(.5f, 0));
    }

cocos2d::CCNode* SecretLayer5::nodeWithTag(int tag) {
        auto ret = cocos2d::CCNode::create();
        ret->setTag(tag);
        return ret;
    }

auto SecretLayer5::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	using FunctionType = decltype(onBack(sender))(*)(SecretLayer5*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3e0c10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SecretLayer5::onSubmit(cocos2d::CCObject* sender) -> decltype(onSubmit(sender)) {
	using FunctionType = decltype(onSubmit(sender))(*)(SecretLayer5*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3df8c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SecretLayer5::playWinSFX() -> decltype(playWinSFX()) {
	using FunctionType = decltype(playWinSFX())(*)(SecretLayer5*);
	static auto func = wrapFunction(base::get() + 0x3df400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SecretLayer5::showFailAnimation() -> decltype(showFailAnimation()) {
	using FunctionType = decltype(showFailAnimation())(*)(SecretLayer5*);
	static auto func = wrapFunction(base::get() + 0x3de4a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SecretLayer5::showFirstDialog() -> decltype(showFirstDialog()) {
	using FunctionType = decltype(showFirstDialog())(*)(SecretLayer5*);
	static auto func = wrapFunction(base::get() + 0x3e04f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SecretLayer5::showSuccessAnimation() -> decltype(showSuccessAnimation()) {
	using FunctionType = decltype(showSuccessAnimation())(*)(SecretLayer5*);
	static auto func = wrapFunction(base::get() + 0x3dea60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SecretLayer5::showTextInput() -> decltype(showTextInput()) {
	using FunctionType = decltype(showTextInput())(*)(SecretLayer5*);
	static auto func = wrapFunction(base::get() + 0x3df860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SecretLayer5::unlockUI() -> decltype(unlockUI()) {
	using FunctionType = decltype(unlockUI())(*)(SecretLayer5*);
	static auto func = wrapFunction(base::get() + 0x3df6a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void SecretLayer5::updateMessageLabel(gd::string text) {
        m_messageLabel->setString(text.c_str());
        m_messageLabel->limitLabelWidth(320.f, .6f, 0.f);
    }

auto SecretLayer5::updateSearchLabel(char const* p0) -> decltype(updateSearchLabel(p0)) {
	using FunctionType = decltype(updateSearchLabel(p0))(*)(SecretLayer5*, char const*);
	static auto func = wrapFunction(base::get() + 0x3e0200, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

SecretLayer6::SecretLayer6() {
        m_gameLayer = nullptr;
    }

auto SecretLayer6::init() -> decltype(init()) {
	throw std::runtime_error("SecretLayer6::init not implemented");
}

auto SecretLayer6::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("SecretLayer6::keyBackClicked not implemented");
}

auto SecretNumberLayer::init() -> decltype(init()) {
	throw std::runtime_error("SecretNumberLayer::init not implemented");
}

SecretRewardsLayer::SecretRewardsLayer() {
        m_mainLayer = nullptr;
        m_secondaryLayer = nullptr;
        m_chestCounter = nullptr;
        m_chestCounters = nullptr;
        m_backSprite = nullptr;
        m_unkSize4_2 = 0;
        m_secondaryScrollLayer = nullptr;
        m_scratchDialogIndex = 0;
        m_potborDialogIndex = 0;
        m_diamondDialogIndex = 0;
        m_mechanicDialogIndex = 0;
        m_inMainLayer = false;
        m_rewardType = GJRewardType::Unknown;
        m_lockedDialogIndex = 0;
    }

SecretRewardsLayer* SecretRewardsLayer::create(bool fromShop) {
        auto ret = new SecretRewardsLayer();
        if (ret->init(fromShop)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto SecretRewardsLayer::scene(bool fromShop) -> decltype(scene(fromShop)) {
	using FunctionType = decltype(scene(fromShop))(*)(bool);
	static auto func = wrapFunction(base::get() + 0x3bb1a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(fromShop);
}

auto SecretRewardsLayer::onExit() -> decltype(onExit()) {
	throw std::runtime_error("SecretRewardsLayer::onExit not implemented");
}

auto SecretRewardsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretRewardsLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SecretRewardsLayer*);
	static auto func = wrapFunction(base::get() + 0x3c0a90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretRewardsLayer::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DialogLayer*>::func(&SecretRewardsLayer::dialogClosed), this);
	using FunctionType = decltype(dialogClosed(p0))(*)(SecretRewardsLayer*, DialogLayer*);
	static auto func = wrapFunction(base::get() + 0x3bf570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SecretRewardsLayer::scrollLayerMoved(cocos2d::CCPoint p0) -> decltype(scrollLayerMoved(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint>::func(&SecretRewardsLayer::scrollLayerMoved), this);
	using FunctionType = decltype(scrollLayerMoved(p0))(*)(SecretRewardsLayer*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x3bda10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SecretRewardsLayer::createSecondaryLayer(int p0) -> decltype(createSecondaryLayer(p0)) {
	using FunctionType = decltype(createSecondaryLayer(p0))(*)(SecretRewardsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x3bdf70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SecretRewardsLayer::generateChestItems(int p0) -> decltype(generateChestItems(p0)) {
	using FunctionType = decltype(generateChestItems(p0))(*)(SecretRewardsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x3be3c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

cocos2d::ccColor3B SecretRewardsLayer::getPageColor(int page) {
        if (page == 1) return cocos2d::ccc3(50, 50, 50);
        else if (page == 2) return cocos2d::ccc3(70, 0, 120);
        else return cocos2d::ccc3(70, 0, 75);
    }

void SecretRewardsLayer::goToPage(int page) {
        if (m_inMainLayer) m_mainScrollLayer->moveToPage(page);
        else m_secondaryScrollLayer->moveToPage(page);
    }

auto SecretRewardsLayer::init(bool p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(SecretRewardsLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x3bb300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SecretRewardsLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	using FunctionType = decltype(onBack(sender))(*)(SecretRewardsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3c08b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SecretRewardsLayer::onChestType(cocos2d::CCObject* sender) -> decltype(onChestType(sender)) {
	using FunctionType = decltype(onChestType(sender))(*)(SecretRewardsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3bdce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SecretRewardsLayer::onGoldChest(cocos2d::CCObject* sender) -> decltype(onGoldChest(sender)) {
	using FunctionType = decltype(onGoldChest(sender))(*)(SecretRewardsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3c0020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SecretRewardsLayer::onSelectItem(cocos2d::CCObject* sender) -> decltype(onSelectItem(sender)) {
	using FunctionType = decltype(onSelectItem(sender))(*)(SecretRewardsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3bedd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SecretRewardsLayer::onShop(cocos2d::CCObject* sender) -> decltype(onShop(sender)) {
	using FunctionType = decltype(onShop(sender))(*)(SecretRewardsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3bf360, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SecretRewardsLayer::onSpecialItem(cocos2d::CCObject* sender) -> decltype(onSpecialItem(sender)) {
	using FunctionType = decltype(onSpecialItem(sender))(*)(SecretRewardsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3bf760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SecretRewardsLayer::onSwitchPage(cocos2d::CCObject* sender) -> decltype(onSwitchPage(sender)) {
	using FunctionType = decltype(onSwitchPage(sender))(*)(SecretRewardsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3bd950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SecretRewardsLayer::showDialog01() -> decltype(showDialog01()) {
	using FunctionType = decltype(showDialog01())(*)(SecretRewardsLayer*);
	static auto func = wrapFunction(base::get() + 0x3c0ae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SecretRewardsLayer::showDialogDiamond() -> decltype(showDialogDiamond()) {
	using FunctionType = decltype(showDialogDiamond())(*)(SecretRewardsLayer*);
	static auto func = wrapFunction(base::get() + 0x3c4980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SecretRewardsLayer::showDialogMechanic() -> decltype(showDialogMechanic()) {
	using FunctionType = decltype(showDialogMechanic())(*)(SecretRewardsLayer*);
	static auto func = wrapFunction(base::get() + 0x3c36f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void SecretRewardsLayer::showShop(int shop) {
        if (cocos2d::CCDirector::sharedDirector()->replaceScene(cocos2d::CCTransitionMoveInT::create(0.5f, GJShopLayer::scene((ShopType)shop)))) this->setKeypadEnabled(false);
    }

auto SecretRewardsLayer::switchToOpenedState(CCMenuItemSpriteExtra* p0) -> decltype(switchToOpenedState(p0)) {
	using FunctionType = decltype(switchToOpenedState(p0))(*)(SecretRewardsLayer*, CCMenuItemSpriteExtra*);
	static auto func = wrapFunction(base::get() + 0x3bfb80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SecretRewardsLayer::updateBackButton() -> decltype(updateBackButton()) {
	using FunctionType = decltype(updateBackButton())(*)(SecretRewardsLayer*);
	static auto func = wrapFunction(base::get() + 0x3bde30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SelectArtLayer::create(SelectArtType p0, int p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(SelectArtType, int);
	static auto func = wrapFunction(base::get() + 0x30d600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SelectArtLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SelectArtLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SelectArtLayer*);
	static auto func = wrapFunction(base::get() + 0x30e530, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SelectArtLayer::init(SelectArtType p0, int p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SelectArtLayer*, SelectArtType, int);
	static auto func = wrapFunction(base::get() + 0x30d710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SelectArtLayer::onSelectCustom(cocos2d::CCObject* sender) -> decltype(onSelectCustom(sender)) {
	using FunctionType = decltype(onSelectCustom(sender))(*)(SelectArtLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x30e420, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SelectArtLayer::selectArt(cocos2d::CCObject* sender) -> decltype(selectArt(sender)) {
	using FunctionType = decltype(selectArt(sender))(*)(SelectArtLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x30e360, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

void SelectArtLayer::updateSelectedCustom(int idx) {
        if (m_lineSprites) {
            m_line = idx;
            this->onSelectCustom(nullptr);
        }
    }

auto SelectEventLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("SelectEventLayer::keyBackClicked not implemented");
}

auto SelectEventLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SelectEventLayer::onClose not implemented");
}

auto SelectEventLayer::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	throw std::runtime_error("SelectEventLayer::onCustomToggleTriggerValue not implemented");
}

SelectFontLayer::SelectFontLayer() {
        m_font = -1;
        m_editorLayer = nullptr;
        m_fontLabel = nullptr;
    }

SelectFontLayer* SelectFontLayer::create(LevelEditorLayer* editorLayer) {
        auto ret = new SelectFontLayer();
        if (ret->init(editorLayer)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto SelectFontLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("SelectFontLayer::keyBackClicked not implemented");
}

auto SelectFontLayer::init(LevelEditorLayer* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(SelectFontLayer*, LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x286be0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SelectFontLayer::onChangeFont(cocos2d::CCObject* sender) -> decltype(onChangeFont(sender)) {
	using FunctionType = decltype(onChangeFont(sender))(*)(SelectFontLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x287400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SelectFontLayer::updateFontLabel() -> decltype(updateFontLabel()) {
	using FunctionType = decltype(updateFontLabel())(*)(SelectFontLayer*);
	static auto func = wrapFunction(base::get() + 0x287200, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

SelectListIconLayer::SelectListIconLayer() {}

SelectListIconLayer* SelectListIconLayer::create(int difficulty) {
        auto ret = new SelectListIconLayer();
        if (ret->init(difficulty)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto SelectListIconLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SelectListIconLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SelectListIconLayer*);
	static auto func = wrapFunction(base::get() + 0x2f5080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SelectListIconLayer::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(SelectListIconLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2f4790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SelectListIconLayer::onSelect(cocos2d::CCObject* sender) -> decltype(onSelect(sender)) {
	using FunctionType = decltype(onSelect(sender))(*)(SelectListIconLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f4f80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SelectPremadeDelegate::selectPremadeClosed(SelectPremadeLayer* p0, int p1) -> decltype(selectPremadeClosed(p0, p1)) {
	throw std::runtime_error("SelectPremadeDelegate::selectPremadeClosed not implemented");
}

auto SelectPremadeLayer::init() -> decltype(init()) {
	throw std::runtime_error("SelectPremadeLayer::init not implemented");
}

auto SelectPremadeLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("SelectPremadeLayer::keyBackClicked not implemented");
}

auto SelectSettingLayer::create(SelectSettingType p0, int p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(SelectSettingType, int);
	static auto func = wrapFunction(base::get() + 0x30e580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SelectSettingLayer::frameForItem(SelectSettingType p0, int p1) -> decltype(frameForItem(p0, p1)) {
	using FunctionType = decltype(frameForItem(p0, p1))(*)(SelectSettingType, int);
	static auto func = wrapFunction(base::get() + 0x30ede0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

gd::string SelectSettingLayer::frameForValue(SelectSettingType type, int value) {
        return frameForItem(type, valueToIdx(type, value));
    }

int SelectSettingLayer::idxToValue(SelectSettingType type, int idx) {
        if (type != SelectSettingType::StartingSpeed) return idx;

        switch (idx) {
            case 0: return 1;
            case 1: return 0;
            case 2: case 3: case 4: return idx;
            default: return 0;
        }
    }

int SelectSettingLayer::valueToIdx(SelectSettingType type, int value) {
        if (type != SelectSettingType::StartingSpeed) return value;

        switch (value) {
            case 0: return 1;
            case 1: return 0;
            case 2: case 3: case 4: return value;
            default: return 1;
        }
    }

auto SelectSettingLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SelectSettingLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SelectSettingLayer*);
	static auto func = wrapFunction(base::get() + 0x30f380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

gd::string SelectSettingLayer::getSelectedFrame() {
        return frameForValue(m_type, m_settingID);
    }

int SelectSettingLayer::getSelectedValue() {
        return idxToValue(m_type, m_settingID);
    }

auto SelectSettingLayer::init(SelectSettingType p0, int p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SelectSettingLayer*, SelectSettingType, int);
	static auto func = wrapFunction(base::get() + 0x30e690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SelectSettingLayer::onSelect(cocos2d::CCObject* sender) -> decltype(onSelect(sender)) {
	using FunctionType = decltype(onSelect(sender))(*)(SelectSettingLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x30f280, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SelectSFXSortDelegate::sortSelectClosed(SelectSFXSortLayer* p0) -> decltype(sortSelectClosed(p0)) {
	throw std::runtime_error("SelectSFXSortDelegate::sortSelectClosed not implemented");
}

SelectSFXSortLayer::SelectSFXSortLayer() {
        m_sortType = AudioSortType::NameAscending;
        m_delegate = nullptr;
    }

SelectSFXSortLayer* SelectSFXSortLayer::create(AudioSortType sortType) {
        auto ret = new SelectSFXSortLayer();
        if (ret->init(sortType)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto SelectSFXSortLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("SelectSFXSortLayer::keyBackClicked not implemented");
}

auto SelectSFXSortLayer::init(AudioSortType p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(SelectSFXSortLayer*, AudioSortType);
	static auto func = wrapFunction(base::get() + 0x468b50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SelectSFXSortLayer::onSelect(cocos2d::CCObject* sender) -> decltype(onSelect(sender)) {
	using FunctionType = decltype(onSelect(sender))(*)(SelectSFXSortLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4691d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SequenceTriggerGameObject::init() -> decltype(init()) {
	throw std::runtime_error("SequenceTriggerGameObject::init not implemented");
}

auto SequenceTriggerGameObject::resetObject() -> decltype(resetObject()) {
	throw std::runtime_error("SequenceTriggerGameObject::resetObject not implemented");
}

auto SequenceTriggerGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	throw std::runtime_error("SequenceTriggerGameObject::triggerObject not implemented");
}

auto SequenceTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("SequenceTriggerGameObject::customObjectSetup not implemented");
}

auto SequenceTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("SequenceTriggerGameObject::getSaveString not implemented");
}

auto SetColorIDPopup::colorSelectClosed(GJSpecialColorSelect* p0, int p1) -> decltype(colorSelectClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<GJSpecialColorSelect*, int>::func(&SetColorIDPopup::colorSelectClosed), this);
	using FunctionType = decltype(colorSelectClosed(p0, p1))(*)(SetColorIDPopup*, GJSpecialColorSelect*, int);
	static auto func = wrapFunction(base::get() + 0x294cf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetFolderPopup::create(int value, bool isCreated, gd::string title) -> decltype(create(value, isCreated, title)) {
	using FunctionType = decltype(create(value, isCreated, title))(*)(int, bool, gd::string);
	static auto func = wrapFunction(base::get() + 0x294e90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(value, isCreated, title);
}

auto SetFolderPopup::valueChanged() -> decltype(valueChanged()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetFolderPopup::valueChanged), this);
	using FunctionType = decltype(valueChanged())(*)(SetFolderPopup*);
	static auto func = wrapFunction(base::get() + 0x295250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetFolderPopup::setTextPopupClosed(SetTextPopup* p0, gd::string p1) -> decltype(setTextPopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<SetTextPopup*, gd::string>::func(&SetFolderPopup::setTextPopupClosed), this);
	using FunctionType = decltype(setTextPopupClosed(p0, p1))(*)(SetFolderPopup*, SetTextPopup*, gd::string);
	static auto func = wrapFunction(base::get() + 0x295590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetFolderPopup::init(int value, bool isCreated, gd::string title) -> decltype(init(value, isCreated, title)) {
	using FunctionType = decltype(init(value, isCreated, title))(*)(SetFolderPopup*, int, bool, gd::string);
	static auto func = wrapFunction(base::get() + 0x294fd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, value, isCreated, title);
}

auto SetFolderPopup::onSetFolderName(cocos2d::CCObject* sender) -> decltype(onSetFolderName(sender)) {
	using FunctionType = decltype(onSetFolderName(sender))(*)(SetFolderPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x295390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetGroupIDLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetGroupIDLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SetGroupIDLayer*);
	static auto func = wrapFunction(base::get() + 0x3e62e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetGroupIDLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	throw std::runtime_error("SetGroupIDLayer::textInputClosed not implemented");
}

auto SetGroupIDLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetGroupIDLayer::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetGroupIDLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x3e4400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetGroupIDLayer::init(GameObject* obj, cocos2d::CCArray* objs) -> decltype(init(obj, objs)) {
	using FunctionType = decltype(init(obj, objs))(*)(SetGroupIDLayer*, GameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x3e1260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, obj, objs);
}

auto SetGroupIDLayer::onAddGroup(cocos2d::CCObject* sender) -> decltype(onAddGroup(sender)) {
	using FunctionType = decltype(onAddGroup(sender))(*)(SetGroupIDLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3e52b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetGroupIDLayer::onAddGroupParent(cocos2d::CCObject* sender) -> decltype(onAddGroupParent(sender)) {
	using FunctionType = decltype(onAddGroupParent(sender))(*)(SetGroupIDLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3e5420, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetGroupIDLayer::onArrow(int tag, int increment) -> decltype(onArrow(tag, increment)) {
	using FunctionType = decltype(onArrow(tag, increment))(*)(SetGroupIDLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x3e39e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, tag, increment);
}

auto SetGroupIDLayer::onArrowLeft(cocos2d::CCObject* sender) -> decltype(onArrowLeft(sender)) {
	using FunctionType = decltype(onArrowLeft(sender))(*)(SetGroupIDLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3e3980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetGroupIDLayer::onArrowRight(cocos2d::CCObject* sender) -> decltype(onArrowRight(sender)) {
	using FunctionType = decltype(onArrowRight(sender))(*)(SetGroupIDLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3e39b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetGroupIDLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SetGroupIDLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3e5f60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetGroupIDLayer::onExtra(cocos2d::CCObject* sender) -> decltype(onExtra(sender)) {
	using FunctionType = decltype(onExtra(sender))(*)(SetGroupIDLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3e40d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetGroupIDLayer::onNextGroupID1(cocos2d::CCObject* sender) -> decltype(onNextGroupID1(sender)) {
	using FunctionType = decltype(onNextGroupID1(sender))(*)(SetGroupIDLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3e48d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetGroupIDLayer::onPaste(cocos2d::CCObject* sender) -> decltype(onPaste(sender)) {
	using FunctionType = decltype(onPaste(sender))(*)(SetGroupIDLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x111a80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetGroupIDLayer::onRemoveFromGroup(cocos2d::CCObject* sender) -> decltype(onRemoveFromGroup(sender)) {
	using FunctionType = decltype(onRemoveFromGroup(sender))(*)(SetGroupIDLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3e51e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetGroupIDLayer::updateEditorLabel() -> decltype(updateEditorLabel()) {
	using FunctionType = decltype(updateEditorLabel())(*)(SetGroupIDLayer*);
	static auto func = wrapFunction(base::get() + 0x3e5920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SetGroupIDLayer::updateEditorLabel2() -> decltype(updateEditorLabel2()) {
	using FunctionType = decltype(updateEditorLabel2())(*)(SetGroupIDLayer*);
	static auto func = wrapFunction(base::get() + 0x3e59b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SetGroupIDLayer::updateGroupIDButtons() -> decltype(updateGroupIDButtons()) {
	using FunctionType = decltype(updateGroupIDButtons())(*)(SetGroupIDLayer*);
	static auto func = wrapFunction(base::get() + 0x3e4940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SetGroupIDLayer::updateGroupIDLabel() -> decltype(updateGroupIDLabel()) {
	using FunctionType = decltype(updateGroupIDLabel())(*)(SetGroupIDLayer*);
	static auto func = wrapFunction(base::get() + 0x3e5ad0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SetGroupIDLayer::updateZLayerButtons() -> decltype(updateZLayerButtons()) {
	using FunctionType = decltype(updateZLayerButtons())(*)(SetGroupIDLayer*);
	static auto func = wrapFunction(base::get() + 0x3e5d30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SetGroupIDLayer::updateZOrder() -> decltype(updateZOrder()) {
	using FunctionType = decltype(updateZOrder())(*)(SetGroupIDLayer*);
	static auto func = wrapFunction(base::get() + 0x3e5890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SetGroupIDLayer::updateZOrderLabel() -> decltype(updateZOrderLabel()) {
	using FunctionType = decltype(updateZOrderLabel())(*)(SetGroupIDLayer*);
	static auto func = wrapFunction(base::get() + 0x3e5a40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SetItemIDLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetItemIDLayer::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(SetItemIDLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3e9ed0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetItemIDLayer::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetItemIDLayer::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetItemIDLayer*, int, float);
	static auto func = wrapFunction(base::get() + 0x3e9de0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetItemIDLayer::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetItemIDLayer::onCustomToggleTriggerValue), this);
	using FunctionType = decltype(onCustomToggleTriggerValue(sender))(*)(SetItemIDLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3e9c40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetTargetIDLayer::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetTargetIDLayer::determineStartValues not implemented");
}

auto SetTargetIDLayer::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetTargetIDLayer::valueDidChange not implemented");
}

auto SetupAdvFollowEditPhysicsPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetupAdvFollowEditPhysicsPopup::valueDidChange not implemented");
}

auto SetupAdvFollowPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupAdvFollowPopup::onClose not implemented");
}

auto SetupAdvFollowPopup::updateDefaultTriggerValues() -> decltype(updateDefaultTriggerValues()) {
	throw std::runtime_error("SetupAdvFollowPopup::updateDefaultTriggerValues not implemented");
}

auto SetupAdvFollowPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetupAdvFollowPopup::valueDidChange not implemented");
}

auto SetupAdvFollowPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	throw std::runtime_error("SetupAdvFollowPopup::onCustomToggleTriggerValue not implemented");
}

auto SetupAdvFollowPopup::selectPremadeClosed(SelectPremadeLayer* p0, int p1) -> decltype(selectPremadeClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<SelectPremadeLayer*, int>::func(&SetupAdvFollowPopup::selectPremadeClosed), this);
	using FunctionType = decltype(selectPremadeClosed(p0, p1))(*)(SetupAdvFollowPopup*, SelectPremadeLayer*, int);
	static auto func = wrapFunction(base::get() + 0x3ee030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupAdvFollowRetargetPopup::updateDefaultTriggerValues() -> decltype(updateDefaultTriggerValues()) {
	throw std::runtime_error("SetupAdvFollowRetargetPopup::updateDefaultTriggerValues not implemented");
}

auto SetupAdvFollowRetargetPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetupAdvFollowRetargetPopup::valueDidChange not implemented");
}

auto SetupAnimationPopup::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupAnimationPopup::determineStartValues not implemented");
}

auto SetupAnimationPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupAnimationPopup::onClose not implemented");
}

auto SetupAnimationPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupAnimationPopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupAnimationPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x3f2060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupAnimSettingsPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupAnimSettingsPopup::onClose not implemented");
}

auto SetupAreaMoveTriggerPopup::updateInputValue(int p0, float& p1) -> decltype(updateInputValue(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float&>::func(&SetupAreaMoveTriggerPopup::updateInputValue), this);
	using FunctionType = decltype(updateInputValue(p0, p1))(*)(SetupAreaMoveTriggerPopup*, int, float&);
	static auto func = wrapFunction(base::get() + 0x3f63f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupAreaMoveTriggerPopup::updateDefaultTriggerValues() -> decltype(updateDefaultTriggerValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupAreaMoveTriggerPopup::updateDefaultTriggerValues), this);
	using FunctionType = decltype(updateDefaultTriggerValues())(*)(SetupAreaMoveTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x3f5d20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupAreaMoveTriggerPopup::updateInputNode(int p0, float p1) -> decltype(updateInputNode(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupAreaMoveTriggerPopup::updateInputNode), this);
	using FunctionType = decltype(updateInputNode(p0, p1))(*)(SetupAreaMoveTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x3f63c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupAreaMoveTriggerPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupAreaMoveTriggerPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupAreaMoveTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x3f6240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupAreaMoveTriggerPopup::triggerValueFromSliderValue(int p0, float p1) -> decltype(triggerValueFromSliderValue(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupAreaMoveTriggerPopup::triggerValueFromSliderValue), this);
	using FunctionType = decltype(triggerValueFromSliderValue(p0, p1))(*)(SetupAreaMoveTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x3f6360, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupAreaMoveTriggerPopup::triggerSliderValueFromValue(int p0, float p1) -> decltype(triggerSliderValueFromValue(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupAreaMoveTriggerPopup::triggerSliderValueFromValue), this);
	using FunctionType = decltype(triggerSliderValueFromValue(p0, p1))(*)(SetupAreaMoveTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x3f6390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupAreaTintTriggerPopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupAreaTintTriggerPopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupAreaTintTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x3f8840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupAreaTintTriggerPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupAreaTintTriggerPopup::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(SetupAreaTintTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3f8b50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupAreaTintTriggerPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupAreaTintTriggerPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupAreaTintTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x3f8680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupAreaTintTriggerPopup::hsvPopupClosed(HSVWidgetPopup* p0, cocos2d::ccHSVValue p1) -> decltype(hsvPopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<HSVWidgetPopup*, cocos2d::ccHSVValue>::func(&SetupAreaTintTriggerPopup::hsvPopupClosed), this);
	using FunctionType = decltype(hsvPopupClosed(p0, p1))(*)(SetupAreaTintTriggerPopup*, HSVWidgetPopup*, cocos2d::ccHSVValue);
	static auto func = wrapFunction(base::get() + 0x3f8a60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupAreaAnimTriggerPopup::updateDefaultTriggerValues() -> decltype(updateDefaultTriggerValues()) {
	throw std::runtime_error("SetupAreaAnimTriggerPopup::updateDefaultTriggerValues not implemented");
}

auto SetupAreaAnimTriggerPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetupAreaAnimTriggerPopup::valueDidChange not implemented");
}

auto SetupArtSwitchPopup::selectArtClosed(SelectArtLayer* p0) -> decltype(selectArtClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SelectArtLayer*>::func(&SetupArtSwitchPopup::selectArtClosed), this);
	using FunctionType = decltype(selectArtClosed(p0))(*)(SetupArtSwitchPopup*, SelectArtLayer*);
	static auto func = wrapFunction(base::get() + 0x459ed0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupAudioLineGuidePopup::selectSettingClosed(SelectSettingLayer* p0) -> decltype(selectSettingClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SelectSettingLayer*>::func(&SetupAudioLineGuidePopup::selectSettingClosed), this);
	using FunctionType = decltype(selectSettingClosed(p0))(*)(SetupAudioLineGuidePopup*, SelectSettingLayer*);
	static auto func = wrapFunction(base::get() + 0x4581a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupAudioTriggerPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupAudioTriggerPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupAudioTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x42e390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupCameraEdgePopup::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupCameraEdgePopup::determineStartValues not implemented");
}

auto SetupCameraEdgePopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupCameraEdgePopup::onClose not implemented");
}

auto SetupCameraEdgePopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupCameraEdgePopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupCameraEdgePopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x3fbfc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupCameraModePopup::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupCameraModePopup::determineStartValues not implemented");
}

auto SetupCameraModePopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupCameraModePopup::onClose not implemented");
}

auto SetupCameraOffsetTrigger::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupCameraOffsetTrigger::determineStartValues not implemented");
}

auto SetupCameraOffsetTrigger::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupCameraOffsetTrigger::onClose not implemented");
}

auto SetupCameraOffsetTrigger::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupCameraOffsetTrigger::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupCameraOffsetTrigger*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x3ff6f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupCameraOffsetTrigger::valuePopupClosed(ConfigureValuePopup* p0, float p1) -> decltype(valuePopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<ConfigureValuePopup*, float>::func(&SetupCameraOffsetTrigger::valuePopupClosed), this);
	using FunctionType = decltype(valuePopupClosed(p0, p1))(*)(SetupCameraOffsetTrigger*, ConfigureValuePopup*, float);
	static auto func = wrapFunction(base::get() + 0x3fedf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupCameraRotatePopup::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupCameraRotatePopup::determineStartValues not implemented");
}

auto SetupCameraRotatePopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupCameraRotatePopup::onClose not implemented");
}

auto SetupCameraRotatePopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("SetupCameraRotatePopup::textChanged not implemented");
}

auto SetupCameraRotatePopup::valuePopupClosed(ConfigureValuePopup* p0, float p1) -> decltype(valuePopupClosed(p0, p1)) {
	throw std::runtime_error("SetupCameraRotatePopup::valuePopupClosed not implemented");
}

auto SetupInstantCollisionTriggerPopup::updateDefaultTriggerValues() -> decltype(updateDefaultTriggerValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupInstantCollisionTriggerPopup::updateDefaultTriggerValues), this);
	using FunctionType = decltype(updateDefaultTriggerValues())(*)(SetupInstantCollisionTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x402bc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupInstantCollisionTriggerPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupInstantCollisionTriggerPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupInstantCollisionTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x402990, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupCollisionTriggerPopup::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupCollisionTriggerPopup::determineStartValues not implemented");
}

auto SetupCollisionTriggerPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupCollisionTriggerPopup::onClose not implemented");
}

auto SetupCollisionTriggerPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupCollisionTriggerPopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupCollisionTriggerPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x401ac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupCountTriggerPopup::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupCountTriggerPopup::determineStartValues not implemented");
}

auto SetupCountTriggerPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupCountTriggerPopup::onClose not implemented");
}

auto SetupCountTriggerPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupCountTriggerPopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupCountTriggerPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x404650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupEndPopup::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupEndPopup::determineStartValues not implemented");
}

auto SetupEndPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupEndPopup::onClose not implemented");
}

auto SetupEndPopup::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	throw std::runtime_error("SetupEndPopup::textInputClosed not implemented");
}

auto SetupEndPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupEndPopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupEndPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x405b60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupEnterEffectPopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupEnterEffectPopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupEnterEffectPopup*);
	static auto func = wrapFunction(base::get() + 0x408580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupEnterEffectPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupEnterEffectPopup::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(SetupEnterEffectPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x408b60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupEnterEffectPopup::updateInputValue(int p0, float& p1) -> decltype(updateInputValue(p0, p1)) {
	throw std::runtime_error("SetupEnterEffectPopup::updateInputValue not implemented");
}

auto SetupEnterEffectPopup::updateInputNode(int p0, float p1) -> decltype(updateInputNode(p0, p1)) {
	throw std::runtime_error("SetupEnterEffectPopup::updateInputNode not implemented");
}

auto SetupEnterEffectPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupEnterEffectPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupEnterEffectPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x408750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupEnterEffectPopup::triggerValueFromSliderValue(int p0, float p1) -> decltype(triggerValueFromSliderValue(p0, p1)) {
	throw std::runtime_error("SetupEnterEffectPopup::triggerValueFromSliderValue not implemented");
}

auto SetupEnterEffectPopup::triggerSliderValueFromValue(int p0, float p1) -> decltype(triggerSliderValueFromValue(p0, p1)) {
	throw std::runtime_error("SetupEnterEffectPopup::triggerSliderValueFromValue not implemented");
}

auto SetupEnterEffectPopup::hsvPopupClosed(HSVWidgetPopup* p0, cocos2d::ccHSVValue p1) -> decltype(hsvPopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<HSVWidgetPopup*, cocos2d::ccHSVValue>::func(&SetupEnterEffectPopup::hsvPopupClosed), this);
	using FunctionType = decltype(hsvPopupClosed(p0, p1))(*)(SetupEnterEffectPopup*, HSVWidgetPopup*, cocos2d::ccHSVValue);
	static auto func = wrapFunction(base::get() + 0x408a70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupEnterTriggerPopup::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupEnterTriggerPopup::determineStartValues not implemented");
}

auto SetupForceBlockPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetupForceBlockPopup::valueDidChange not implemented");
}

auto SetupGameplayOffsetPopup::updateInputValue(int p0, float& p1) -> decltype(updateInputValue(p0, p1)) {
	throw std::runtime_error("SetupGameplayOffsetPopup::updateInputValue not implemented");
}

auto SetupGameplayOffsetPopup::updateInputNode(int p0, float p1) -> decltype(updateInputNode(p0, p1)) {
	throw std::runtime_error("SetupGameplayOffsetPopup::updateInputNode not implemented");
}

auto SetupGameplayOffsetPopup::triggerValueFromSliderValue(int p0, float p1) -> decltype(triggerValueFromSliderValue(p0, p1)) {
	throw std::runtime_error("SetupGameplayOffsetPopup::triggerValueFromSliderValue not implemented");
}

auto SetupGameplayOffsetPopup::triggerSliderValueFromValue(int p0, float p1) -> decltype(triggerSliderValueFromValue(p0, p1)) {
	throw std::runtime_error("SetupGameplayOffsetPopup::triggerSliderValueFromValue not implemented");
}

auto SetupGameplayOffsetPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	throw std::runtime_error("SetupGameplayOffsetPopup::onCustomToggleTriggerValue not implemented");
}

auto SetupGradientPopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupGradientPopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupGradientPopup*);
	static auto func = wrapFunction(base::get() + 0x409e70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupGradientPopup::onPlusButton(cocos2d::CCObject* sender) -> decltype(onPlusButton(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupGradientPopup::onPlusButton), this);
	using FunctionType = decltype(onPlusButton(sender))(*)(SetupGradientPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x409f80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupGradientPopup::updateToggleItem(int p0, bool p1) -> decltype(updateToggleItem(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, bool>::func(&SetupGradientPopup::updateToggleItem), this);
	using FunctionType = decltype(updateToggleItem(p0, p1))(*)(SetupGradientPopup*, int, bool);
	static auto func = wrapFunction(base::get() + 0x40a000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupGradientPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupGradientPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupGradientPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x40a410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupGravityModPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("SetupGravityModPopup::keyBackClicked not implemented");
}

auto SetupGravityModPopup::show() -> decltype(show()) {
	throw std::runtime_error("SetupGravityModPopup::show not implemented");
}

auto SetupGravityModPopup::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	throw std::runtime_error("SetupGravityModPopup::textInputClosed not implemented");
}

auto SetupGravityModPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("SetupGravityModPopup::textChanged not implemented");
}

auto SetupGravityTriggerPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetupGravityTriggerPopup::valueDidChange not implemented");
}

auto SetupInstantCountPopup::create(CountTriggerGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(CountTriggerGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x40a520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupInstantCountPopup::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupInstantCountPopup::determineStartValues not implemented");
}

auto SetupInstantCountPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupInstantCountPopup::onClose not implemented");
}

auto SetupInstantCountPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupInstantCountPopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupInstantCountPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x40b740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupInstantCountPopup::init(CountTriggerGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupInstantCountPopup*, CountTriggerGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x40a660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupInstantCountPopup::onTargetIDArrow(cocos2d::CCObject* sender) -> decltype(onTargetIDArrow(sender)) {
	using FunctionType = decltype(onTargetIDArrow(sender))(*)(SetupInstantCountPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4045c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupInstantCountPopup::updateItemID() -> decltype(updateItemID()) {
	using FunctionType = decltype(updateItemID())(*)(SetupInstantCountPopup*);
	static auto func = wrapFunction(base::get() + 0x401fd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SetupInteractObjectPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupInteractObjectPopup::onClose not implemented");
}

auto SetupInteractObjectPopup::onPlusButton(cocos2d::CCObject* sender) -> decltype(onPlusButton(sender)) {
	throw std::runtime_error("SetupInteractObjectPopup::onPlusButton not implemented");
}

auto SetupInteractObjectPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetupInteractObjectPopup::valueDidChange not implemented");
}

auto SetupItemCompareTriggerPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetupItemCompareTriggerPopup::valueDidChange not implemented");
}

auto SetupItemCompareTriggerPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	throw std::runtime_error("SetupItemCompareTriggerPopup::onCustomToggleTriggerValue not implemented");
}

auto SetupItemEditTriggerPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetupItemEditTriggerPopup::valueDidChange not implemented");
}

auto SetupItemEditTriggerPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	throw std::runtime_error("SetupItemEditTriggerPopup::onCustomToggleTriggerValue not implemented");
}

auto SetupItemEditTriggerPopup::init(ItemTriggerGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupItemEditTriggerPopup*, ItemTriggerGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x4525f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupItemEditTriggerPopup::updateFormulaLabel() -> decltype(updateFormulaLabel()) {
	using FunctionType = decltype(updateFormulaLabel())(*)(SetupItemEditTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x453eb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SetupKeyframePopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupKeyframePopup::onClose not implemented");
}

auto SetupKeyframePopup::onCustomButton(cocos2d::CCObject* sender) -> decltype(onCustomButton(sender)) {
	throw std::runtime_error("SetupKeyframePopup::onCustomButton not implemented");
}

auto SetupKeyframePopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetupKeyframePopup::valueDidChange not implemented");
}

auto SetupKeyframePopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	throw std::runtime_error("SetupKeyframePopup::onCustomToggleTriggerValue not implemented");
}

auto SetupMGTrigger::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupMGTrigger::determineStartValues not implemented");
}

auto SetupMGTrigger::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupMGTrigger::onClose not implemented");
}

auto SetupMGTrigger::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupMGTrigger::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupMGTrigger*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x410830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupMGTrigger::valuePopupClosed(ConfigureValuePopup* p0, float p1) -> decltype(valuePopupClosed(p0, p1)) {
	throw std::runtime_error("SetupMGTrigger::valuePopupClosed not implemented");
}

auto SetupMoveCommandPopup::updateInputValue(int p0, float& p1) -> decltype(updateInputValue(p0, p1)) {
	throw std::runtime_error("SetupMoveCommandPopup::updateInputValue not implemented");
}

auto SetupMoveCommandPopup::updateInputNode(int p0, float p1) -> decltype(updateInputNode(p0, p1)) {
	throw std::runtime_error("SetupMoveCommandPopup::updateInputNode not implemented");
}

auto SetupMoveCommandPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetupMoveCommandPopup::valueDidChange not implemented");
}

auto SetupMoveCommandPopup::triggerValueFromSliderValue(int p0, float p1) -> decltype(triggerValueFromSliderValue(p0, p1)) {
	throw std::runtime_error("SetupMoveCommandPopup::triggerValueFromSliderValue not implemented");
}

auto SetupMoveCommandPopup::triggerSliderValueFromValue(int p0, float p1) -> decltype(triggerSliderValueFromValue(p0, p1)) {
	throw std::runtime_error("SetupMoveCommandPopup::triggerSliderValueFromValue not implemented");
}

auto SetupMoveCommandPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	throw std::runtime_error("SetupMoveCommandPopup::onCustomToggleTriggerValue not implemented");
}

auto SetupMoveCommandPopup::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupMoveCommandPopup*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x279010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupObjectOptions2Popup::onPlusButton(cocos2d::CCObject* sender) -> decltype(onPlusButton(sender)) {
	throw std::runtime_error("SetupObjectOptions2Popup::onPlusButton not implemented");
}

auto SetupObjectOptionsPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("SetupObjectOptionsPopup::keyBackClicked not implemented");
}

auto SetupObjectOptionsPopup::show() -> decltype(show()) {
	throw std::runtime_error("SetupObjectOptionsPopup::show not implemented");
}

auto SetupObjectOptionsPopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupObjectOptionsPopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupObjectOptionsPopup*);
	static auto func = wrapFunction(base::get() + 0x3e7cd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupObjectOptionsPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupObjectOptionsPopup::onClose not implemented");
}

auto SetupObjectTogglePopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupObjectTogglePopup::onClose not implemented");
}

auto SetupObjectTogglePopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetupObjectTogglePopup::valueDidChange not implemented");
}

auto SetupOpacityPopup::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupOpacityPopup::determineStartValues not implemented");
}

auto SetupOpacityPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupOpacityPopup::onClose not implemented");
}

auto SetupOpacityPopup::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	throw std::runtime_error("SetupOpacityPopup::textInputClosed not implemented");
}

auto SetupOpacityPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupOpacityPopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupOpacityPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x413a50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupOpacityPopup::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupOpacityPopup*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x412860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupOptionsTriggerPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupOptionsTriggerPopup::onCustomToggleTriggerValue), this);
	using FunctionType = decltype(onCustomToggleTriggerValue(sender))(*)(SetupOptionsTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x41e720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupPickupTriggerPopup::create(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x41e7f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupPickupTriggerPopup::onPlusButton(cocos2d::CCObject* sender) -> decltype(onPlusButton(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupPickupTriggerPopup::onPlusButton), this);
	using FunctionType = decltype(onPlusButton(sender))(*)(SetupPickupTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x40c610, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupPickupTriggerPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupPickupTriggerPopup::onCustomToggleTriggerValue), this);
	using FunctionType = decltype(onCustomToggleTriggerValue(sender))(*)(SetupPickupTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x41f090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupPickupTriggerPopup::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupPickupTriggerPopup*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x41e900, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupPickupTriggerPopup::updateState() -> decltype(updateState()) {
	using FunctionType = decltype(updateState())(*)(SetupPickupTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x41f020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SetupPortalPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("SetupPortalPopup::keyBackClicked not implemented");
}

auto SetupPulsePopup::show() -> decltype(show()) {
	throw std::runtime_error("SetupPulsePopup::show not implemented");
}

auto SetupPulsePopup::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupPulsePopup::determineStartValues not implemented");
}

auto SetupPulsePopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupPulsePopup::onClose not implemented");
}

auto SetupPulsePopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupPulsePopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupPulsePopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x424150, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupPulsePopup::colorValueChanged(cocos2d::ccColor3B p0) -> decltype(colorValueChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B>::func(&SetupPulsePopup::colorValueChanged), this);
	using FunctionType = decltype(colorValueChanged(p0))(*)(SetupPulsePopup*, cocos2d::ccColor3B);
	static auto func = wrapFunction(base::get() + 0x423e90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

void SetupPulsePopup::textInputOpened(CCTextInputNode* p0) {}

auto SetupPulsePopup::colorSelectClosed(GJSpecialColorSelect* p0, int p1) -> decltype(colorSelectClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<GJSpecialColorSelect*, int>::func(&SetupPulsePopup::colorSelectClosed), this);
	using FunctionType = decltype(colorSelectClosed(p0, p1))(*)(SetupPulsePopup*, GJSpecialColorSelect*, int);
	static auto func = wrapFunction(base::get() + 0x423720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupPulsePopup::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupPulsePopup*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x41f430, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupPulsePopup::onPaste(cocos2d::CCObject* sender) -> decltype(onPaste(sender)) {
	using FunctionType = decltype(onPaste(sender))(*)(SetupPulsePopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x90de0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupPulsePopup::onSelectPulseMode(cocos2d::CCObject* sender) -> decltype(onSelectPulseMode(sender)) {
	using FunctionType = decltype(onSelectPulseMode(sender))(*)(SetupPulsePopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x422aa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupRandAdvTriggerPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupRandAdvTriggerPopup::onClose not implemented");
}

void SetupRandAdvTriggerPopup::textChanged(CCTextInputNode* p0) {}

auto SetupRandTriggerPopup::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupRandTriggerPopup::determineStartValues not implemented");
}

auto SetupRandTriggerPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupRandTriggerPopup::onClose not implemented");
}

auto SetupRandTriggerPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupRandTriggerPopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupRandTriggerPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x4288e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupReverbPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupReverbPopup::onClose not implemented");
}

auto SetupRotateCommandPopup::updateInputNode(int p0, float p1) -> decltype(updateInputNode(p0, p1)) {
	throw std::runtime_error("SetupRotateCommandPopup::updateInputNode not implemented");
}

auto SetupRotateCommandPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetupRotateCommandPopup::valueDidChange not implemented");
}

auto SetupRotateCommandPopup::triggerValueFromSliderValue(int p0, float p1) -> decltype(triggerValueFromSliderValue(p0, p1)) {
	throw std::runtime_error("SetupRotateCommandPopup::triggerValueFromSliderValue not implemented");
}

auto SetupRotateCommandPopup::triggerSliderValueFromValue(int p0, float p1) -> decltype(triggerSliderValueFromValue(p0, p1)) {
	throw std::runtime_error("SetupRotateCommandPopup::triggerSliderValueFromValue not implemented");
}

auto SetupRotateCommandPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	throw std::runtime_error("SetupRotateCommandPopup::onCustomToggleTriggerValue not implemented");
}

auto SetupRotateCommandPopup::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupRotateCommandPopup*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x2a06d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupRotateCommandPopup::updateControlVisibility() -> decltype(updateControlVisibility()) {
	using FunctionType = decltype(updateControlVisibility())(*)(SetupRotateCommandPopup*);
	static auto func = wrapFunction(base::get() + 0x2a1b30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SetupRotateGameplayPopup::onPlusButton(cocos2d::CCObject* sender) -> decltype(onPlusButton(sender)) {
	throw std::runtime_error("SetupRotateGameplayPopup::onPlusButton not implemented");
}

auto SetupRotateGameplayPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetupRotateGameplayPopup::valueDidChange not implemented");
}

auto SetupRotatePopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupRotatePopup::onClose not implemented");
}

auto SetupRotatePopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	throw std::runtime_error("SetupRotatePopup::onCustomToggleTriggerValue not implemented");
}

auto SetupSequenceTriggerPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	throw std::runtime_error("SetupSequenceTriggerPopup::onCustomToggleTriggerValue not implemented");
}

auto SFXBrowserDelegate::sfxBrowserClosed(SFXBrowser* p0) -> decltype(sfxBrowserClosed(p0)) {
	throw std::runtime_error("SFXBrowserDelegate::sfxBrowserClosed not implemented");
}

auto SetupSFXPopup::create(SFXTriggerGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(SFXTriggerGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x42ee10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupSFXPopup::pageChanged() -> decltype(pageChanged()) {
	throw std::runtime_error("SetupSFXPopup::pageChanged not implemented");
}

auto SetupSFXPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupSFXPopup::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(SetupSFXPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x430230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupSFXPopup::onPlusButton(cocos2d::CCObject* sender) -> decltype(onPlusButton(sender)) {
	throw std::runtime_error("SetupSFXPopup::onPlusButton not implemented");
}

auto SetupSFXPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetupSFXPopup::valueDidChange not implemented");
}

void SetupSFXPopup::sfxObjectSelected(SFXInfoObject* p0) {}

auto SetupSFXPopup::getActiveSFXID() -> decltype(getActiveSFXID()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupSFXPopup::getActiveSFXID), this);
	using FunctionType = decltype(getActiveSFXID())(*)(SetupSFXPopup*);
	static auto func = wrapFunction(base::get() + 0x430920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupSFXPopup::overridePlaySFX(SFXInfoObject* p0) -> decltype(overridePlaySFX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SFXInfoObject*>::func(&SetupSFXPopup::overridePlaySFX), this);
	using FunctionType = decltype(overridePlaySFX(p0))(*)(SetupSFXPopup*, SFXInfoObject*);
	static auto func = wrapFunction(base::get() + 0x430930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupSFXPopup::sfxBrowserClosed(SFXBrowser* p0) -> decltype(sfxBrowserClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SFXBrowser*>::func(&SetupSFXPopup::sfxBrowserClosed), this);
	using FunctionType = decltype(sfxBrowserClosed(p0))(*)(SetupSFXPopup*, SFXBrowser*);
	static auto func = wrapFunction(base::get() + 0x431050, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupShaderEffectPopup::toggleGroup(int p0, bool p1) -> decltype(toggleGroup(p0, p1)) {
	throw std::runtime_error("SetupShaderEffectPopup::toggleGroup not implemented");
}

auto SetupShaderEffectPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupShaderEffectPopup::onClose not implemented");
}

auto SetupShaderEffectPopup::updateDefaultTriggerValues() -> decltype(updateDefaultTriggerValues()) {
	throw std::runtime_error("SetupShaderEffectPopup::updateDefaultTriggerValues not implemented");
}

auto SetupShaderEffectPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetupShaderEffectPopup::valueDidChange not implemented");
}

auto SetupShakePopup::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupShakePopup::determineStartValues not implemented");
}

auto SetupShakePopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupShakePopup::onClose not implemented");
}

auto SetupShakePopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupShakePopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupShakePopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x43dd60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupSmartBlockLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupSmartBlockLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SetupSmartBlockLayer*);
	static auto func = wrapFunction(base::get() + 0x4406d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupSmartBlockLayer::show() -> decltype(show()) {
	throw std::runtime_error("SetupSmartBlockLayer::show not implemented");
}

auto SetupSmartBlockLayer::selectArtClosed(SelectArtLayer* p0) -> decltype(selectArtClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SelectArtLayer*>::func(&SetupSmartBlockLayer::selectArtClosed), this);
	using FunctionType = decltype(selectArtClosed(p0))(*)(SetupSmartBlockLayer*, SelectArtLayer*);
	static auto func = wrapFunction(base::get() + 0x440690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupSmartTemplateLayer::create(GJSmartTemplate* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(GJSmartTemplate*);
	static auto func = wrapFunction(base::get() + 0x4406e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto SetupSmartTemplateLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupSmartTemplateLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SetupSmartTemplateLayer*);
	static auto func = wrapFunction(base::get() + 0x441940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupSmartTemplateLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&SetupSmartTemplateLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(SetupSmartTemplateLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x4413a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupSmartTemplateLayer::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupSmartTemplateLayer::textInputOpened), this);
	using FunctionType = decltype(textInputOpened(p0))(*)(SetupSmartTemplateLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x4416e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupSmartTemplateLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupSmartTemplateLayer::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(SetupSmartTemplateLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x441480, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupSmartTemplateLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("SetupSmartTemplateLayer::textChanged not implemented");
}

auto SetupSmartTemplateLayer::init(GJSmartTemplate* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(SetupSmartTemplateLayer*, GJSmartTemplate*);
	static auto func = wrapFunction(base::get() + 0x4407f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SongPlaybackDelegate::onPlayback(SongInfoObject* p0) -> decltype(onPlayback(p0)) {
	throw std::runtime_error("SongPlaybackDelegate::onPlayback not implemented");
}

auto SetupSongTriggerPopup::pageChanged() -> decltype(pageChanged()) {
	throw std::runtime_error("SetupSongTriggerPopup::pageChanged not implemented");
}

auto SetupSongTriggerPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupSongTriggerPopup::onClose not implemented");
}

auto SetupSongTriggerPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetupSongTriggerPopup::valueDidChange not implemented");
}

auto SetupSongTriggerPopup::onPlayback(SongInfoObject* p0) -> decltype(onPlayback(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SongInfoObject*>::func(&SetupSongTriggerPopup::onPlayback), this);
	using FunctionType = decltype(onPlayback(p0))(*)(SetupSongTriggerPopup*, SongInfoObject*);
	static auto func = wrapFunction(base::get() + 0x445290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupSpawnPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupSpawnPopup::onClose not implemented");
}

auto SetupStaticCameraPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetupStaticCameraPopup::valueDidChange not implemented");
}

auto SetupStaticCameraPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	throw std::runtime_error("SetupStaticCameraPopup::onCustomToggleTriggerValue not implemented");
}

auto SetupStopTriggerPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupStopTriggerPopup::onClose not implemented");
}

auto SetupStopTriggerPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	throw std::runtime_error("SetupStopTriggerPopup::onCustomToggleTriggerValue not implemented");
}

auto SetupTeleportPopup::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupTeleportPopup::determineStartValues not implemented");
}

auto SetupTeleportPopup::updateDefaultTriggerValues() -> decltype(updateDefaultTriggerValues()) {
	throw std::runtime_error("SetupTeleportPopup::updateDefaultTriggerValues not implemented");
}

auto SetupTeleportPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetupTeleportPopup::valueDidChange not implemented");
}

auto SetupTimerControlTriggerPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	throw std::runtime_error("SetupTimerControlTriggerPopup::onCustomToggleTriggerValue not implemented");
}

auto SetupTimeWarpPopup::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupTimeWarpPopup::determineStartValues not implemented");
}

auto SetupTimeWarpPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupTimeWarpPopup::onClose not implemented");
}

auto SetupTouchTogglePopup::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupTouchTogglePopup::determineStartValues not implemented");
}

auto SetupTouchTogglePopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupTouchTogglePopup::onClose not implemented");
}

auto SetupTouchTogglePopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupTouchTogglePopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupTouchTogglePopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x44c760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupZoomTriggerPopup::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupZoomTriggerPopup::determineStartValues not implemented");
}

auto SetupZoomTriggerPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupZoomTriggerPopup::onClose not implemented");
}

SFXBrowser::SFXBrowser() {
        m_searchResult = nullptr;
        m_sfxObjects = nullptr;
        m_listLayer = nullptr;
        m_nameLabel = nullptr;
        m_pathLabel = nullptr;
        m_infoLabel = nullptr;
        m_pageLabel = nullptr;
        m_searchLabel = nullptr;
        m_prevButton = nullptr;
        m_refreshButton = nullptr;
        m_clearSearchButton = nullptr;
        m_circleSprite = nullptr;
        m_libraryVersion = 0;
        m_cellAmount = 0;
        m_gettingURL = false;
        m_selectedCell = false;
        m_snapToSelected = false;
        m_compactMode = false;
        m_sortType = AudioSortType::NameAscending;
        m_delegate = nullptr;
        #ifdef GEODE_IS_DESKTOP
        m_autoUpdating = false;
        #endif
    }

SFXBrowser* SFXBrowser::create(int id) {
        auto ret = new SFXBrowser();
        if (ret->init(id)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto SFXBrowser::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("SFXBrowser::registerWithTouchDispatcher not implemented");
}

auto SFXBrowser::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SFXBrowser::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SFXBrowser*);
	static auto func = wrapFunction(base::get() + 0x4687f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SFXBrowser::musicActionFinished(GJMusicAction p0) -> decltype(musicActionFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJMusicAction>::func(&SFXBrowser::musicActionFinished), this);
	using FunctionType = decltype(musicActionFinished(p0))(*)(SFXBrowser*, GJMusicAction);
	static auto func = wrapFunction(base::get() + 0x467360, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SFXBrowser::musicActionFailed(GJMusicAction p0) -> decltype(musicActionFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJMusicAction>::func(&SFXBrowser::musicActionFailed), this);
	using FunctionType = decltype(musicActionFailed(p0))(*)(SFXBrowser*, GJMusicAction);
	static auto func = wrapFunction(base::get() + 0x467400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SFXBrowser::sortSelectClosed(SelectSFXSortLayer* p0) -> decltype(sortSelectClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SelectSFXSortLayer*>::func(&SFXBrowser::sortSelectClosed), this);
	using FunctionType = decltype(sortSelectClosed(p0))(*)(SFXBrowser*, SelectSFXSortLayer*);
	static auto func = wrapFunction(base::get() + 0x467f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SFXBrowser::setTextPopupClosed(SetTextPopup* p0, gd::string p1) -> decltype(setTextPopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<SetTextPopup*, gd::string>::func(&SFXBrowser::setTextPopupClosed), this);
	using FunctionType = decltype(setTextPopupClosed(p0, p1))(*)(SFXBrowser*, SetTextPopup*, gd::string);
	static auto func = wrapFunction(base::get() + 0x468200, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SFXBrowser::cellPerformedAction(TableViewCell* p0, int p1, CellAction p2, cocos2d::CCNode* p3) -> decltype(cellPerformedAction(p0, p1, p2, p3)) {
	auto self = addresser::thunkAdjust(Resolve<TableViewCell*, int, CellAction, cocos2d::CCNode*>::func(&SFXBrowser::cellPerformedAction), this);
	using FunctionType = decltype(cellPerformedAction(p0, p1, p2, p3))(*)(SFXBrowser*, TableViewCell*, int, CellAction, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x4682a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3);
}

auto SFXBrowser::getSelectedCellIdx() -> decltype(getSelectedCellIdx()) {
	throw std::runtime_error("SFXBrowser::getSelectedCellIdx not implemented");
}

auto SFXBrowser::shouldSnapToSelected() -> decltype(shouldSnapToSelected()) {
	throw std::runtime_error("SFXBrowser::shouldSnapToSelected not implemented");
}

auto SFXBrowser::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(SFXBrowser*, int);
	static auto func = wrapFunction(base::get() + 0x4661b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SFXBrowser::onExitFolder(cocos2d::CCObject* sender) -> decltype(onExitFolder(sender)) {
	using FunctionType = decltype(onExitFolder(sender))(*)(SFXBrowser*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x468660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SFXBrowser::onPage(cocos2d::CCObject* sender) -> decltype(onPage(sender)) {
	using FunctionType = decltype(onPage(sender))(*)(SFXBrowser*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4683c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SFXBrowser::onSearch(cocos2d::CCObject* sender) -> decltype(onSearch(sender)) {
	using FunctionType = decltype(onSearch(sender))(*)(SFXBrowser*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x468090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SFXBrowser::onSorting(cocos2d::CCObject* sender) -> decltype(onSorting(sender)) {
	using FunctionType = decltype(onSorting(sender))(*)(SFXBrowser*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x467de0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SFXBrowser::onToggleCompactMode(cocos2d::CCObject* sender) -> decltype(onToggleCompactMode(sender)) {
	using FunctionType = decltype(onToggleCompactMode(sender))(*)(SFXBrowser*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x467f80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SFXBrowser::setupList(SFXSearchResult* p0) -> decltype(setupList(p0)) {
	using FunctionType = decltype(setupList(p0))(*)(SFXBrowser*, SFXSearchResult*);
	static auto func = wrapFunction(base::get() + 0x467540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SFXBrowser::updatePageLabel() -> decltype(updatePageLabel()) {
	using FunctionType = decltype(updatePageLabel())(*)(SFXBrowser*);
	static auto func = wrapFunction(base::get() + 0x468490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

SFXInfoObject::SFXInfoObject() {
        m_sfxID = 0;
        m_folderID = 0;
        m_size = 0;
        m_duration = 0;
        m_folder = false;
        m_unk049 = false;
        m_name = "";
    }

SFXInfoObject* SFXInfoObject::create(int id, gd::string name, int folderID, int size, int duration) {
        auto ret = new SFXInfoObject();
        if (ret->init(id, name, folderID, size, duration)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

gd::string SFXInfoObject::getLowerCaseName() {
        gd::string name = m_name;
        for (int i = 0; i < name.size(); i++) {
            name[i] = tolower(name[i]);
        }
        return name;
    }

bool SFXInfoObject::init(int id, gd::string name, int folderID, int size, int duration) {
        m_sfxID = id;
        m_name = name;
        m_folderID = folderID;
        m_size = size;
        m_duration = duration;
        m_folder = false;
        return true;
    }

SFXFolderObject::SFXFolderObject() {
        m_sfxObjects = nullptr;
    }

SFXFolderObject* SFXFolderObject::create(int p0, gd::string p1, int p2) {
        auto ret = new SFXFolderObject();
        if (ret->init(p0, p1, p2)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

bool SFXFolderObject::init(int p0, gd::string p1, int p2) {
        if (!SFXInfoObject::init(p0, p1, p2, 0, 0)) return false;
        m_sfxObjects = cocos2d::CCArray::create();
        m_sfxObjects->retain();
        return true;
    }

auto SFXSearchResult::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x331fa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto SFXSearchResult::updateObjects(AudioSortType p0) -> decltype(updateObjects(p0)) {
	auto self = addresser::thunkAdjust(Resolve<AudioSortType>::func(&SFXSearchResult::updateObjects), this);
	using FunctionType = decltype(updateObjects(p0))(*)(SFXSearchResult*, AudioSortType);
	static auto func = wrapFunction(base::get() + 0x332020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

SFXFolderObject* SFXSearchResult::getActiveFolder() {
        return m_folderObject;
    }

auto SFXSearchResult::getSelectedPage(int p0, int p1) -> decltype(getSelectedPage(p0, p1)) {
	using FunctionType = decltype(getSelectedPage(p0, p1))(*)(SFXSearchResult*, int, int);
	static auto func = wrapFunction(base::get() + 0x332580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

bool SFXSearchResult::init(int folderID) {
        if (!MusicSearchResult::init((GJSongType)-1)) return false;
        m_folderID = folderID;
        m_audioType = 1;
        return true;
    }

void SFXSearchResult::setActiveFolder(SFXFolderObject* folder) {
        CC_SAFE_RELEASE(m_folderObject);
        CC_SAFE_RETAIN(folder);
        m_folderObject = folder;
    }

auto SFXTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("SFXTriggerGameObject::customObjectSetup not implemented");
}

auto SFXTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("SFXTriggerGameObject::getSaveString not implemented");
}

auto ShaderGameObject::customSetup() -> decltype(customSetup()) {
	throw std::runtime_error("ShaderGameObject::customSetup not implemented");
}

auto ShaderGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("ShaderGameObject::customObjectSetup not implemented");
}

auto ShaderGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("ShaderGameObject::getSaveString not implemented");
}

auto ShaderLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ShaderLayer::init), this);
	using FunctionType = decltype(init())(*)(ShaderLayer*);
	static auto func = wrapFunction(base::get() + 0x4697b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ShaderLayer::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&ShaderLayer::update), this);
	using FunctionType = decltype(update(p0))(*)(ShaderLayer*, float);
	static auto func = wrapFunction(base::get() + 0x4697b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ShaderLayer::visit() -> decltype(visit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ShaderLayer::visit), this);
	using FunctionType = decltype(visit())(*)(ShaderLayer*);
	static auto func = wrapFunction(base::get() + 0x470580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ShaderLayer::performCalculations() -> decltype(performCalculations()) {
	using FunctionType = decltype(performCalculations())(*)(ShaderLayer*);
	static auto func = wrapFunction(base::get() + 0x46fbd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ShaderLayer::resetAllShaders() -> decltype(resetAllShaders()) {
	using FunctionType = decltype(resetAllShaders())(*)(ShaderLayer*);
	static auto func = wrapFunction(base::get() + 0x4710f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ShaderLayer::setupShader(bool p0) -> decltype(setupShader(p0)) {
	using FunctionType = decltype(setupShader(p0))(*)(ShaderLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x4698c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ShaderLayer::toggleAntiAlias(bool p0) -> decltype(toggleAntiAlias(p0)) {
	using FunctionType = decltype(toggleAntiAlias(p0))(*)(ShaderLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x46a4f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

ShardsPage::ShardsPage() {
        m_pages = nullptr;
        m_prevButton = nullptr;
        m_nextButton = nullptr;
        m_tierSprite = nullptr;
        m_page = -1;
    }

ShardsPage* ShardsPage::create() {
        auto ret = new ShardsPage();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto ShardsPage::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ShardsPage::init), this);
	using FunctionType = decltype(init())(*)(ShardsPage*);
	static auto func = wrapFunction(base::get() + 0x471620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ShardsPage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("ShardsPage::registerWithTouchDispatcher not implemented");
}

auto ShardsPage::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("ShardsPage::keyBackClicked not implemented");
}

auto ShardsPage::show() -> decltype(show()) {
	throw std::runtime_error("ShardsPage::show not implemented");
}

auto ShardsPage::onIconInfo(cocos2d::CCObject* sender) -> decltype(onIconInfo(sender)) {
	using FunctionType = decltype(onIconInfo(sender))(*)(ShardsPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x474610, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ShareCommentLayer::create(gd::string title, int charLimit, CommentType type, int ID, gd::string desc) -> decltype(create(title, charLimit, type, ID, desc)) {
	using FunctionType = decltype(create(title, charLimit, type, ID, desc))(*)(gd::string, int, CommentType, int, gd::string);
	static auto func = wrapFunction(base::get() + 0x474930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(title, charLimit, type, ID, desc);
}

auto ShareCommentLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("ShareCommentLayer::registerWithTouchDispatcher not implemented");
}

auto ShareCommentLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ShareCommentLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(ShareCommentLayer*);
	static auto func = wrapFunction(base::get() + 0x476170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void ShareCommentLayer::textInputOpened(CCTextInputNode* textInput) {}

auto ShareCommentLayer::textInputClosed(CCTextInputNode* textInput) -> decltype(textInputClosed(textInput)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&ShareCommentLayer::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(textInput))(*)(ShareCommentLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x4761c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, textInput);
}

auto ShareCommentLayer::textChanged(CCTextInputNode* textInput) -> decltype(textChanged(textInput)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&ShareCommentLayer::textChanged), this);
	using FunctionType = decltype(textChanged(textInput))(*)(ShareCommentLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x476300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, textInput);
}

auto ShareCommentLayer::uploadActionFinished(int ID, int unk) -> decltype(uploadActionFinished(ID, unk)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&ShareCommentLayer::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(ID, unk))(*)(ShareCommentLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x476550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, ID, unk);
}

auto ShareCommentLayer::uploadActionFailed(int ID, int unk) -> decltype(uploadActionFailed(ID, unk)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&ShareCommentLayer::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(ID, unk))(*)(ShareCommentLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x4765e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, ID, unk);
}

auto ShareCommentLayer::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&ShareCommentLayer::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(ShareCommentLayer*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x476690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ShareCommentLayer::init(gd::string title, int charLimit, CommentType type, int ID, gd::string desc) -> decltype(init(title, charLimit, type, ID, desc)) {
	using FunctionType = decltype(init(title, charLimit, type, ID, desc))(*)(ShareCommentLayer*, gd::string, int, CommentType, int, gd::string);
	static auto func = wrapFunction(base::get() + 0x474b40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, title, charLimit, type, ID, desc);
}

auto ShareCommentLayer::onClear(cocos2d::CCObject* sender) -> decltype(onClear(sender)) {
	using FunctionType = decltype(onClear(sender))(*)(ShareCommentLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x475c20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ShareCommentLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(ShareCommentLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x476130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ShareCommentLayer::onPercent(cocos2d::CCObject* sender) -> decltype(onPercent(sender)) {
	using FunctionType = decltype(onPercent(sender))(*)(ShareCommentLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x475c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ShareCommentLayer::onShare(cocos2d::CCObject* sender) -> decltype(onShare(sender)) {
	using FunctionType = decltype(onShare(sender))(*)(ShareCommentLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x475d90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

void ShareCommentLayer::updateCharCountLabel() {
        if (m_charLimit * .9f <= m_descText.size()) {
            m_charCountLabel->setColor({ 255, 0, 0 });
            m_charCountLabel->setOpacity(255);
        } else if (m_charLimit * .7f <= m_descText.size()) {
            m_charCountLabel->setColor({ 0, 0, 0 });
            m_charCountLabel->setOpacity(255);
        } else {
            m_charCountLabel->setColor({ 0, 0, 0 });
            m_charCountLabel->setOpacity(125);
        }
        m_charCountLabel->setString(cocos2d::CCString::createWithFormat("%i", m_charLimit - m_descText.size())->getCString());
    }

auto ShareCommentLayer::updatePercentLabel() -> decltype(updatePercentLabel()) {
	using FunctionType = decltype(updatePercentLabel())(*)(ShareCommentLayer*);
	static auto func = wrapFunction(base::get() + 0x475cb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

ShareLevelLayer::ShareLevelLayer() {
        m_level = nullptr;
        m_starsRequested = 0;
        m_starButtons = nullptr;
    }

ShareLevelLayer* ShareLevelLayer::create(GJGameLevel* level) {
        auto ret = new ShareLevelLayer();
        if (ret->init(level)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto ShareLevelLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ShareLevelLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(ShareLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x478bb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

CCMenuItemSpriteExtra* ShareLevelLayer::getStarsButton(int btnID, cocos2d::SEL_MenuHandler callback, cocos2d::CCMenu* menu, float scale) {
        auto btnSpr = ButtonSprite::create(cocos2d::CCString::createWithFormat("%i", btnID)->getCString(), 20, 0, .5f, true, "bigFont.fnt", "GJ_button_01.png", 30.f);
        auto btn = CCMenuItemSpriteExtra::create(btnSpr, this, callback);
        btn->setScale(scale);
        btn->m_baseScale = scale;
        if (menu) menu->addChild(btn);
        return btn;
    }

auto ShareLevelLayer::init(GJGameLevel* level) -> decltype(init(level)) {
	using FunctionType = decltype(init(level))(*)(ShareLevelLayer*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x4769e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, level);
}

auto ShareLevelLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(ShareLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x84620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ShareLevelLayer::onSettings(cocos2d::CCObject* sender) -> decltype(onSettings(sender)) {
	using FunctionType = decltype(onSettings(sender))(*)(ShareLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x477c40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ShareLevelLayer::onShare(cocos2d::CCObject* sender) -> decltype(onShare(sender)) {
	using FunctionType = decltype(onShare(sender))(*)(ShareLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x477d90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ShareLevelLayer::selectRating(cocos2d::CCObject* p0) -> decltype(selectRating(p0)) {
	using FunctionType = decltype(selectRating(p0))(*)(ShareLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x477ab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ShareLevelLayer::setupStars() -> decltype(setupStars()) {
	using FunctionType = decltype(setupStars())(*)(ShareLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x4776a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

ShareLevelSettingsLayer::ShareLevelSettingsLayer() {}

ShareLevelSettingsLayer* ShareLevelSettingsLayer::create(GJGameLevel* level) {
        auto ret = new ShareLevelSettingsLayer();
        if (ret->init(level)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto ShareLevelSettingsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ShareLevelSettingsLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(ShareLevelSettingsLayer*);
	static auto func = wrapFunction(base::get() + 0x4799c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ShareLevelSettingsLayer::init(GJGameLevel* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(ShareLevelSettingsLayer*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x478c00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ShareLevelSettingsLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(ShareLevelSettingsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x479940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ShareLevelSettingsLayer::onUnlisted(cocos2d::CCObject* sender) -> decltype(onUnlisted(sender)) {
	using FunctionType = decltype(onUnlisted(sender))(*)(ShareLevelSettingsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x479620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

ShareListLayer::ShareListLayer() {
        m_list = nullptr;
        m_friendsOnlyToggler = nullptr;
        m_friendsOnlyLabel = nullptr;
    }

ShareListLayer* ShareListLayer::create(GJLevelList* list) {
        auto ret = new ShareListLayer();
        if (ret->init(list)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto ShareListLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("ShareListLayer::keyBackClicked not implemented");
}

auto ShareListLayer::init(GJLevelList* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(ShareListLayer*, GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x2f50d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ShareListLayer::onInfo(cocos2d::CCObject* sender) -> decltype(onInfo(sender)) {
	using FunctionType = decltype(onInfo(sender))(*)(ShareListLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f6270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ShareListLayer::onShare(cocos2d::CCObject* sender) -> decltype(onShare(sender)) {
	using FunctionType = decltype(onShare(sender))(*)(ShareListLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f6530, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ShareListLayer::onUnlisted(cocos2d::CCObject* sender) -> decltype(onUnlisted(sender)) {
	using FunctionType = decltype(onUnlisted(sender))(*)(ShareListLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f63e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SimplePlayer::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x271ac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto SimplePlayer::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&SimplePlayer::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(SimplePlayer*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x272e70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SimplePlayer::setColor(cocos2d::ccColor3B const& p0) -> decltype(setColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B const&>::func(&SimplePlayer::setColor), this);
	using FunctionType = decltype(setColor(p0))(*)(SimplePlayer*, cocos2d::ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x272320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

void SimplePlayer::createRobotSprite(int frame) {
        if (m_robotSprite) return;
        auto robotSprite = GJRobotSprite::create(frame);
        m_robotSprite = robotSprite;
        addChild(robotSprite);
        m_robotSprite->setVisible(false);
    }

auto SimplePlayer::createSpiderSprite(int p0) -> decltype(createSpiderSprite(p0)) {
	using FunctionType = decltype(createSpiderSprite(p0))(*)(SimplePlayer*, int);
	static auto func = wrapFunction(base::get() + 0x272290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void SimplePlayer::disableCustomGlowColor() {
        m_hasCustomGlowColor = false;
    }

void SimplePlayer::enableCustomGlowColor(cocos2d::ccColor3B const& color) {
        m_hasCustomGlowColor = true;
        m_glowColor = color;
    }

void SimplePlayer::hideAll() {
        m_firstLayer->setVisible(false);
        m_secondLayer->setVisible(false);
        if (m_birdDome) m_birdDome->setVisible(false);
        if (m_outlineSprite) m_outlineSprite->setVisible(false);
        if (m_detailSprite) m_detailSprite->setVisible(false);
        if (m_robotSprite) m_robotSprite->setVisible(false);
        if (m_spiderSprite) m_spiderSprite->setVisible(false);
    }

void SimplePlayer::hideSecondary() {
        m_secondLayer->setVisible(false);
        m_birdDome->setVisible(false);
        m_detailSprite->setVisible(false);
        m_outlineSprite->setVisible(false);
        if (m_robotSprite) {
            m_robotSprite->hideSecondary();
            m_robotSprite->m_glowSprite->setVisible(false);
        }
        if (m_spiderSprite) {
            m_spiderSprite->hideSecondary();
            m_spiderSprite->m_glowSprite->setVisible(false);
        }
    }

auto SimplePlayer::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(SimplePlayer*, int);
	static auto func = wrapFunction(base::get() + 0x271bb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void SimplePlayer::setColors(cocos2d::ccColor3B const& color1, cocos2d::ccColor3B const& color2) {
        m_firstLayer->setColor(color1);
        m_secondLayer->setColor(color2);
        updateColors();
    }

auto SimplePlayer::setFrames(char const* p0, char const* p1, char const* p2, char const* p3, char const* p4) -> decltype(setFrames(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(setFrames(p0, p1, p2, p3, p4))(*)(SimplePlayer*, char const*, char const*, char const*, char const*, char const*);
	static auto func = wrapFunction(base::get() + 0x272c40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

void SimplePlayer::setSecondColor(cocos2d::ccColor3B const& color) {
        m_secondLayer->setColor(color);
        updateColors();
    }

auto SimplePlayer::updateColors() -> decltype(updateColors()) {
	using FunctionType = decltype(updateColors())(*)(SimplePlayer*);
	static auto func = wrapFunction(base::get() + 0x272350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SimplePlayer::updatePlayerFrame(int p0, IconType p1) -> decltype(updatePlayerFrame(p0, p1)) {
	using FunctionType = decltype(updatePlayerFrame(p0, p1))(*)(SimplePlayer*, int, IconType);
	static auto func = wrapFunction(base::get() + 0x272710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SlideInLayer::init() -> decltype(init()) {
	throw std::runtime_error("SlideInLayer::init not implemented");
}

auto SlideInLayer::draw() -> decltype(draw()) {
	throw std::runtime_error("SlideInLayer::draw not implemented");
}

auto SlideInLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	throw std::runtime_error("SlideInLayer::ccTouchBegan not implemented");
}

auto SlideInLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	throw std::runtime_error("SlideInLayer::ccTouchMoved not implemented");
}

auto SlideInLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	throw std::runtime_error("SlideInLayer::ccTouchEnded not implemented");
}

auto SlideInLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	throw std::runtime_error("SlideInLayer::ccTouchCancelled not implemented");
}

auto SlideInLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("SlideInLayer::registerWithTouchDispatcher not implemented");
}

auto SlideInLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("SlideInLayer::keyBackClicked not implemented");
}

auto SlideInLayer::customSetup() -> decltype(customSetup()) {
	throw std::runtime_error("SlideInLayer::customSetup not implemented");
}

auto SlideInLayer::enterLayer() -> decltype(enterLayer()) {
	throw std::runtime_error("SlideInLayer::enterLayer not implemented");
}

auto SlideInLayer::exitLayer(cocos2d::CCObject* p0) -> decltype(exitLayer(p0)) {
	throw std::runtime_error("SlideInLayer::exitLayer not implemented");
}

auto SlideInLayer::showLayer(bool p0) -> decltype(showLayer(p0)) {
	throw std::runtime_error("SlideInLayer::showLayer not implemented");
}

auto SlideInLayer::hideLayer(bool p0) -> decltype(hideLayer(p0)) {
	throw std::runtime_error("SlideInLayer::hideLayer not implemented");
}

auto SlideInLayer::layerVisible() -> decltype(layerVisible()) {
	throw std::runtime_error("SlideInLayer::layerVisible not implemented");
}

auto SlideInLayer::layerHidden() -> decltype(layerHidden()) {
	throw std::runtime_error("SlideInLayer::layerHidden not implemented");
}

auto SlideInLayer::enterAnimFinished() -> decltype(enterAnimFinished()) {
	throw std::runtime_error("SlideInLayer::enterAnimFinished not implemented");
}

auto SlideInLayer::disableUI() -> decltype(disableUI()) {
	throw std::runtime_error("SlideInLayer::disableUI not implemented");
}

auto SlideInLayer::enableUI() -> decltype(enableUI()) {
	throw std::runtime_error("SlideInLayer::enableUI not implemented");
}

auto SliderThumb::getValue() -> decltype(getValue()) {
	using FunctionType = decltype(getValue())(*)(SliderThumb*);
	static auto func = wrapFunction(base::get() + 0x712b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void SliderThumb::setMaxOffset(float offset) {
        float value = getValue();
        m_length = offset;
        this->setPosition({0, 0});
        setValue(value);
    }

void SliderThumb::setRotated(bool rotated) {
        float value = getValue();
        m_vertical = rotated;
        this->setPosition({0, 0});
        setValue(value);
    }

auto SliderThumb::setValue(float p0) -> decltype(setValue(p0)) {
	using FunctionType = decltype(setValue(p0))(*)(SliderThumb*, float);
	static auto func = wrapFunction(base::get() + 0x71340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SliderTouchLogic::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&SliderTouchLogic::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(SliderTouchLogic*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x714b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SliderTouchLogic::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&SliderTouchLogic::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(SliderTouchLogic*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x715a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SliderTouchLogic::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&SliderTouchLogic::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(SliderTouchLogic*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x71560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SliderTouchLogic::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("SliderTouchLogic::registerWithTouchDispatcher not implemented");
}

void SliderTouchLogic::setMaxOffset(float offset) {
        float newOffset = m_thumb->getScale() * offset;
        m_length = newOffset;
        m_thumb->setMaxOffset(newOffset);
    }

void SliderTouchLogic::setRotated(bool rotated) {
        m_rotated = rotated;
        m_thumb->setRotated(rotated);
    }

auto Slider::create(cocos2d::CCNode* target, cocos2d::SEL_MenuHandler handler, char const* bar, char const* groove, char const* thumb, char const* thumbSel, float scale) -> decltype(create(target, handler, bar, groove, thumb, thumbSel, scale)) {
	using FunctionType = decltype(create(target, handler, bar, groove, thumb, thumbSel, scale))(*)(cocos2d::CCNode*, cocos2d::SEL_MenuHandler, char const*, char const*, char const*, char const*, float);
	static auto func = wrapFunction(base::get() + 0x71720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(target, handler, bar, groove, thumb, thumbSel, scale);
}

Slider* Slider::create(cocos2d::CCNode* target, cocos2d::SEL_MenuHandler handler) {
        return Slider::create(target, handler, 1.f);
    }

Slider* Slider::create(cocos2d::CCNode* target, cocos2d::SEL_MenuHandler handler, float scale) {
        return Slider::create(target, handler, "sliderBar.png", "slidergroove.png", "sliderthumb.png", "sliderthumbsel.png", scale);
    }

auto Slider::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&Slider::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(Slider*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x71d10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto Slider::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&Slider::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(Slider*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x71d50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto Slider::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&Slider::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(Slider*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x71d30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

bool Slider::getLiveDragging() {
        return m_touchLogic->m_activateThumb;
    }

SliderThumb* Slider::getThumb() {
        return m_touchLogic->m_thumb;
    }

float Slider::getValue() {
        return this->getThumb()->getValue();
    }

void Slider::hideGroove(bool visibility) {
        m_groove->setVisible(!visibility);
    }

auto Slider::init(cocos2d::CCNode* p0, cocos2d::SEL_MenuHandler p1, char const* p2, char const* p3, char const* p4, char const* p5, float p6) -> decltype(init(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5, p6))(*)(Slider*, cocos2d::CCNode*, cocos2d::SEL_MenuHandler, char const*, char const*, char const*, char const*, float);
	static auto func = wrapFunction(base::get() + 0x71850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6);
}

void Slider::setBarVisibility(bool visibility) {
        m_sliderBar->setVisible(visibility);
    }

void Slider::setLiveDragging(bool activateThumb) {
        m_touchLogic->m_activateThumb = activateThumb;
    }

void Slider::setMaxOffset(float offset) {
        m_touchLogic->setMaxOffset(offset);
    }

void Slider::setRotated(bool rotated) {
        m_touchLogic->setRotated(rotated);
        m_groove->setRotation((rotated) ? -90 : 0);
    }

auto Slider::setValue(float val) -> decltype(setValue(val)) {
	using FunctionType = decltype(setValue(val))(*)(Slider*, float);
	static auto func = wrapFunction(base::get() + 0x71c00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, val);
}

void Slider::updateBar() {
        float local_8;
        auto thumb = this->getThumb();
        if (!thumb->m_vertical) {
            local_8 = thumb->getPositionX();
        } else {
            local_8 = thumb->getPositionY();
        }

        float local_c = thumb->getScale() * thumb->m_length * 0.5f + local_8;
        float fVar6 = m_width;
        local_c = local_c / (thumb->getScale() * thumb->m_length);
        if (fVar6 * local_c <= fVar6) {
            fVar6 = fVar6 * local_c;
        }

        this->m_sliderBar->setTextureRect(cocos2d::CCRect(0.0f, 0.0f, fVar6, m_height));
    }

auto SmartGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("SmartGameObject::customObjectSetup not implemented");
}

auto SmartGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("SmartGameObject::getSaveString not implemented");
}

auto SmartTemplateCell::init() -> decltype(init()) {
	throw std::runtime_error("SmartTemplateCell::init not implemented");
}

auto SmartTemplateCell::draw() -> decltype(draw()) {
	throw std::runtime_error("SmartTemplateCell::draw not implemented");
}

auto SmartTemplateCell::loadFromObject(GJSmartTemplate* p0) -> decltype(loadFromObject(p0)) {
	using FunctionType = decltype(loadFromObject(p0))(*)(SmartTemplateCell*, GJSmartTemplate*);
	static auto func = wrapFunction(base::get() + 0xbd8c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SmartTemplateCell::updateBGColor(int p0) -> decltype(updateBGColor(p0)) {
	using FunctionType = decltype(updateBGColor(p0))(*)(SmartTemplateCell*, int);
	static auto func = wrapFunction(base::get() + 0xbdcb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SongCell::init() -> decltype(init()) {
	throw std::runtime_error("SongCell::init not implemented");
}

auto SongCell::draw() -> decltype(draw()) {
	throw std::runtime_error("SongCell::draw not implemented");
}

auto SongCell::loadFromObject(SongObject* p0) -> decltype(loadFromObject(p0)) {
	using FunctionType = decltype(loadFromObject(p0))(*)(SongCell*, SongObject*);
	static auto func = wrapFunction(base::get() + 0xb3990, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SongInfoLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("SongInfoLayer::keyBackClicked not implemented");
}

auto SongInfoLayer::init(gd::string p0, gd::string p1, gd::string p2, gd::string p3, gd::string p4, gd::string p5, int p6, gd::string p7, int p8) -> decltype(init(p0, p1, p2, p3, p4, p5, p6, p7, p8)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5, p6, p7, p8))(*)(SongInfoLayer*, gd::string, gd::string, gd::string, gd::string, gd::string, gd::string, int, gd::string, int);
	static auto func = wrapFunction(base::get() + 0x47a450, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7, p8);
}

auto SongInfoObject::create(int songID, gd::string songName, gd::string artistName, int artistID, float filesize, gd::string youtubeVideo, gd::string youtubeChannel, gd::string url, int nongType, gd::string extraArtistIDs, bool isNew, int newType, int priority) -> decltype(create(songID, songName, artistName, artistID, filesize, youtubeVideo, youtubeChannel, url, nongType, extraArtistIDs, isNew, newType, priority)) {
	using FunctionType = decltype(create(songID, songName, artistName, artistID, filesize, youtubeVideo, youtubeChannel, url, nongType, extraArtistIDs, isNew, newType, priority))(*)(int, gd::string, gd::string, int, float, gd::string, gd::string, gd::string, int, gd::string, bool, int, int);
	static auto func = wrapFunction(base::get() + 0x3300c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(songID, songName, artistName, artistID, filesize, youtubeVideo, youtubeChannel, url, nongType, extraArtistIDs, isNew, newType, priority);
}

auto SongInfoObject::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x32ef70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto SongInfoObject::encodeWithCoder(DS_Dictionary* p0) -> decltype(encodeWithCoder(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&SongInfoObject::encodeWithCoder), this);
	using FunctionType = decltype(encodeWithCoder(p0))(*)(SongInfoObject*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x3309a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SongInfoObject::canEncode() -> decltype(canEncode()) {
	throw std::runtime_error("SongInfoObject::canEncode not implemented");
}

auto SongInfoObject::createWithCoder(DS_Dictionary* p0) -> decltype(createWithCoder(p0)) {
	using FunctionType = decltype(createWithCoder(p0))(*)(SongInfoObject*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x330690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

SongObject::SongObject() {
        m_audioID = 0;
    }

SongObject* SongObject::create(int audioID) {
        auto ret = new SongObject();
        if(ret->init(audioID)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

bool SongObject::init(int audioID) {
        m_audioID = audioID;
        return true;
    }

auto SongOptionsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SongOptionsLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SongOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0xc4920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SongSelectNode::create(int p0, bool p1, LevelSettingsObject* p2, SongSelectType p3, cocos2d::CCPoint p4, cocos2d::CCNode* p5, cocos2d::CCMenu* p6, bool p7) -> decltype(create(p0, p1, p2, p3, p4, p5, p6, p7)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5, p6, p7))(*)(int, bool, LevelSettingsObject*, SongSelectType, cocos2d::CCPoint, cocos2d::CCNode*, cocos2d::CCMenu*, bool);
	static auto func = wrapFunction(base::get() + 0xc5f80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5, p6, p7);
}

auto SongSelectNode::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&SongSelectNode::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(SongSelectNode*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0xc6fe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SongSelectNode::customSongLayerClosed() -> decltype(customSongLayerClosed()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SongSelectNode::customSongLayerClosed), this);
	using FunctionType = decltype(customSongLayerClosed())(*)(SongSelectNode*);
	static auto func = wrapFunction(base::get() + 0xc7070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SongSelectNode::songIDChanged(int p0) -> decltype(songIDChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&SongSelectNode::songIDChanged), this);
	using FunctionType = decltype(songIDChanged(p0))(*)(SongSelectNode*, int);
	static auto func = wrapFunction(base::get() + 0xc70a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SongSelectNode::getActiveSongID() -> decltype(getActiveSongID()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SongSelectNode::getActiveSongID), this);
	using FunctionType = decltype(getActiveSongID())(*)(SongSelectNode*);
	static auto func = wrapFunction(base::get() + 0xc70b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SongSelectNode::getSongFileName() -> decltype(getSongFileName()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SongSelectNode::getSongFileName), this);
	using FunctionType = decltype(getSongFileName())(*)(SongSelectNode*);
	static auto func = wrapFunction(base::get() + 0xc70c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SongSelectNode::getLevelSettings() -> decltype(getLevelSettings()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SongSelectNode::getLevelSettings), this);
	using FunctionType = decltype(getLevelSettings())(*)(SongSelectNode*);
	static auto func = wrapFunction(base::get() + 0xc7180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SongSelectNode::audioNext(cocos2d::CCObject* sender) -> decltype(audioNext(sender)) {
	using FunctionType = decltype(audioNext(sender))(*)(SongSelectNode*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xc6ab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SongSelectNode::audioPrevious(cocos2d::CCObject* sender) -> decltype(audioPrevious(sender)) {
	using FunctionType = decltype(audioPrevious(sender))(*)(SongSelectNode*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xc6af0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SongSelectNode::init(int p0, bool p1, LevelSettingsObject* p2, SongSelectType p3, cocos2d::CCPoint p4, cocos2d::CCNode* p5, cocos2d::CCMenu* p6, bool p7) -> decltype(init(p0, p1, p2, p3, p4, p5, p6, p7)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5, p6, p7))(*)(SongSelectNode*, int, bool, LevelSettingsObject*, SongSelectType, cocos2d::CCPoint, cocos2d::CCNode*, cocos2d::CCMenu*, bool);
	static auto func = wrapFunction(base::get() + 0xc60b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7);
}

auto SongSelectNode::onSongMode(int p0) -> decltype(onSongMode(p0)) {
	using FunctionType = decltype(onSongMode(p0))(*)(SongSelectNode*, int);
	static auto func = wrapFunction(base::get() + 0xc6b50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void SongSelectNode::selectSong(int id) {
        auto songID = id;
        if (songID > 21) songID = 21;
        m_songChanged = true;
        if (songID < 0) songID = 0;
        m_selectedSongID = songID;
        this->updateAudioLabel();
    }

auto SongSelectNode::showCustomSongSelect() -> decltype(showCustomSongSelect()) {
	using FunctionType = decltype(showCustomSongSelect())(*)(SongSelectNode*);
	static auto func = wrapFunction(base::get() + 0xc6e80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SongSelectNode::updateAudioLabel() -> decltype(updateAudioLabel()) {
	using FunctionType = decltype(updateAudioLabel())(*)(SongSelectNode*);
	static auto func = wrapFunction(base::get() + 0xc69c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SongSelectNode::updateWidgetVisibility() -> decltype(updateWidgetVisibility()) {
	using FunctionType = decltype(updateWidgetVisibility())(*)(SongSelectNode*);
	static auto func = wrapFunction(base::get() + 0xc6d70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SongsLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x47bf80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto SongsLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SongsLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(SongsLayer*);
	static auto func = wrapFunction(base::get() + 0x47c050, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SongTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("SongTriggerGameObject::customObjectSetup not implemented");
}

auto SongTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("SongTriggerGameObject::getSaveString not implemented");
}

auto SpawnParticleGameObject::init() -> decltype(init()) {
	throw std::runtime_error("SpawnParticleGameObject::init not implemented");
}

auto SpawnParticleGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("SpawnParticleGameObject::customObjectSetup not implemented");
}

auto SpawnParticleGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("SpawnParticleGameObject::getSaveString not implemented");
}

auto SpawnTriggerGameObject::init() -> decltype(init()) {
	throw std::runtime_error("SpawnTriggerGameObject::init not implemented");
}

auto SpawnTriggerGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*, int, gd::vector<int> const*>::func(&SpawnTriggerGameObject::triggerObject), this);
	using FunctionType = decltype(triggerObject(p0, p1, p2))(*)(SpawnTriggerGameObject*, GJBaseGameLayer*, int, gd::vector<int> const*);
	static auto func = wrapFunction(base::get() + 0x4a06a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto SpawnTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("SpawnTriggerGameObject::customObjectSetup not implemented");
}

auto SpawnTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("SpawnTriggerGameObject::getSaveString not implemented");
}

auto SpawnTriggerGameObject::updateRemapKeys(gd::vector<int> const& p0) -> decltype(updateRemapKeys(p0)) {
	using FunctionType = decltype(updateRemapKeys(p0))(*)(SpawnTriggerGameObject*, gd::vector<int> const&);
	static auto func = wrapFunction(base::get() + 0x4a05a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SpecialAnimGameObject::resetObject() -> decltype(resetObject()) {
	throw std::runtime_error("SpecialAnimGameObject::resetObject not implemented");
}

auto SpecialAnimGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("SpecialAnimGameObject::customObjectSetup not implemented");
}

auto SpecialAnimGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("SpecialAnimGameObject::getSaveString not implemented");
}

auto SpecialAnimGameObject::updateMainColor(cocos2d::ccColor3B const& p0) -> decltype(updateMainColor(p0)) {
	throw std::runtime_error("SpecialAnimGameObject::updateMainColor not implemented");
}

auto SpecialAnimGameObject::updateSecondaryColor(cocos2d::ccColor3B const& p0) -> decltype(updateSecondaryColor(p0)) {
	throw std::runtime_error("SpecialAnimGameObject::updateSecondaryColor not implemented");
}

auto SpecialAnimGameObject::updateSyncedAnimation(float p0, int p1) -> decltype(updateSyncedAnimation(p0, p1)) {
	throw std::runtime_error("SpecialAnimGameObject::updateSyncedAnimation not implemented");
}

auto SpriteAnimationManager::overridePrio() -> decltype(overridePrio()) {
	using FunctionType = decltype(overridePrio())(*)(SpriteAnimationManager*);
	static auto func = wrapFunction(base::get() + 0x74420, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void SpriteAnimationManager::stopAnimations() {
        this->overridePrio();
        if (m_sprite->m_paSprite) m_sprite->m_paSprite->stopAllActions();
        if (m_sprite->m_fbfSprite) m_sprite->m_fbfSprite->stopAllActions();
    }

SpriteDescription::SpriteDescription() {
        m_position = cocos2d::CCPointMake(0.f, 0.f);
        m_scale = cocos2d::CCPointMake(0.f, 0.f);
        m_flipped = cocos2d::CCPointMake(0.f, 0.f);
        m_rotation = 0;
        m_zValue = 0;
        m_tag = 0;
        m_usesCustomTag = false;
        m_texture = nullptr;
    }

SpriteDescription* SpriteDescription::createDescription(cocos2d::CCDictionary* dict) {
        auto ret = new SpriteDescription();
        if (ret->initDescription(dict)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

SpriteDescription* SpriteDescription::createDescription(DS_Dictionary* dict) {
        auto ret = new SpriteDescription();
        if (ret->initDescription(dict)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

bool SpriteDescription::initDescription(cocos2d::CCDictionary* dict) {
        m_position = cocos2d::CCPointFromString(dict->valueForKey("position")->getCString());
        m_scale = cocos2d::CCPointFromString(dict->valueForKey("scale")->getCString());
        m_flipped = cocos2d::CCPointFromString(dict->valueForKey("flipped")->getCString());
        m_rotation = dict->valueForKey("rotation")->floatValue();
        m_zValue = dict->valueForKey("zValue")->intValue();
        m_tag = dict->valueForKey("tag")->intValue();
        m_usesCustomTag = dict->valueForKey("usesCustomTag")->boolValue();
        if (m_usesCustomTag) {
            auto frameName = dict->valueForKey("texture")->getCString();
            m_texture = cocos2d::CCSpriteFrameCache::sharedSpriteFrameCache()->spriteFrameByName(frameName);
            m_texture->retain();
            m_texture->setFrameName(frameName);
        }
        return true;
    }

auto SpriteDescription::initDescription(DS_Dictionary* dict) -> decltype(initDescription(dict)) {
	using FunctionType = decltype(initDescription(dict))(*)(SpriteDescription*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x41cf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, dict);
}

auto StarInfoPopup::create(int p0, int p1, int p2, int p3, int p4, int p5, int p6, int p7, int p8, bool p9) -> decltype(create(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9))(*)(int, int, int, int, int, int, int, int, int, bool);
	static auto func = wrapFunction(base::get() + 0x3b0cb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
}

auto StarInfoPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("StarInfoPopup::keyBackClicked not implemented");
}

auto StarInfoPopup::init(int p0, int p1, int p2, int p3, int p4, int p5, int p6, int p7, int p8, bool p9) -> decltype(init(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9))(*)(StarInfoPopup*, int, int, int, int, int, int, int, int, int, bool);
	static auto func = wrapFunction(base::get() + 0x3b0df0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
}

auto StartPosObject::init() -> decltype(init()) {
	throw std::runtime_error("StartPosObject::init not implemented");
}

auto StartPosObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("StartPosObject::customObjectSetup not implemented");
}

auto StartPosObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("StartPosObject::getSaveString not implemented");
}

auto StatsCell::init() -> decltype(init()) {
	throw std::runtime_error("StatsCell::init not implemented");
}

auto StatsCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&StatsCell::draw), this);
	using FunctionType = decltype(draw())(*)(StatsCell*);
	static auto func = wrapFunction(base::get() + 0xad710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto StatsCell::loadFromObject(StatsObject* p0) -> decltype(loadFromObject(p0)) {
	using FunctionType = decltype(loadFromObject(p0))(*)(StatsCell*, StatsObject*);
	static auto func = wrapFunction(base::get() + 0xb2630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto StatsLayer::customSetup() -> decltype(customSetup()) {
	throw std::runtime_error("StatsLayer::customSetup not implemented");
}

auto SupportLayer::customSetup() -> decltype(customSetup()) {
	throw std::runtime_error("SupportLayer::customSetup not implemented");
}

auto SupportLayer::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&SupportLayer::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(p0, p1))(*)(SupportLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x4b0fb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SupportLayer::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&SupportLayer::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(p0, p1))(*)(SupportLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x4b10f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SupportLayer::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&SupportLayer::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(SupportLayer*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x4b0f70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SupportLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&SupportLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(SupportLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x4b1d70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SupportLayer::onLowDetail(cocos2d::CCObject* sender) -> decltype(onLowDetail(sender)) {
	using FunctionType = decltype(onLowDetail(sender))(*)(SupportLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4b1180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SupportLayer::onRequestAccess(cocos2d::CCObject* sender) -> decltype(onRequestAccess(sender)) {
	using FunctionType = decltype(onRequestAccess(sender))(*)(SupportLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4b0d30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

TableView* TableView::create(TableViewDelegate* tvd, TableViewDataSource* tvds, TableViewCellDelegate* tvcd, cocos2d::CCRect rect) {
        auto ret = new TableView(rect);
        ret->m_tableDelegate = tvd;
        ret->m_dataSource = tvds;
        ret->m_cellDelegate = tvcd;
        ret->setPosition({ 0.f, 0.f });
        ret->autorelease();
        return ret;
    }

void TableView::onEnter() { cocos2d::CCLayer::onEnter(); }

void TableView::onExit() { cocos2d::CCLayer::onExit(); }

auto TableView::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&TableView::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(TableView*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x75250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto TableView::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&TableView::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(TableView*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x754e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto TableView::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&TableView::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(TableView*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x75400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto TableView::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&TableView::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(TableView*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x75460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto TableView::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&TableView::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(TableView*);
	static auto func = wrapFunction(base::get() + 0x3e5a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto TableView::scrollWheel(float p0, float p1) -> decltype(scrollWheel(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, float>::func(&TableView::scrollWheel), this);
	using FunctionType = decltype(scrollWheel(p0, p1))(*)(TableView*, float, float);
	static auto func = wrapFunction(base::get() + 0x75a90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void TableView::scrllViewWillBeginDecelerating(CCScrollLayerExt* p0) {}

void TableView::scrollViewDidEndDecelerating(CCScrollLayerExt* p0) {}

void TableView::scrollViewTouchMoving(CCScrollLayerExt* p0) {}

void TableView::scrollViewDidEndMoving(CCScrollLayerExt* p0) {}

auto TableView::reloadData() -> decltype(reloadData()) {
	using FunctionType = decltype(reloadData())(*)(TableView*);
	static auto func = wrapFunction(base::get() + 0x74d00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto TeleportPortalObject::create(char const* p0, bool p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(char const*, bool);
	static auto func = wrapFunction(base::get() + 0x499670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto TeleportPortalObject::setPosition(cocos2d::CCPoint const& p0) -> decltype(setPosition(p0)) {
	throw std::runtime_error("TeleportPortalObject::setPosition not implemented");
}

auto TeleportPortalObject::setRotation(float p0) -> decltype(setRotation(p0)) {
	throw std::runtime_error("TeleportPortalObject::setRotation not implemented");
}

auto TeleportPortalObject::setStartPos(cocos2d::CCPoint p0) -> decltype(setStartPos(p0)) {
	throw std::runtime_error("TeleportPortalObject::setStartPos not implemented");
}

auto TeleportPortalObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("TeleportPortalObject::customObjectSetup not implemented");
}

auto TeleportPortalObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("TeleportPortalObject::getSaveString not implemented");
}

auto TeleportPortalObject::addToGroup(int p0) -> decltype(addToGroup(p0)) {
	throw std::runtime_error("TeleportPortalObject::addToGroup not implemented");
}

auto TeleportPortalObject::removeFromGroup(int p0) -> decltype(removeFromGroup(p0)) {
	throw std::runtime_error("TeleportPortalObject::removeFromGroup not implemented");
}

auto TeleportPortalObject::setRotation2(float p0) -> decltype(setRotation2(p0)) {
	throw std::runtime_error("TeleportPortalObject::setRotation2 not implemented");
}

auto TeleportPortalObject::addToGroup2(int p0) -> decltype(addToGroup2(p0)) {
	throw std::runtime_error("TeleportPortalObject::addToGroup2 not implemented");
}

auto TeleportPortalObject::removeFromGroup2(int p0) -> decltype(removeFromGroup2(p0)) {
	throw std::runtime_error("TeleportPortalObject::removeFromGroup2 not implemented");
}

auto TeleportPortalObject::getTeleportXOff(cocos2d::CCNode* p0) -> decltype(getTeleportXOff(p0)) {
	using FunctionType = decltype(getTeleportXOff(p0))(*)(TeleportPortalObject*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x4998f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto TextAlertPopup::create(gd::string text, float delay, float scale, int opacity, gd::string font) -> decltype(create(text, delay, scale, opacity, font)) {
	using FunctionType = decltype(create(text, delay, scale, opacity, font))(*)(gd::string, float, float, int, gd::string);
	static auto func = wrapFunction(base::get() + 0x2964a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(text, delay, scale, opacity, font);
}

auto TextAlertPopup::init(gd::string text, float delay, float scale, int opacity, gd::string font) -> decltype(init(text, delay, scale, opacity, font)) {
	using FunctionType = decltype(init(text, delay, scale, opacity, font))(*)(TextAlertPopup*, gd::string, float, float, int, gd::string);
	static auto func = wrapFunction(base::get() + 0x2965d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, text, delay, scale, opacity, font);
}

void TextAlertPopup::setAlertPosition(cocos2d::CCPoint windowOffset, cocos2d::CCPoint pointOffset) {
        if (!m_label) return;

        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        this->setPosition({
            windowOffset.x * winSize.width + m_width / 2 + pointOffset.x,
            windowOffset.y * winSize.height + m_height / 2 + pointOffset.y
        });
    }

void TextAlertPopup::setLabelColor(cocos2d::ccColor3B color) {
        if (m_label) m_label->setColor(color);
    }

auto TextArea::create(gd::string str, char const* font, float scale, float width, cocos2d::CCPoint anchor, float lineHeight, bool disableColor) -> decltype(create(str, font, scale, width, anchor, lineHeight, disableColor)) {
	using FunctionType = decltype(create(str, font, scale, width, anchor, lineHeight, disableColor))(*)(gd::string, char const*, float, float, cocos2d::CCPoint, float, bool);
	static auto func = wrapFunction(base::get() + 0x76e50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(str, font, scale, width, anchor, lineHeight, disableColor);
}

auto TextArea::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&TextArea::update), this);
	using FunctionType = decltype(update(p0))(*)(TextArea*, float);
	static auto func = wrapFunction(base::get() + 0x776b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

void TextArea::draw() {}

auto TextArea::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&TextArea::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(TextArea*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x775c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto TextArea::colorAllCharactersTo(cocos2d::ccColor3B p0) -> decltype(colorAllCharactersTo(p0)) {
	using FunctionType = decltype(colorAllCharactersTo(p0))(*)(TextArea*, cocos2d::ccColor3B);
	static auto func = wrapFunction(base::get() + 0x77600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto TextArea::finishFade() -> decltype(finishFade()) {
	using FunctionType = decltype(finishFade())(*)(TextArea*);
	static auto func = wrapFunction(base::get() + 0x775a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto TextArea::setString(gd::string p0) -> decltype(setString(p0)) {
	using FunctionType = decltype(setString(p0))(*)(TextArea*, gd::string);
	static auto func = wrapFunction(base::get() + 0x77090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto TextArea::stopAllCharacterActions() -> decltype(stopAllCharacterActions()) {
	using FunctionType = decltype(stopAllCharacterActions())(*)(TextArea*);
	static auto func = wrapFunction(base::get() + 0x774e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto TextGameObject::create(cocos2d::CCTexture2D* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x1a4530, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto TextGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("TextGameObject::customObjectSetup not implemented");
}

auto TextGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("TextGameObject::getSaveString not implemented");
}

auto TextGameObject::updateTextKerning(int p0) -> decltype(updateTextKerning(p0)) {
	throw std::runtime_error("TextGameObject::updateTextKerning not implemented");
}

auto TextGameObject::getTextKerning() -> decltype(getTextKerning()) {
	throw std::runtime_error("TextGameObject::getTextKerning not implemented");
}

auto TextGameObject::updateTextObject(gd::string p0, bool p1) -> decltype(updateTextObject(p0, p1)) {
	using FunctionType = decltype(updateTextObject(p0, p1))(*)(TextGameObject*, gd::string, bool);
	static auto func = wrapFunction(base::get() + 0x1a4620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto TextStyleSection::create(int p0, int p1, TextStyleType p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(int, int, TextStyleType);
	static auto func = wrapFunction(base::get() + 0x6d810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

TextStyleSection* TextStyleSection::createColoredSection(cocos2d::ccColor3B p0, int p1, int p2) {
        auto ret = TextStyleSection::create(p1, p2, TextStyleType::Colored);
        ret->m_color = p0;
        return ret;
    }

TextStyleSection* TextStyleSection::createDelaySection(int p0, float p1) {
        auto ret = TextStyleSection::create(p0, -1, TextStyleType::Delayed);
        ret->m_delay = p1;
        return ret;
    }

TextStyleSection* TextStyleSection::createInstantSection(int p0, int p1, float p2) {
        auto ret = TextStyleSection::create(p0, p1, TextStyleType::Instant);
        ret->m_instantTime = p2;
        return ret;
    }

TextStyleSection* TextStyleSection::createShakeSection(int p0, int p1, int p2, int p3) {
        auto ret = TextStyleSection::create(p0, p1, TextStyleType::Shake);
        ret->m_shakeIntensity = p2;
        ret->m_shakesPerSecond = p3;
        return ret;
    }

bool TextStyleSection::init(int p0, int p1, TextStyleType p2) {
        m_styleType = p2;
        m_startIndex = p0;
        m_endIndex = p1;
        return true;
    }

auto TimerTriggerGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	throw std::runtime_error("TimerTriggerGameObject::triggerObject not implemented");
}

auto TimerTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("TimerTriggerGameObject::customObjectSetup not implemented");
}

auto TimerTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("TimerTriggerGameObject::getSaveString not implemented");
}

TopArtistsLayer::TopArtistsLayer() {
        m_topArtists = nullptr;
        m_listLayer = nullptr;
        m_loadingCircle = nullptr;
        m_page = 0;
    }

TopArtistsLayer* TopArtistsLayer::create() {
        auto ret = new TopArtistsLayer();
        if (ret->init()) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

auto TopArtistsLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&TopArtistsLayer::init), this);
	using FunctionType = decltype(init())(*)(TopArtistsLayer*);
	static auto func = wrapFunction(base::get() + 0x4b2030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto TopArtistsLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("TopArtistsLayer::registerWithTouchDispatcher not implemented");
}

auto TopArtistsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&TopArtistsLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(TopArtistsLayer*);
	static auto func = wrapFunction(base::get() + 0x84650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto TopArtistsLayer::show() -> decltype(show()) {
	throw std::runtime_error("TopArtistsLayer::show not implemented");
}

auto TopArtistsLayer::loadListFinished(cocos2d::CCArray* p0, char const* p1) -> decltype(loadListFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*, char const*>::func(&TopArtistsLayer::loadListFinished), this);
	using FunctionType = decltype(loadListFinished(p0, p1))(*)(TopArtistsLayer*, cocos2d::CCArray*, char const*);
	static auto func = wrapFunction(base::get() + 0x4b27d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto TopArtistsLayer::loadListFailed(char const* p0) -> decltype(loadListFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&TopArtistsLayer::loadListFailed), this);
	using FunctionType = decltype(loadListFailed(p0))(*)(TopArtistsLayer*, char const*);
	static auto func = wrapFunction(base::get() + 0x4b2830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto TopArtistsLayer::setupPageInfo(gd::string p0, char const* p1) -> decltype(setupPageInfo(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string, char const*>::func(&TopArtistsLayer::setupPageInfo), this);
	using FunctionType = decltype(setupPageInfo(p0, p1))(*)(TopArtistsLayer*, gd::string, char const*);
	static auto func = wrapFunction(base::get() + 0x4b2990, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto TopArtistsLayer::loadPage(int p0) -> decltype(loadPage(p0)) {
	using FunctionType = decltype(loadPage(p0))(*)(TopArtistsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x4b2b70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto TopArtistsLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(TopArtistsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x84620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto TopArtistsLayer::onNextPage(cocos2d::CCObject* sender) -> decltype(onNextPage(sender)) {
	using FunctionType = decltype(onNextPage(sender))(*)(TopArtistsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4b2fe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto TopArtistsLayer::onPrevPage(cocos2d::CCObject* sender) -> decltype(onPrevPage(sender)) {
	using FunctionType = decltype(onPrevPage(sender))(*)(TopArtistsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4b2ff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto TopArtistsLayer::setupLeaderboard(cocos2d::CCArray* p0) -> decltype(setupLeaderboard(p0)) {
	using FunctionType = decltype(setupLeaderboard(p0))(*)(TopArtistsLayer*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x4b2840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto TOSPopup::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&TOSPopup::init), this);
	using FunctionType = decltype(init())(*)(TOSPopup*);
	static auto func = wrapFunction(base::get() + 0x296930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void TOSPopup::keyBackClicked() {}

auto TransformTriggerGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	throw std::runtime_error("TransformTriggerGameObject::triggerObject not implemented");
}

auto TransformTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("TransformTriggerGameObject::customObjectSetup not implemented");
}

auto TransformTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("TransformTriggerGameObject::getSaveString not implemented");
}

auto TriggerControlGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	throw std::runtime_error("TriggerControlGameObject::triggerObject not implemented");
}

auto TriggerControlGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("TriggerControlGameObject::customObjectSetup not implemented");
}

auto TriggerControlGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("TriggerControlGameObject::getSaveString not implemented");
}

auto TutorialLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&TutorialLayer::init), this);
	using FunctionType = decltype(init())(*)(TutorialLayer*);
	static auto func = wrapFunction(base::get() + 0x4b31c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto TutorialLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&TutorialLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(TutorialLayer*);
	static auto func = wrapFunction(base::get() + 0x4b3de0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto TutorialPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("TutorialPopup::keyBackClicked not implemented");
}

auto TutorialPopup::show() -> decltype(show()) {
	throw std::runtime_error("TutorialPopup::show not implemented");
}

UILayer* UILayer::get() {
        if (auto gjbgl = GJBaseGameLayer::get()) return gjbgl->m_uiLayer;
        return nullptr;
    }

void UILayer::draw() {}

auto UILayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&UILayer::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(UILayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4b55a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto UILayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&UILayer::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(UILayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4b5730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto UILayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&UILayer::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(UILayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4b5750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto UILayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	throw std::runtime_error("UILayer::ccTouchCancelled not implemented");
}

auto UILayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("UILayer::registerWithTouchDispatcher not implemented");
}

auto UILayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&UILayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(UILayer*);
	static auto func = wrapFunction(base::get() + 0x4b5300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto UILayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&UILayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(UILayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x4b52e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto UILayer::keyUp(cocos2d::enumKeyCodes p0) -> decltype(keyUp(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&UILayer::keyUp), this);
	using FunctionType = decltype(keyUp(p0))(*)(UILayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x4b52f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto UILayer::handleKeypress(cocos2d::enumKeyCodes p0, bool p1) -> decltype(handleKeypress(p0, p1)) {
	using FunctionType = decltype(handleKeypress(p0, p1))(*)(UILayer*, cocos2d::enumKeyCodes, bool);
	static auto func = wrapFunction(base::get() + 0x4b4c40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto UILayer::init(GJBaseGameLayer* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(UILayer*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x4b3f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto UILayer::onPause(cocos2d::CCObject* sender) -> decltype(onPause(sender)) {
	using FunctionType = decltype(onPause(sender))(*)(UILayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4b53c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto UILayer::processUINodeTouch(GJUITouchEvent p0, int p1, cocos2d::CCPoint p2, GJUINode* p3) -> decltype(processUINodeTouch(p0, p1, p2, p3)) {
	using FunctionType = decltype(processUINodeTouch(p0, p1, p2, p3))(*)(UILayer*, GJUITouchEvent, int, cocos2d::CCPoint, GJUINode*);
	static auto func = wrapFunction(base::get() + 0x4b58d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto UILayer::resetUINodeState() -> decltype(resetUINodeState()) {
	using FunctionType = decltype(resetUINodeState())(*)(UILayer*);
	static auto func = wrapFunction(base::get() + 0x4b4aa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto UIObjectSettingsPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	throw std::runtime_error("UIObjectSettingsPopup::onCustomToggleTriggerValue not implemented");
}

auto UIOptionsLayer::create(bool p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(bool);
	static auto func = wrapFunction(base::get() + 0x2995e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto UIOptionsLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&UIOptionsLayer::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(UIOptionsLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x29c640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto UIOptionsLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&UIOptionsLayer::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(UIOptionsLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x29c790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto UIOptionsLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&UIOptionsLayer::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(UIOptionsLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x29c8c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto UIOptionsLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	throw std::runtime_error("UIOptionsLayer::ccTouchCancelled not implemented");
}

auto UIOptionsLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("UIOptionsLayer::registerWithTouchDispatcher not implemented");
}

auto UIOptionsLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("UIOptionsLayer::onClose not implemented");
}

auto UIOptionsLayer::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("UIOptionsLayer::valueDidChange not implemented");
}

auto UIOptionsLayer::getValue(int p0) -> decltype(getValue(p0)) {
	throw std::runtime_error("UIOptionsLayer::getValue not implemented");
}

auto UIOptionsLayer::init(bool p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(UIOptionsLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x299720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto UIPOptionsLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&UIPOptionsLayer::init), this);
	using FunctionType = decltype(init())(*)(UIPOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x29e170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto UIPOptionsLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	throw std::runtime_error("UIPOptionsLayer::ccTouchBegan not implemented");
}

auto UIPOptionsLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	throw std::runtime_error("UIPOptionsLayer::ccTouchMoved not implemented");
}

auto UIPOptionsLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	throw std::runtime_error("UIPOptionsLayer::ccTouchEnded not implemented");
}

auto UIPOptionsLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	throw std::runtime_error("UIPOptionsLayer::ccTouchCancelled not implemented");
}

auto UIPOptionsLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("UIPOptionsLayer::registerWithTouchDispatcher not implemented");
}

auto UIPOptionsLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("UIPOptionsLayer::onClose not implemented");
}

auto UIPOptionsLayer::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("UIPOptionsLayer::valueDidChange not implemented");
}

auto UIPOptionsLayer::getValue(int p0) -> decltype(getValue(p0)) {
	throw std::runtime_error("UIPOptionsLayer::getValue not implemented");
}

auto UISettingsGameObject::init() -> decltype(init()) {
	throw std::runtime_error("UISettingsGameObject::init not implemented");
}

auto UISettingsGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("UISettingsGameObject::customObjectSetup not implemented");
}

auto UISettingsGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("UISettingsGameObject::getSaveString not implemented");
}

UndoObject::UndoObject() {
        m_objectCopy = nullptr;
        m_objects = nullptr;
        // some of the floats are set to 1.0 but idk which who cares
    }

UndoObject::~UndoObject() {
        if (m_objectCopy) m_objectCopy->release();
        if (m_objects) m_objects->release();
    }

UndoObject* UndoObject::createWithArray(cocos2d::CCArray* arrOfObjects, UndoCommand command) {
        auto* ret = new UndoObject();
        if (ret->init(arrOfObjects, command)) {
            ret->autorelease();
            return ret;
        }
        delete ret;
        return nullptr;
    }

bool UndoObject::init(cocos2d::CCArray* array, UndoCommand command) {
        m_command = command;
        if (array != nullptr) {
            m_objects = cocos2d::CCArray::create();
            m_objects->addObjectsFromArray(array);
            m_objects->retain();
        }
        return true;
    }

auto UndoObject::init(GameObject* p0, UndoCommand p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(UndoObject*, GameObject*, UndoCommand);
	static auto func = wrapFunction(base::get() + 0x2db040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto UpdateAccountSettingsPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&UpdateAccountSettingsPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(UpdateAccountSettingsPopup*);
	static auto func = wrapFunction(base::get() + 0x28db10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto UpdateAccountSettingsPopup::updateSettingsFinished() -> decltype(updateSettingsFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&UpdateAccountSettingsPopup::updateSettingsFinished), this);
	using FunctionType = decltype(updateSettingsFinished())(*)(UpdateAccountSettingsPopup*);
	static auto func = wrapFunction(base::get() + 0x28d790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto UpdateAccountSettingsPopup::updateSettingsFailed() -> decltype(updateSettingsFailed()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&UpdateAccountSettingsPopup::updateSettingsFailed), this);
	using FunctionType = decltype(updateSettingsFailed())(*)(UpdateAccountSettingsPopup*);
	static auto func = wrapFunction(base::get() + 0x28d890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto UploadActionPopup::create(UploadPopupDelegate* delegate, gd::string str) -> decltype(create(delegate, str)) {
	using FunctionType = decltype(create(delegate, str))(*)(UploadPopupDelegate*, gd::string);
	static auto func = wrapFunction(base::get() + 0x28db20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(delegate, str);
}

auto UploadActionPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&UploadActionPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x28e320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void UploadActionPopup::closePopup() {
        this->setKeypadEnabled(false);
        this->removeFromParentAndCleanup(true);
    }

auto UploadActionPopup::init(UploadPopupDelegate* delegate, gd::string str) -> decltype(init(delegate, str)) {
	using FunctionType = decltype(init(delegate, str))(*)(UploadActionPopup*, UploadPopupDelegate*, gd::string);
	static auto func = wrapFunction(base::get() + 0x28dc60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, delegate, str);
}

auto UploadActionPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(UploadActionPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x28e2d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto UploadActionPopup::showFailMessage(gd::string message) -> decltype(showFailMessage(message)) {
	using FunctionType = decltype(showFailMessage(message))(*)(UploadActionPopup*, gd::string);
	static auto func = wrapFunction(base::get() + 0x28e1d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, message);
}

auto UploadActionPopup::showSuccessMessage(gd::string message) -> decltype(showSuccessMessage(message)) {
	using FunctionType = decltype(showSuccessMessage(message))(*)(UploadActionPopup*, gd::string);
	static auto func = wrapFunction(base::get() + 0x28e0c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, message);
}

void UploadListPopup::keyBackClicked() {}

auto UploadListPopup::show() -> decltype(show()) {
	throw std::runtime_error("UploadListPopup::show not implemented");
}

auto UploadListPopup::listUploadFinished(GJLevelList* p0) -> decltype(listUploadFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJLevelList*>::func(&UploadListPopup::listUploadFinished), this);
	using FunctionType = decltype(listUploadFinished(p0))(*)(UploadListPopup*, GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x2f6cc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto UploadListPopup::listUploadFailed(GJLevelList* p0, int p1) -> decltype(listUploadFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<GJLevelList*, int>::func(&UploadListPopup::listUploadFailed), this);
	using FunctionType = decltype(listUploadFailed(p0, p1))(*)(UploadListPopup*, GJLevelList*, int);
	static auto func = wrapFunction(base::get() + 0x2f6e90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto UploadListPopup::init(GJLevelList* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(UploadListPopup*, GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x2f6780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void UploadPopup::keyBackClicked() {}

auto UploadPopup::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&UploadPopup::show), this);
	using FunctionType = decltype(show())(*)(UploadPopup*);
	static auto func = wrapFunction(base::get() + 0x2f7220, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto UploadPopup::levelUploadFinished(GJGameLevel* p0) -> decltype(levelUploadFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJGameLevel*>::func(&UploadPopup::levelUploadFinished), this);
	using FunctionType = decltype(levelUploadFinished(p0))(*)(UploadPopup*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x478710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto UploadPopup::levelUploadFailed(GJGameLevel* p0) -> decltype(levelUploadFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJGameLevel*>::func(&UploadPopup::levelUploadFailed), this);
	using FunctionType = decltype(levelUploadFailed(p0))(*)(UploadPopup*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x4788e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto URLCell::init() -> decltype(init()) {
	throw std::runtime_error("URLCell::init not implemented");
}

auto URLCell::draw() -> decltype(draw()) {
	throw std::runtime_error("URLCell::draw not implemented");
}

auto URLCell::loadFromObject(CCURLObject* p0) -> decltype(loadFromObject(p0)) {
	using FunctionType = decltype(loadFromObject(p0))(*)(URLCell*, CCURLObject*);
	static auto func = wrapFunction(base::get() + 0xbf530, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto VideoOptionsLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x360cd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto VideoOptionsLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&VideoOptionsLayer::init), this);
	using FunctionType = decltype(init())(*)(VideoOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x360df0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto VideoOptionsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&VideoOptionsLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(VideoOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x362c60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto VideoOptionsLayer::createToggleButton(gd::string p0, cocos2d::SEL_MenuHandler p1, bool p2, cocos2d::CCMenu* p3, cocos2d::CCPoint p4, float p5, float p6, bool p7, cocos2d::CCArray* p8) -> decltype(createToggleButton(p0, p1, p2, p3, p4, p5, p6, p7, p8)) {
	using FunctionType = decltype(createToggleButton(p0, p1, p2, p3, p4, p5, p6, p7, p8))(*)(VideoOptionsLayer*, gd::string, cocos2d::SEL_MenuHandler, bool, cocos2d::CCMenu*, cocos2d::CCPoint, float, float, bool, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x362c70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7, p8);
}

auto VideoOptionsLayer::onAdvanced(cocos2d::CCObject* sender) -> decltype(onAdvanced(sender)) {
	using FunctionType = decltype(onAdvanced(sender))(*)(VideoOptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x362130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto VideoOptionsLayer::onApply(cocos2d::CCObject* sender) -> decltype(onApply(sender)) {
	using FunctionType = decltype(onApply(sender))(*)(VideoOptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x362720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto VideoOptionsLayer::onBorderless(cocos2d::CCObject* sender) -> decltype(onBorderless(sender)) {
	using FunctionType = decltype(onBorderless(sender))(*)(VideoOptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x362280, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto VideoOptionsLayer::onBorderlessFix(cocos2d::CCObject* sender) -> decltype(onBorderlessFix(sender)) {
	using FunctionType = decltype(onBorderlessFix(sender))(*)(VideoOptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3622a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto VideoOptionsLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(VideoOptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x362be0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto VideoOptionsLayer::onFullscreen(cocos2d::CCObject* sender) -> decltype(onFullscreen(sender)) {
	using FunctionType = decltype(onFullscreen(sender))(*)(VideoOptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x362260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto VideoOptionsLayer::onResolutionNext(cocos2d::CCObject* sender) -> decltype(onResolutionNext(sender)) {
	using FunctionType = decltype(onResolutionNext(sender))(*)(VideoOptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3623a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto VideoOptionsLayer::onResolutionPrev(cocos2d::CCObject* sender) -> decltype(onResolutionPrev(sender)) {
	using FunctionType = decltype(onResolutionPrev(sender))(*)(VideoOptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x362390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto VideoOptionsLayer::onTextureQualityNext(cocos2d::CCObject* sender) -> decltype(onTextureQualityNext(sender)) {
	using FunctionType = decltype(onTextureQualityNext(sender))(*)(VideoOptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3622d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto VideoOptionsLayer::onTextureQualityPrev(cocos2d::CCObject* sender) -> decltype(onTextureQualityPrev(sender)) {
	using FunctionType = decltype(onTextureQualityPrev(sender))(*)(VideoOptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3622c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto VideoOptionsLayer::toggleResolution() -> decltype(toggleResolution()) {
	using FunctionType = decltype(toggleResolution())(*)(VideoOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x3624c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto VideoOptionsLayer::updateResolution(int p0) -> decltype(updateResolution(p0)) {
	using FunctionType = decltype(updateResolution(p0))(*)(VideoOptionsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x3623b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto VideoOptionsLayer::updateTextureQuality(int p0) -> decltype(updateTextureQuality(p0)) {
	using FunctionType = decltype(updateTextureQuality(p0))(*)(VideoOptionsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x3622e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto WorldLevelPage::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("WorldLevelPage::keyBackClicked not implemented");
}

auto WorldLevelPage::show() -> decltype(show()) {
	throw std::runtime_error("WorldLevelPage::show not implemented");
}

auto WorldSelectLayer::onExit() -> decltype(onExit()) {
	throw std::runtime_error("WorldSelectLayer::onExit not implemented");
}

auto WorldSelectLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("WorldSelectLayer::keyBackClicked not implemented");
}

auto WorldSelectLayer::scrollLayerWillScrollToPage(BoomScrollLayer* p0, int p1) -> decltype(scrollLayerWillScrollToPage(p0, p1)) {
	throw std::runtime_error("WorldSelectLayer::scrollLayerWillScrollToPage not implemented");
}

auto WorldSelectLayer::scrollLayerScrolledToPage(BoomScrollLayer* p0, int p1) -> decltype(scrollLayerScrolledToPage(p0, p1)) {
	throw std::runtime_error("WorldSelectLayer::scrollLayerScrolledToPage not implemented");
}

auto WorldSelectLayer::scrollLayerMoved(cocos2d::CCPoint p0) -> decltype(scrollLayerMoved(p0)) {
	throw std::runtime_error("WorldSelectLayer::scrollLayerMoved not implemented");
}
